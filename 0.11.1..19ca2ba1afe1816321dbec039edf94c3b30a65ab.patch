diff --git a/.gitignore b/.gitignore
index ee2bfff..f7d108c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -71,3 +71,6 @@ doc/build
 # spack files
 .spack*
 spack.lock
+
+# Code editors
+.vscode
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4880124..a559722 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -57,6 +57,12 @@ IF(ENABLE_LUSTRE)
   # - LUSTRE_STAT
 ENDIF(ENABLE_LUSTRE)
 
+OPTION(ENABLE_HPSS "Enable optimization and features for HPSSFS-FUSE" OFF)
+MESSAGE(STATUS "ENABLE_HPSS: ${ENABLE_HPSS}")
+IF(ENABLE_HPSS)
+  ADD_DEFINITIONS(-DHPSS_SUPPORT)
+ENDIF(ENABLE_HPSS)
+
 OPTION(ENABLE_GPFS "Enable GFPS/Spectrum Scale support")
 MESSAGE(STATUS "ENABLE_GPFS: ${ENABLE_GPFS}")
 IF(ENABLE_GPFS)
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index d7c9a01..4ffcf16 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -3,17 +3,12 @@
 *Thank you for taking the time to contribute!*
 
 ## Table of Contents
-[Resources](#resources)
-
 [How To Contribute](#how-to-contribute)
   * [Reporting an Issue & Feature Suggestions](#reporting-an-issue--feature-suggestions)
   * [Pull Requests](#pull-requests)
   * [License](#license)
   * [Contributor's Declaration](#contributors-declaration)
 
-## Resources
-[mpiFileUtils Google Group](https://groups.google.com/forum/#!forum/mpifileutils)
-
 ## How To Contribute
 
 ### Reporting an Issue & Feature Suggestions
diff --git a/dist/CMakeLists.txt b/dist/CMakeLists.txt
index 3b6c581..102d1b5 100644
--- a/dist/CMakeLists.txt
+++ b/dist/CMakeLists.txt
@@ -57,6 +57,12 @@ IF(ENABLE_LUSTRE)
   # - LUSTRE_STAT
 ENDIF(ENABLE_LUSTRE)
 
+OPTION(ENABLE_HPSS "Enable optimization and features for HPSSFS-FUSE" OFF)
+MESSAGE(STATUS "ENABLE_HPSS: ${ENABLE_HPSS}")
+IF(ENABLE_HPSS)
+  ADD_DEFINITIONS(-DHPSS_SUPPORT)
+ENDIF(ENABLE_HPSS)
+
 OPTION(ENABLE_GPFS "Enable GFPS/Spectrum Scale support")
 MESSAGE(STATUS "ENABLE_GPFS: ${ENABLE_GPFS}")
 IF(ENABLE_GPFS)
diff --git a/doc/rst/build.rst b/doc/rst/build.rst
index 047ba87..81bdf76 100644
--- a/doc/rst/build.rst
+++ b/doc/rst/build.rst
@@ -34,7 +34,7 @@ To be certain of compatibility, it is recommended that one install libarchive-3.
    mkdir install
    installdir=`pwd`/install
 
-   wget https://github.com/libarchive/libarchive/releases/download/3.5.1/libarchive-3.5.1.tar.gz
+   wget https://github.com/libarchive/libarchive/releases/download/v3.5.1/libarchive-3.5.1.tar.gz
    tar -zxf libarchive-3.5.1.tar.gz
    cd libarchive-3.5.1
      ./configure --prefix=$installdir
@@ -66,6 +66,7 @@ Additional CMake options:
 * :code:`-DENABLE_XATTRS=[ON/OFF]` : use extended attributes and libattr, defaults to :code:`ON`
 * :code:`-DENABLE_LUSTRE=[ON/OFF]` : specialization for Lustre, defaults to :code:`OFF`
 * :code:`-DENABLE_GPFS=[ON/OFF]` : specialization for GPFS, defaults to :code:`OFF`
+* :code:`-DENABLE_HPSS=[ON/OFF]` : specialization for HPSS, defaults to :code:`OFF`
 * :code:`-DENABLE_EXPERIMENTAL=[ON/OFF]` : build experimental tools, defaults to :code:`OFF`
 
 -------------------------------------------
@@ -102,7 +103,7 @@ Spack
 
 To use `Spack <https://github.com/spack/spack>`_, it is recommended that one first create a `packages.yaml` file to list system-provided packages, like MPI.
 Without doing this, Spack will fetch and install an MPI library that may not work on your system.
-Make sure that you've set up spack in your shell (see `these instructions <https://spack.readthedocs.io/en/latest/getting_started.html>`_).
+Make sure that you've set up Spack in your shell (see `these instructions <https://spack.readthedocs.io/en/latest/getting_started.html>`_).
 
 Once Spack has been configured, mpiFileUtils can be installed as:
 
@@ -114,7 +115,7 @@ or to enable all features:
 
 .. code-block:: Bash
 
-    spack install mpifileutils +lustre +gpfs +experimental
+    spack install mpifileutils +lustre +gpfs +hpss +experimental
 
 ----------------------------
 Development build with CMake
@@ -135,7 +136,7 @@ which can be done with the following commands:
      wget https://github.com/hpc/libcircle/releases/download/v0.3/libcircle-0.3.0.tar.gz
      wget https://github.com/llnl/lwgrp/releases/download/v1.0.4/lwgrp-1.0.4.tar.gz
      wget https://github.com/llnl/dtcmp/releases/download/v1.1.4/dtcmp-1.1.4.tar.gz
-     wget https://github.com/libarchive/libarchive/releases/download/3.5.1/libarchive-3.5.1.tar.gz
+     wget https://github.com/libarchive/libarchive/releases/download/v3.5.1/libarchive-3.5.1.tar.gz
 
      tar -zxf libcircle-0.3.0.tar.gz
      cd libcircle-0.3.0
@@ -205,5 +206,5 @@ Thus, the commands to build become:
    cd ../build
    cmake ../mpifileutils
 
-The other way to use spack is to create a "view" to the installed dependencies.
+The other way to use Spack is to create a "view" to the installed dependencies.
 Details on this are coming soon.
diff --git a/doc/rst/dcmp.1.rst b/doc/rst/dcmp.1.rst
index acf51c6..397c301 100644
--- a/doc/rst/dcmp.1.rst
+++ b/doc/rst/dcmp.1.rst
@@ -60,6 +60,10 @@ OPTIONS
 
    Use O_DIRECT to avoid caching file data.
 
+.. option:: --open-noatime
+
+   Open files with O_NOATIME flag.
+
 .. option:: --progress N
 
    Print progress message to stdout approximately every N seconds.
diff --git a/doc/rst/dcp.1.rst b/doc/rst/dcp.1.rst
index 00f3d33..ff3a20b 100644
--- a/doc/rst/dcp.1.rst
+++ b/doc/rst/dcp.1.rst
@@ -49,7 +49,7 @@ OPTIONS
    DFS API, and all other containers use the DAOS object API.
    Values must be in {DFS, DAOS}.
 
-.. option:: --daos-preserve FILENAME 
+.. option:: --daos-preserve FILENAME
 
    Option to turn on metadata preservation in DAOS. This should
    be used in the case that data is being moved to/from DAOS. For instance,
@@ -82,6 +82,10 @@ OPTIONS
 
    Use O_DIRECT to avoid caching file data.
 
+.. option:: --open-noatime
+
+   Open files with O_NOATIME flag.
+
 .. option:: -S, --sparse
 
    Create sparse files when possible.
@@ -92,6 +96,16 @@ OPTIONS
    The number of seconds must be a non-negative integer.
    A value of 0 disables progress messages.
 
+.. option:: -G, --gid GID
+
+   Set the effective group ID to perform the copy operation. The copy
+   may fail if the group does not have sufficient privileges.
+
+.. option:: -U, --uid UID
+
+   Set the effective user ID to perform the copy operation. The copy
+   may fail if the user does not have sufficient privileges.
+
 .. option:: -v, --verbose
 
    Run in verbose mode.
diff --git a/doc/rst/ddup.1.rst b/doc/rst/ddup.1.rst
index 33e0313..d47bc98 100644
--- a/doc/rst/ddup.1.rst
+++ b/doc/rst/ddup.1.rst
@@ -20,6 +20,10 @@ Multiple sets of duplicate files can be matched using this final reported hash.
 OPTIONS
 -------
 
+.. option:: --open-noatime
+
+   Open files with O_NOATIME flag, if possible.
+
 .. option:: -d, --debug LEVEL
 
    Set verbosity level.  LEVEL can be one of: fatal, err, warn, info, dbg.
diff --git a/doc/rst/dsync.1.rst b/doc/rst/dsync.1.rst
index 402ee05..248bf43 100644
--- a/doc/rst/dsync.1.rst
+++ b/doc/rst/dsync.1.rst
@@ -83,6 +83,10 @@ OPTIONS
 
    Use O_DIRECT to avoid caching file data.
 
+.. option:: --open-noatime
+
+   Open files with O_NOATIME flag.
+
 .. option:: --link-dest DIR
 
    Create hardlink in DEST to files in DIR when file is unchanged
diff --git a/doc/rst/dtar.1.rst b/doc/rst/dtar.1.rst
index 5fa4e19..f732037 100644
--- a/doc/rst/dtar.1.rst
+++ b/doc/rst/dtar.1.rst
@@ -119,6 +119,10 @@ OPTIONS
    Apply recorded flags to extracted files.
    Default does not record or extract flags.
 
+.. option:: --open-noatime
+
+   Open source files with O_NOATIME flag when creating archive.
+
 .. option:: --fsync
 
    Call fsync before closing files after writing.
diff --git a/doc/rst/proj-design.rst b/doc/rst/proj-design.rst
index b404696..cb18b90 100644
--- a/doc/rst/proj-design.rst
+++ b/doc/rst/proj-design.rst
@@ -32,7 +32,7 @@ Portability
 -----------
 
 The tools are intended to support common file systems used in HPC centers, like
-Lustre, GPFS, and NFS. Additionally, methods in the library should be portable
+Lustre, GPFS, NFS, and HPSS. Additionally, methods in the library should be portable
 and efficient across multiple file systems. Tool and library users can rely on
 mpiFileUtils to provide portable and performant implementations.
 
diff --git a/mpifileutils.spec b/mpifileutils.spec
index b3a0f81..94619f0 100644
--- a/mpifileutils.spec
+++ b/mpifileutils.spec
@@ -17,15 +17,12 @@ File utilities designed for scalability and performance.
 %setup -q
 
 %build
-#topdir=`pwd`
-#installdir=$topdir/install
-
-cmake ./ -DWITH_DTCMP_PREFIX=${installdir} -DWITH_LibCircle_PREFIX=${installdir} -DCMAKE_INSTALL_PREFIX=%{buildroot} -DENABLE_LUSTRE=ON -DENABLE_XATTRS=ON
-make
+%{cmake} ./ -DWITH_DTCMP_PREFIX=${installdir} -DWITH_LibCircle_PREFIX=${installdir} -DCMAKE_INSTALL_PREFIX=%{buildroot} -DENABLE_LUSTRE=ON -DENABLE_XATTRS=ON
+%{cmake_build}
 
 %install
 rm -rf %{buildroot}
-make install DESTDIR=%{buildroot}
+%{cmake_install}
 
 
 %files
diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt
index 509ba35..5178c1a 100644
--- a/src/common/CMakeLists.txt
+++ b/src/common/CMakeLists.txt
@@ -15,6 +15,7 @@ LIST(APPEND libmfu_install_headers
   mfu_param_path.h
   mfu_path.h
   mfu_pred.h
+  mfu_proc.h
   mfu_progress.h
   mfu_util.h
   )
@@ -46,6 +47,7 @@ LIST(APPEND libmfu_srcs
   mfu_param_path.c
   mfu_path.c
   mfu_pred.c
+  mfu_proc.c
   mfu_progress.c
   mfu_util.c
   strmap.c
diff --git a/src/common/mfu.h b/src/common/mfu.h
index 108f0fb..dcf7de8 100644
--- a/src/common/mfu.h
+++ b/src/common/mfu.h
@@ -27,6 +27,7 @@ extern "C" {
 #include "mfu_param_path.h"
 #include "mfu_flist.h"
 #include "mfu_pred.h"
+#include "mfu_proc.h"
 #include "mfu_progress.h"
 #include "mfu_bz2.h"
 
diff --git a/src/common/mfu_daos.c b/src/common/mfu_daos.c
index 8f53133..2dbf8cf 100644
--- a/src/common/mfu_daos.c
+++ b/src/common/mfu_daos.c
@@ -210,13 +210,11 @@ static int daos_check_args(
     bool have_src_cont  = strlen(da->src_cont) ? true : false;
     bool have_dst_pool  = strlen(da->dst_pool) ? true : false;
     bool have_dst_cont  = strlen(da->dst_cont) ? true : false;
-    bool have_prefix    = (da->dfs_prefix != NULL);
 
     /* Determine whether any DAOS arguments are supplied. 
      * If not, then there is nothing to check. */
     *flag_daos_args = 0;
-    if (have_src_pool || have_src_cont || have_dst_pool || have_dst_cont
-            || have_prefix) {
+    if (have_src_pool || have_src_cont || have_dst_pool || have_dst_cont) {
         *flag_daos_args = 1;
     }
     if ((have_src_path && (strncmp(src_path, "daos:", 5) == 0)) ||
@@ -276,37 +274,6 @@ static int daos_check_args(
     return rc;
 }
 
-/* Checks if the prefix is valid.
- * If valid, returns matching string into suffix */
-static bool daos_check_prefix(
-    char* path,
-    const char* dfs_prefix,
-    char** suffix)
-{
-    bool is_prefix = false;
-    int prefix_len = strlen(dfs_prefix);
-    int path_len = strlen(path);
-
-    /* ignore trailing '/' on the prefix */
-    if (dfs_prefix[prefix_len-1] == '/') {
-        prefix_len--;
-    }
-
-    /* figure out if dfs_prefix is a prefix of the file path */
-    if (strncmp(path, dfs_prefix, prefix_len) == 0) {
-        /* if equal, assume root */
-        if (path_len == prefix_len) {
-            *suffix = strdup("/");
-            is_prefix = true;
-        }
-        /* if path is longer, it must start with '/' */
-        else if (path_len > prefix_len && path[prefix_len] == '/') {
-            *suffix = strdup(path + prefix_len);
-            is_prefix = true;
-        }
-    }
-    return is_prefix;
-}
 
 /*
  * Parse a path of the format:
@@ -341,6 +308,9 @@ int daos_parse_path(
         } else {
             strncpy(path, dattr.da_rel_path, path_len);
         }
+    } else if (strncmp(path, "daos:", 5) == 0) {
+        /* Actual error, since we expect a daos path */
+        rc = -1;
     } else {
         /* If basename does not exist yet then duns_resolve_path will fail even
         * if dirname is a UNS path */
@@ -387,9 +357,6 @@ int daos_parse_path(
             snprintf(*pool_str, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", dattr.da_pool);
             snprintf(*cont_str, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", dattr.da_cont);
             strncpy(path, dattr.da_rel_path, path_len);
-        } else if (strncmp(path, "daos:", 5) == 0) {
-            /* Actual error, since we expect a daos path */
-            rc = -1;
         } else {
             /* We didn't parse a daos path,
             * but we weren't necessarily looking for one */
@@ -415,106 +382,39 @@ static int daos_set_paths(
 {
     int     rc = 0;
     bool    have_dst = (numpaths > 1);
-    bool    prefix_on_src = false;
-    bool    prefix_on_dst = false;
-    char*   prefix_path = NULL;
     char*   src_path = NULL;
     char*   dst_path = NULL;
 
-    /* find out if a dfs_prefix is being used,
-     * if so, then that means that the container
-     * is not being copied from the root of the
-     * UNS path  */
-    if (da->dfs_prefix != NULL) {
-        char prefix_pool[DAOS_PROP_LABEL_MAX_LEN + 1];
-        char prefix_cont[DAOS_PROP_LABEL_MAX_LEN + 1];
-        int prefix_rc;
-
-        size_t prefix_len = strlen(da->dfs_prefix);
-        prefix_path = strndup(da->dfs_prefix, prefix_len);
-        if (prefix_path == NULL) {
-            MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for DAOS prefix.");
-            rc = 1;
-            goto out;
-        }
-
-        memset(prefix_pool, '\0', DAOS_PROP_LABEL_MAX_LEN + 1);
-        memset(prefix_cont, '\0', DAOS_PROP_LABEL_MAX_LEN + 1);
-
-        /* Get the pool/container uuids from the prefix */
-        prefix_rc = daos_parse_path(prefix_path, prefix_len,
-                                    &prefix_pool, &prefix_cont);
-        if (prefix_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS Prefix UNS path");
-            rc = 1;
-            goto out;
-        }
-
-        /* In case the user tries to give a sub path in the UNS path */
-        if (strcmp(prefix_path, "/") != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS prefix must be a UNS path");
-            rc = 1;
-            goto out;
-        }
-
-        /* Check if the prefix matches the source */
-        prefix_on_src = daos_check_prefix(argpaths[0], da->dfs_prefix, &da->src_path);
-        if (prefix_on_src) {
-            snprintf(da->src_pool, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_pool);
-            snprintf(da->src_cont, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_cont);
-            argpaths[0] = da->src_path;
-        }
-
-        if (have_dst) {
-            /* Check if the prefix matches the destination */
-            prefix_on_dst = daos_check_prefix(argpaths[1], da->dfs_prefix, &da->dst_path);
-            if (prefix_on_dst) {
-                snprintf(da->dst_pool, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_pool);
-                snprintf(da->dst_cont, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_cont);
-                argpaths[1] = da->dst_path;
-            }
-        }
-
-        if (!prefix_on_src && !prefix_on_dst) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS prefix does not match source or destination");
-            rc = 1;
-            goto out;
-        }
-    }
-
     /*
-     * For the source and destination paths,
-     * if they are not using a prefix,
-     * then just directly try to parse a DAOS path.
+     * Try to parse a DAOS source and/or destination path.
      */
-    if (!prefix_on_src) {
-        size_t src_len = strlen(argpaths[0]);
-        src_path = strndup(argpaths[0], src_len);
-        if (src_path == NULL) {
-            MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
+    size_t src_len = strlen(argpaths[0]);
+    src_path = strndup(argpaths[0], src_len);
+    if (src_path == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
+        rc = 1;
+        goto out;
+    }
+    int src_rc = daos_parse_path(src_path, src_len, &da->src_pool, &da->src_cont);
+    if (src_rc == 0) {
+        if (strlen(da->src_cont) == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source pool requires a source container.");
             rc = 1;
             goto out;
         }
-        int src_rc = daos_parse_path(src_path, src_len, &da->src_pool, &da->src_cont);
-        if (src_rc == 0) {
-            if (strlen(da->src_cont) == 0) {
-                MFU_LOG(MFU_LOG_ERR, "Source pool requires a source container.");
-                rc = 1;
-                goto out;
-            }
-            argpaths[0] = da->src_path = strdup(src_path);
-            if (argpaths[0] == NULL) {
-                MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
-                rc = 1;
-                goto out;
-            }
-        } else if (src_rc == -1) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS source path: daos://<pool>/<cont>[/<path>]");
+        argpaths[0] = da->src_path = strdup(src_path);
+        if (argpaths[0] == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
             rc = 1;
             goto out;
         }
+    } else if (src_rc == -1) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS source path: daos://<pool>/<cont>[/<path>]");
+        rc = 1;
+        goto out;
     }
-    if (have_dst && !prefix_on_dst) {
+
+    if (have_dst) {
         size_t dst_len = strlen(argpaths[1]);
         dst_path = strndup(argpaths[1], dst_len);
         if (dst_path == NULL) {
@@ -535,9 +435,7 @@ static int daos_set_paths(
             rc = 1;
             goto out;
         }
-    }
 
-    if (have_dst) {
         int dst_cont_len = strlen(da->dst_cont);
         *dst_cont_passed = dst_cont_len > 0 ? true : false;
         /* Generate a new container uuid if only a pool was given. */
@@ -547,13 +445,12 @@ static int daos_set_paths(
     }
 
 out:
-    mfu_free(&prefix_path);
     mfu_free(&src_path);
     mfu_free(&dst_path);
     return rc;
 }
 
-static int daos_get_cont_type(
+static int mfu_daos_get_cont_type(
     daos_handle_t coh,
     enum daos_cont_props* type)
 {
@@ -619,7 +516,7 @@ out:
  * Try to set the file type based on the container type,
  * using api as a guide.
  */
-static int daos_set_api_cont_type(
+static int mfu_daos_set_api_cont_type(
     mfu_file_t* mfu_file,
     enum daos_cont_props cont_type,
     daos_api_t api)
@@ -745,10 +642,10 @@ static int cont_get_props(daos_handle_t coh, daos_prop_t** _props,
     daos_prop_t*    prop_acl = NULL;
     daos_prop_t*    props_merged = NULL;
     /* total amount of properties to allocate */
-    uint32_t        total_props = 15;
+    uint32_t        total_props = 16;
     /* minimum number of properties that are always allocated/used to start
      * count */
-    int             prop_index = 15;
+    int             prop_index = 16;
 
     if (get_oid) {
         total_props++;
@@ -790,6 +687,7 @@ static int cont_get_props(daos_handle_t coh, daos_prop_t** _props,
     props->dpp_entries[12].dpe_type = DAOS_PROP_CO_DEDUP;
     props->dpp_entries[13].dpe_type = DAOS_PROP_CO_DEDUP_THRESHOLD;
     props->dpp_entries[14].dpe_type = DAOS_PROP_CO_EC_CELL_SZ;
+    props->dpp_entries[15].dpe_type = DAOS_PROP_CO_SCRUBBER_DISABLED;
 
     /* Conditionally get the OID. Should always be true for serialization. */
     if (get_oid) {
@@ -1115,7 +1013,7 @@ void daos_bcast_handle(
 }
 
 /* connect to DAOS pool, and then open container */
-int daos_connect(
+int mfu_daos_connect(
   int rank,
   daos_args_t* da,
   char (*pool)[],
@@ -1124,7 +1022,9 @@ int daos_connect(
   daos_handle_t* coh,
   bool force_serialize,
   bool connect_pool,
+  unsigned int pool_connect_flags,
   bool create_cont,
+  unsigned int cont_open_flags,
   bool require_new_cont,
   bool preserve,
   mfu_file_t* mfu_src_file,
@@ -1161,12 +1061,12 @@ int daos_connect(
         }
 #endif
         /* Connect to DAOS pool */
-        if (connect_pool) {
+        if (connect_pool && !daos_handle_is_valid(*poh)) {
             daos_pool_info_t pool_info = {0};
 #if DAOS_API_VERSION_MAJOR < 1
-            rc = daos_pool_connect(*pool, NULL, NULL, DAOS_PC_RW, poh, &pool_info, NULL);
+            rc = daos_pool_connect(*pool, NULL, NULL, pool_connect_flags, poh, &pool_info, NULL);
 #else
-            rc = daos_pool_connect(*pool, NULL, DAOS_PC_RW, poh, &pool_info, NULL);
+            rc = daos_pool_connect(*pool, NULL, pool_connect_flags, poh, &pool_info, NULL);
 #endif
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to connect to pool: "DF_RC, DP_RC(rc));
@@ -1182,9 +1082,11 @@ int daos_connect(
              * If nothing is passed in for destination a uuid is always generated
              * unless user passed one in, because destination container labels are
              * not generated */
-            rc = daos_cont_open(*poh, da->dst_cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+            char cont_str[130];
+            uuid_unparse(da->dst_cont_uuid, cont_str);
+            rc = daos_cont_open(*poh, cont_str, cont_open_flags, coh, &co_info, NULL);
         } else {
-            rc = daos_cont_open(*poh, *cont, DAOS_COO_RW, coh, &co_info, NULL);
+            rc = daos_cont_open(*poh, *cont, cont_open_flags, coh, &co_info, NULL);
         }
         if (rc != 0) {
             if (rc != -DER_NONEXIST || !create_cont) {
@@ -1246,7 +1148,7 @@ int daos_connect(
                     /* if nothing is passed in for destination a uuid is always
                      * generated unless user passed one in, destination container
                      * labels are not generated */
-                    rc = dfs_cont_create(*poh, da->dst_cont_uuid, &attr, NULL, NULL);
+                    rc = dfs_cont_create(*poh, &da->dst_cont_uuid, &attr, NULL, NULL);
                 }
                 if (rc != 0) {
                     MFU_LOG(MFU_LOG_ERR, "Failed to create container: (%d %s)", rc, strerror(rc));
@@ -1256,7 +1158,7 @@ int daos_connect(
                 if (dst_cont_passed && !is_uuid) {
                     rc = daos_cont_create_with_label(*poh, *cont, props, &da->dst_cont_uuid, NULL);
                 } else {
-                    rc = daos_cont_create(*poh, da->dst_cont_uuid, props, NULL);
+                    rc = daos_cont_create(*poh, &da->dst_cont_uuid, props, NULL);
                 }
                 if (rc != 0) {
                     MFU_LOG(MFU_LOG_ERR, "Failed to create container: "DF_RC, DP_RC(rc));
@@ -1273,14 +1175,12 @@ int daos_connect(
             }
 
             /* try to open it again */
-            if (dst_cont_passed) {
-                if (is_uuid) {
-                    rc = daos_cont_open(*poh, da->dst_cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
-                } else {
-                    rc = daos_cont_open(*poh, *cont, DAOS_COO_RW, coh, &co_info, NULL);
-                }
+            if (dst_cont_passed && !is_uuid) {
+                rc = daos_cont_open(*poh, *cont, cont_open_flags, coh, &co_info, NULL);
             } else {
-                rc = daos_cont_open(*poh, da->dst_cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+                char cont_str[130];
+                uuid_unparse(da->dst_cont_uuid, cont_str);
+                rc = daos_cont_open(*poh, cont_str, cont_open_flags, coh, &co_info, NULL);
             }
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to open container: "DF_RC, DP_RC(rc));
@@ -1436,7 +1336,6 @@ daos_args_t* daos_args_new(void)
     da->dst_poh    = DAOS_HDL_INVAL;
     da->src_coh    = DAOS_HDL_INVAL;
     da->dst_coh    = DAOS_HDL_INVAL;
-    da->dfs_prefix = NULL;
     da->src_path   = NULL;
     da->dst_path   = NULL;
 
@@ -1470,7 +1369,6 @@ void daos_args_delete(daos_args_t** pda)
 {
     if (pda != NULL) {
         daos_args_t* da = *pda;
-        mfu_free(&da->dfs_prefix);
         mfu_free(&da->src_path);
         mfu_free(&da->dst_path);
         mfu_free(&da->daos_preserve_path);
@@ -1639,10 +1537,7 @@ int daos_setup(
         }
     }
 
-    /* Figure out if daos path is the src or dst,
-     * using UNS path, then chop off UNS path
-     * prefix since the path is mapped to the root
-     * of the container in the DAOS DFS mount */
+    /* Figure out if daos path is the src or dst */
     if (!local_daos_error) {
         tmp_rc = daos_set_paths(rank, argpaths, numpaths, da, &dst_cont_passed);
         if (tmp_rc != 0) {
@@ -1661,8 +1556,7 @@ int daos_setup(
     }
 
     /* Make sure there weren't any errors before continuing.
-     * Since daos_connect has a collective broadcast.
-     * we have to make sure same_pool below is valid. */
+     * Since mfu_daos_connect has a collective broadcast. */
     if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
         tmp_rc = daos_fini();
         return 1;
@@ -1676,10 +1570,16 @@ int daos_setup(
     bool have_src_cont  = strlen(da->src_cont) > 0 ? true : false;
     bool have_dst_pool  = strlen(da->dst_pool) > 0 ? true : false;
 
-    /* Check if containers are in the same pool */
-    bool same_pool = (strcmp(da->src_pool, da->dst_pool) == 0);
+    /* Need W on destination pools for creating a container */
+    unsigned int src_pool_connect_flags = DAOS_PC_RO;
+    unsigned int dst_pool_connect_flags = DAOS_PC_RW;
+
+    /* For POSIX containers, the source only needs read, but the destination needs read and write.
+     * For DAOS (object-level), both containers need read and write.
+     * Open the source with RO first, then elevate to RW if needed below. */
+    unsigned int src_cont_open_flags = DAOS_COO_RO;
+    unsigned int dst_cont_open_flags = DAOS_COO_RW;
 
-    bool connect_pool = true;
     bool create_cont = false;
     bool require_new_cont = false;
     bool preserve = false;
@@ -1694,28 +1594,52 @@ int daos_setup(
             local_daos_error = true;
             goto out;
         }
-        tmp_rc = daos_connect(rank, da, &da->src_pool, &da->src_cont,
-                              &da->src_poh, &da->src_coh, false,
-                              connect_pool, create_cont, require_new_cont,
-                              preserve, mfu_src_file, dst_cont_passed);
+        tmp_rc = mfu_daos_connect(rank, da, &da->src_pool, &da->src_cont,
+                                  &da->src_poh, &da->src_coh, false,
+                                  true, src_pool_connect_flags, create_cont, src_cont_open_flags, require_new_cont,
+                                  preserve, mfu_src_file, dst_cont_passed);
         if (tmp_rc != 0) {
-            /* tmp_rc from daos_connect is collective */
+            /* tmp_rc from mfu_daos_connect is collective */
             local_daos_error = true;
             goto out;
         }
         /* Get the container type */
-        tmp_rc = daos_get_cont_type(da->src_coh, &da->src_cont_type);
+        tmp_rc = mfu_daos_get_cont_type(da->src_coh, &da->src_cont_type);
         if (tmp_rc != 0) {
             /* ideally, this should be the same for each process */
             local_daos_error = true;
             goto out;
         }
         /* Set the src api based on the container type */
-        tmp_rc = daos_set_api_cont_type(mfu_src_file, da->src_cont_type, da->api);
+        tmp_rc = mfu_daos_set_api_cont_type(mfu_src_file, da->src_cont_type, da->api);
         if (tmp_rc != 0) {
             local_daos_error = true;
             goto out;
         }
+        /* If using the DAOS API, we need to elevate permissions to RW for creating a snapshot */
+        if (mfu_src_file->type == DAOS) {
+            MPI_Barrier(MPI_COMM_WORLD);
+
+            tmp_rc = daos_cont_close(da->src_coh, NULL);
+            if (tmp_rc != 0) {
+                local_daos_error = true;
+                goto out;
+            }
+            da->src_coh = DAOS_HDL_INVAL;
+
+            /* Re-open with RW */
+            src_cont_open_flags = DAOS_COO_RW;
+            tmp_rc = mfu_daos_connect(rank, da, &da->src_pool, &da->src_cont,
+                                      &da->src_poh, &da->src_coh, false,
+                                      true, src_pool_connect_flags, create_cont, src_cont_open_flags, require_new_cont,
+                                      preserve, mfu_src_file, dst_cont_passed);
+            if (tmp_rc != 0) {
+                /* tmp_rc from mfu_daos_connect is collective */
+                local_daos_error = true;
+                goto out;
+            }
+        }
+
         /* Sanity check before we create a new container */
         if (da->src_cont_type != DAOS_PROP_CO_LAYOUT_POSIX) {
             if (strcmp(da->src_path, "/") != 0) {
@@ -1729,7 +1653,7 @@ int daos_setup(
     }
 
     /* If we're using the DAOS API, the destination container cannot
-     * exist already, unless overriden by allow_exist_dst_cont. */
+     * exist already, unless overridden by allow_exist_dst_cont. */
     if (mfu_src_file->type != POSIX && mfu_src_file->type != DFS && !da->allow_exist_dst_cont) {
         require_new_cont = true;
     }
@@ -1753,11 +1677,11 @@ int daos_setup(
         create_cont = true;
         /* do check that src is POSIX and since dst has a pool,
          * then the dst *should* always be DFS, but this is not set
-         * on the destintaion until after daos_connect is called, and
+         * on the destintaion until after mfu_daos_connect is called, and
          * we should read the properties *before* the container is
          * created. We do not have the destination container type
          * here yet which is why extra check is used then passed
-         * to daos_connect */
+         * to mfu_daos_connect */
         if (da->daos_preserve) {
             if (mfu_src_file->type == POSIX) {
                 preserve = true; 
@@ -1769,26 +1693,17 @@ int daos_setup(
                 goto out;
             }
         }
-        if (same_pool) {
-            connect_pool = false;
-            tmp_rc = daos_connect(rank, da, &da->dst_pool, &da->dst_cont,
-                                  &da->src_poh, &da->dst_coh, false,
-                                  connect_pool, create_cont, require_new_cont,
-                                  preserve, mfu_src_file, dst_cont_passed);
-        } else {
-            connect_pool = true;
-            tmp_rc = daos_connect(rank, da, &da->dst_pool, &da->dst_cont,
+        tmp_rc = mfu_daos_connect(rank, da, &da->dst_pool, &da->dst_cont,
                                   &da->dst_poh, &da->dst_coh, false,
-                                  connect_pool, create_cont, require_new_cont,
-                                  preserve, mfu_src_file, dst_cont_passed);
-        }
+                                  true, dst_pool_connect_flags, create_cont, dst_cont_open_flags,
+                                  require_new_cont, preserve, mfu_src_file, dst_cont_passed);
         if (tmp_rc != 0) {
-            /* tmp_rc from daos_connect is collective */
+            /* tmp_rc from mfu_daos_connect is collective */
             local_daos_error = true;
             goto out;
         }
         /* Get the container type */
-        tmp_rc = daos_get_cont_type(da->dst_coh, &da->dst_cont_type);
+        tmp_rc = mfu_daos_get_cont_type(da->dst_coh, &da->dst_cont_type);
         if (tmp_rc != 0) {
             /* ideally, this should be the same for each process */
             local_daos_error = true;
@@ -1796,7 +1711,7 @@ int daos_setup(
         }
         if (have_dst) {
             /* Set the dst api based on the container type */
-            tmp_rc = daos_set_api_cont_type(mfu_dst_file, da->dst_cont_type, da->api);
+            tmp_rc = mfu_daos_set_api_cont_type(mfu_dst_file, da->dst_cont_type, da->api);
             if (tmp_rc != 0) {
                 local_daos_error = true;
                 goto out;
@@ -1823,11 +1738,7 @@ int daos_setup(
     if (have_dst) {
         /* Mount destination DFS container */
         if (mfu_dst_file->type == DFS) {
-            if (same_pool) {
-                tmp_rc = mfu_dfs_mount(mfu_dst_file, &da->src_poh, &da->dst_coh);
-            } else {
-                tmp_rc = mfu_dfs_mount(mfu_dst_file, &da->dst_poh, &da->dst_coh);
-            }
+            tmp_rc = mfu_dfs_mount(mfu_dst_file, &da->dst_poh, &da->dst_coh);
             if (tmp_rc != 0) {
                 local_daos_error = true;
                 goto out;
@@ -1874,8 +1785,6 @@ int daos_cleanup(
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
-    bool same_pool = (strcmp(da->src_pool, da->dst_pool) == 0);
-
     /* Destroy source snapshot */
     if (rank == 0 && da->src_epc != 0) {
         tmp_rc = mfu_daos_destroy_snap(da->src_coh, da->src_epc);
@@ -1944,7 +1853,7 @@ int daos_cleanup(
     }
 
     /* Close destination pool */
-    if (daos_handle_is_valid(da->dst_poh) && !same_pool) {
+    if (daos_handle_is_valid(da->dst_poh)) {
         tmp_rc = daos_pool_disconnect(da->dst_poh, NULL);
         if (tmp_rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool "DF_RC, DP_RC(tmp_rc));
@@ -2420,7 +2329,7 @@ static int mfu_daos_obj_sync(
 
     /* open handle of object in dst container */
     daos_handle_t dst_oh;
-    rc = daos_obj_open(dst_coh, oid, DAOS_OO_EXCL, &dst_oh, NULL);
+    rc = daos_obj_open(dst_coh, oid, DAOS_OO_RW, &dst_oh, NULL);
     if (rc != 0) {
         MFU_LOG(MFU_LOG_ERR, "DAOS object open returned with errors: " MFU_ERRF,
                 MFU_ERRP(-MFU_ERR_DAOS));
@@ -3857,7 +3766,7 @@ static int cont_serialize_prop_str(struct hdf5_args* hdf5,
     hid_t   attr_dspace;
     hid_t   usr_attr;
 
-    if (entry == NULL || entry->dpe_str == NULL) {
+    if (entry == NULL) {
         MFU_LOG(MFU_LOG_ERR, "Property %s not found", prop_str);
         rc = 1;
         goto out;
@@ -3870,7 +3779,7 @@ static int cont_serialize_prop_str(struct hdf5_args* hdf5,
         rc = 1;
         goto out;
     }
-    status = H5Tset_size(attr_dtype, strlen(entry->dpe_str) + 1);
+    status = H5Tset_size(attr_dtype, (entry->dpe_str ? strlen(entry->dpe_str) : 0) + 1);
     if (status < 0) {
         MFU_LOG(MFU_LOG_ERR, "failed to set dtype size");
         rc = 1;
@@ -3895,7 +3804,7 @@ static int cont_serialize_prop_str(struct hdf5_args* hdf5,
         rc = 1;
         goto out;
     }   
-    status = H5Awrite(usr_attr, attr_dtype, entry->dpe_str);
+    status = H5Awrite(usr_attr, attr_dtype, entry->dpe_str ? entry->dpe_str : "");
     if (status < 0) {
         MFU_LOG(MFU_LOG_ERR, "failed to write attribute");
         rc = 1;
@@ -4156,26 +4065,32 @@ int cont_serialize_props(struct hdf5_args *hdf5,
     }
 
     entry = &prop_query->dpp_entries[15];
-    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ALLOCED_OID");
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_SCRUBBER_DISABLED");
     if (rc != 0) {
         goto out;
     }
 
     entry = &prop_query->dpp_entries[16];
-    rc = cont_serialize_prop_str(hdf5, entry, "DAOS_PROP_CO_LABEL");
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ALLOCED_OID");
     if (rc != 0) {
         goto out;
     }
 
     entry = &prop_query->dpp_entries[17];
+    rc = cont_serialize_prop_str(hdf5, entry, "DAOS_PROP_CO_LABEL");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[18];
     rc = cont_serialize_prop_roots(hdf5, entry, "DAOS_PROP_CO_ROOTS");
     if (rc != 0) {
         goto out;
     }
 
     /* serialize ACL */
-    if (prop_query->dpp_nr > 18) {
-        entry = &prop_query->dpp_entries[18];
+    if (prop_query->dpp_nr > 19) {
+        entry = &prop_query->dpp_entries[19];
         rc = cont_serialize_prop_acl(hdf5, entry, "DAOS_PROP_CO_ACL");
         if (rc != 0) {
             goto out;
@@ -4301,7 +4216,7 @@ int daos_cont_serialize_hdlr(int rank, struct hdf5_args *hdf5, char *output_dir,
                 goto out;
             }
         } else {
-            rc = daos_obj_open(da->src_coh, oid, 0, &oh, NULL);
+            rc = daos_obj_open(da->src_coh, oid, DAOS_OO_RO, &oh, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "failed to open object: "DF_RC, DP_RC(rc));
                 goto out;
@@ -5369,7 +5284,7 @@ int cont_deserialize_all_props(struct hdf5_args *hdf5,
 {
     int                     rc = 0;
     bool                    deserialize_label = false;
-    uint32_t                num_props = 18;
+    uint32_t                num_props = 19;
     daos_prop_t             *label = NULL;
     daos_prop_t             *prop = NULL;
     struct daos_prop_entry  *entry;
@@ -5394,22 +5309,23 @@ int cont_deserialize_all_props(struct hdf5_args *hdf5,
         goto out;
     }
 
-    rc = daos_cont_open(poh, label_entry->dpe_str, DAOS_COO_RW, &coh, &cont_info, NULL);
-    if (rc == -DER_NONEXIST) {
-        /* doesn't exist so ok to deserialize this container label */
-        deserialize_label = true;
-    } else if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "daos_cont_open failed: "DF_RC, DP_RC(rc));
-        goto out;
-    }  else {
-        /* if this succeeds then label already exists, close container after
-         * checking */
-        rc = daos_cont_close(coh, NULL);
-        if (rc != 0) {
+    if (label_entry->dpe_str[0]) {
+        rc = daos_cont_open(poh, label_entry->dpe_str, DAOS_COO_RW, &coh, &cont_info, NULL);
+        if (rc == -DER_NONEXIST) {
+            /* doesn't exist so ok to deserialize this container label */
+            deserialize_label = true;
+        } else if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "daos_cont_open failed: "DF_RC, DP_RC(rc));
             goto out;
+        }  else {
+            /* if this succeeds then label already exists, close container after
+             * checking */
+            rc = daos_cont_close(coh, NULL);
+            if (rc != 0) {
+                goto out;
+            }
         }
     }
-
     if (deserialize_label) {
         num_props++;
     }
@@ -5434,11 +5350,12 @@ int cont_deserialize_all_props(struct hdf5_args *hdf5,
     prop->dpp_entries[12].dpe_type = DAOS_PROP_CO_DEDUP;
     prop->dpp_entries[13].dpe_type = DAOS_PROP_CO_DEDUP_THRESHOLD;
     prop->dpp_entries[14].dpe_type = DAOS_PROP_CO_EC_CELL_SZ;
-    prop->dpp_entries[15].dpe_type = DAOS_PROP_CO_ALLOCED_OID;
-    prop->dpp_entries[16].dpe_type = DAOS_PROP_CO_ACL;
-    prop->dpp_entries[17].dpe_type = DAOS_PROP_CO_ROOTS;
+    prop->dpp_entries[15].dpe_type = DAOS_PROP_CO_SCRUBBER_DISABLED;
+    prop->dpp_entries[16].dpe_type = DAOS_PROP_CO_ALLOCED_OID;
+    prop->dpp_entries[17].dpe_type = DAOS_PROP_CO_ACL;
+    prop->dpp_entries[18].dpe_type = DAOS_PROP_CO_ROOTS;
     if (deserialize_label) {
-        prop->dpp_entries[18].dpe_type = DAOS_PROP_CO_LABEL; 
+        prop->dpp_entries[19].dpe_type = DAOS_PROP_CO_LABEL;
     }
 
     entry = &prop->dpp_entries[0];
@@ -5532,12 +5449,18 @@ int cont_deserialize_all_props(struct hdf5_args *hdf5,
     }
 
     entry = &prop->dpp_entries[15];
-    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ALLOCED_OID");
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_SCRUBBER_DISABLED");
     if (rc != 0) {
         goto out;
     }
 
     entry = &prop->dpp_entries[16];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ALLOCED_OID");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[17];
     /* read acl as a list of strings in deserialize, then convert
      * back to acl for property entry
      */
@@ -5546,14 +5469,14 @@ int cont_deserialize_all_props(struct hdf5_args *hdf5,
         goto out;
     }
 
-    entry = &prop->dpp_entries[17];
+    entry = &prop->dpp_entries[18];
     rc = cont_deserialize_prop_roots(hdf5, entry, "DAOS_PROP_CO_ROOTS", roots);
     if (rc != 0) {
         goto out;
     }
 
     if (deserialize_label) {
-        prop->dpp_entries[18].dpe_str = strdup(label_entry->dpe_str);
+        prop->dpp_entries[19].dpe_str = strdup(label_entry->dpe_str);
     }
     *cont_type = prop->dpp_entries[0].dpe_val;
     *_prop = prop;
@@ -5617,7 +5540,7 @@ int daos_cont_deserialize_connect(daos_args_t *daos_args,
     } else {
         uuid_unparse(daos_args->dst_cont_uuid, cont_str);
         MFU_LOG(MFU_LOG_INFO, "Successfully created container %s", cont_str);
-        rc = daos_cont_open(daos_args->src_poh, daos_args->dst_cont_uuid,
+        rc = daos_cont_open(daos_args->src_poh, cont_str,
                             DAOS_COO_RW, &daos_args->src_coh, &co_info, NULL);
     }
     if (rc != 0) {
@@ -5714,7 +5637,7 @@ int daos_cont_deserialize_hdlr(int rank, daos_args_t *da, const char *h5filename
                 goto out;
             }
         } else {
-            rc = daos_obj_open(da->src_coh, oid, 0, &oh, NULL);
+            rc = daos_obj_open(da->src_coh, oid, DAOS_OO_RW, &oh, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "failed to open object: "DF_RC, DP_RC(rc));
                 goto out;
diff --git a/src/common/mfu_daos.h b/src/common/mfu_daos.h
index 86624c0..ab7ec66 100644
--- a/src/common/mfu_daos.h
+++ b/src/common/mfu_daos.h
@@ -40,7 +40,6 @@ typedef struct {
     char dst_cont[DAOS_PROP_LABEL_MAX_LEN + 1];
     /* if destination container is not created new UUID is generated */
     uuid_t dst_cont_uuid;   /* destination container UUID */
-    char* dfs_prefix;       /* prefix for UNS */
     char* src_path;         /* allocated src path */
     char* dst_path;         /* allocated dst path */
     daos_api_t api;         /* API to use */
@@ -302,7 +301,7 @@ int daos_parse_path(
 
 /* connect to DAOS pool,
  * and then open container */
-int daos_connect(
+int mfu_daos_connect(
   int rank,
   daos_args_t* da,
   char (*pool)[],
@@ -311,7 +310,9 @@ int daos_connect(
   daos_handle_t* coh,
   bool force_serialize,
   bool connect_pool,
+  unsigned int pool_connect_flags,
   bool create_cont,
+  unsigned int cont_open_flags,
   bool require_new_cont,
   bool preserve,
   mfu_file_t* mfu_src_file,
diff --git a/src/common/mfu_flist.h b/src/common/mfu_flist.h
index dd02888..d2ed0a3 100644
--- a/src/common/mfu_flist.h
+++ b/src/common/mfu_flist.h
@@ -550,13 +550,9 @@ void mfu_flist_metadata_apply(
 void mfu_flist_unlink(mfu_flist flist, bool traceless, mfu_file_t* mfu_file);
 
 typedef struct {
-    uid_t getuid;   /* result from getuid */
-    uid_t geteuid;  /* result from geteuid */
     uid_t uid;      /* new user id for item's owner, -1 for no change */
     gid_t gid;      /* new group id for item's group, -1 for no change  */
     mode_t umask;   /* umask to apply when setting item permissions */
-    bool capchown;  /* whether process has CAP_CHOWN capability */
-    bool capfowner; /* whether process has CAP_FOWNER capability */
     bool force;     /* always call chmod/chgrp on every item */
     bool silence;   /* avoid printing EPERM errors */
 } mfu_chmod_opts_t;
@@ -633,6 +629,7 @@ typedef struct {
     bool    preserve_acls;
     bool    preserve_fflags;
     bool    preserve;
+    bool    open_noatime;
     int     flags;
     size_t  chunk_size;
     size_t  buf_size;
diff --git a/src/common/mfu_flist_archive.c b/src/common/mfu_flist_archive.c
index b370522..f5ba861 100644
--- a/src/common/mfu_flist_archive.c
+++ b/src/common/mfu_flist_archive.c
@@ -142,6 +142,7 @@ static int mfu_archive_open_file(
     const char* file,                /* path to file to be opened */
     int read_flag,                   /* set to 1 to open in read only, 0 for write */
     int sync_flag,                   /* set to 1 to sync file on close (if opned for write) */
+    int noatime_flag,                /* set to 1 to open file with O_NOATIME */
     mfu_archive_file_cache_t* cache) /* cache the open file to avoid repetitive open/close of the same file */
 {
     /* see if we have a cached file descriptor */
@@ -164,6 +165,9 @@ static int mfu_archive_open_file(
     int fd;
     if (read_flag) {
         int flags = O_RDONLY;
+        if (noatime_flag) {
+            flags |= O_NOATIME;
+        }
         fd = mfu_open(file, flags);
     } else {
         int flags = O_WRONLY | O_CREAT;
@@ -397,7 +401,11 @@ static int encode_header(
         /* to preserve ACLs and XATTRs, we rely on read disk to capture that info,
          * libarchive captures this info in an entry by default (unless told not to),
          * we need to open the target item with a file descriptor for the read_disk call */
-        int fd = mfu_open(fname, O_RDONLY);
+        int flags = O_RDONLY;
+        if (opts->open_noatime) {
+            flags |= O_NOATIME;
+        }
+        int fd = mfu_open(fname, flags);
         if (fd >= 0) {
             /* define an host archive for encoding our entry */
             struct archive* source = archive_read_disk_new();
@@ -729,7 +737,8 @@ static void DTAR_perform_copy(CIRCLE_handle* handle)
     /* open input file for reading */
     int read_flag = 1;
     int sync_flag = 0;
-    int open_rc = mfu_archive_open_file(in_name, read_flag, sync_flag, &mfu_archive_src_cache);
+    int noatime_flag = DTAR_opts->open_noatime;
+    int open_rc = mfu_archive_open_file(in_name, read_flag, sync_flag, noatime_flag, &mfu_archive_src_cache);
     int in_fd = mfu_archive_src_cache.fd;
     if (open_rc == -1) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open source file '%s' errno=%d %s",
@@ -913,10 +922,11 @@ static void DTAR_perform_extract(CIRCLE_handle* handle)
     /* get name of user file */
     const char* out_name = op->operand;
 
-    /* open output file for reading */
+    /* open output file for writing */
     int read_flag = 0; /* write */
     int sync_flag = DTAR_opts->sync_on_close;
-    int open_rc = mfu_archive_open_file(out_name, read_flag, sync_flag, &mfu_archive_dst_cache);
+    int noatime_flag = DTAR_opts->open_noatime;
+    int open_rc = mfu_archive_open_file(out_name, read_flag, sync_flag, noatime_flag, &mfu_archive_dst_cache);
     int out_fd = mfu_archive_dst_cache.fd;
     if (open_rc == -1) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open destination file '%s' errno=%d %s",
@@ -2340,7 +2350,11 @@ static int mfu_flist_archive_create_copy_chunk(
 
         /* open the source file for reading */
         const char* in_name = p->name;
-        int in_fd = mfu_open(p->name, O_RDONLY);
+        int flags = O_RDONLY;
+        if (opts->open_noatime) {
+            flags |= O_NOATIME;
+        }
+        int in_fd = mfu_open(in_name, flags);
         if (in_fd < 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to open source file '%s' errno=%d %s",
                 in_name, errno, strerror(errno));
@@ -3516,7 +3530,7 @@ static int index_entries_distread(
         MFU_LOG(MFU_LOG_INFO, "Indexing archive with parallel read");
     }
 
-    /* open archive file for readhing */
+    /* open archive file for reading */
     int fd = mfu_open(filename, O_RDONLY);
     if (fd < 0) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open archive: '%s' (errno=%d %s)",
@@ -3883,7 +3897,7 @@ static int extract_flist_offsets(
     /* prepare list for metadata details */
     mfu_flist_set_detail(flist, 1);
 
-    /* open archive file for readhing */
+    /* open archive file for reading */
     int fd = mfu_open(filename, O_RDONLY);
     if (fd < 0) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open archive: '%s' (errno=%d %s)",
@@ -5764,6 +5778,9 @@ mfu_archive_opts_t* mfu_archive_opts_new(void)
     /* By default, don't bother to preserve all attributes. */
     opts->preserve = false;
 
+    /* Whether to open files with O_NOATIME */
+    opts->open_noatime = false;
+
     /* flags for libarchive */
     opts->flags = 0;
 
diff --git a/src/common/mfu_flist_chmod.c b/src/common/mfu_flist_chmod.c
index d1bd985..c21d101 100644
--- a/src/common/mfu_flist_chmod.c
+++ b/src/common/mfu_flist_chmod.c
@@ -928,6 +928,7 @@ static int chmod_list(
     const mfu_perms* head,
     const char* usrname,
     const char* grname,
+    const mfu_proc_t* proc,
     mfu_chmod_opts_t* opts)
 {
     /* assume we'll succeed, set this to FAILURE on any error */
@@ -990,7 +991,7 @@ static int chmod_list(
                 /* only attempt to change group if effective user id of
                  * the process is the owner of the item or process has
                  * CAP_CHWON capability */
-                if (grname != NULL && opts->geteuid != olduid && !opts->capchown) {
+                if (grname != NULL && proc->geteuid != olduid && !proc->cap_chown) {
                     /* want to change group, but effective uid is not the
                      * owner, linux prevents normal users from doing this */
                     change = 0;
@@ -1069,7 +1070,7 @@ static int chmod_list(
                 /* don't bother changing permissions on files we don't own,
                  * unless process has CAP_FOWNER capability */
                 uid_t owner = (uid_t) mfu_flist_file_get_uid(list, idx);
-                if (opts->geteuid != owner && !opts->capfowner) {
+                if (proc->geteuid != owner && !proc->cap_fowner) {
                     /* don't attempt to change files we don't own */
                     change = 0;
                 }
@@ -1174,6 +1175,17 @@ void mfu_flist_chmod(
         }
     }
 
+    /* Determine whether process is running with CAP_CHOWN,
+     * allowing changes to uid/gid of file even when effective
+     * user id of the process does not match owner of the file. */
+
+    /* Determine whether process is running with CAP_FOWNER,
+     * allowing changes to permissions of file even when effective
+     * user id of the process does not match owner of the file */
+
+    mfu_proc_t proc;
+    mfu_proc_set(&proc);
+
     /* wait for all tasks and start timer */
     MPI_Barrier(MPI_COMM_WORLD);
     double start_dchmod = MPI_Wtime();
@@ -1199,7 +1211,7 @@ void mfu_flist_chmod(
 
         /* do a dchmod on each element in the list for this level & pass it the size */
         uint64_t stats[7] = {0};
-        chmod_list(list, stats, head, usrname, grname, opts);
+        chmod_list(list, stats, head, usrname, grname, &proc, opts);
 
         /* tally up stats for above operation into running totals */
         total_stats[ITEM_COUNT]    += stats[ITEM_COUNT];
@@ -1252,13 +1264,6 @@ mfu_chmod_opts_t* mfu_chmod_opts_new(void)
 {
     mfu_chmod_opts_t* opts = (mfu_chmod_opts_t*) MFU_MALLOC(sizeof(mfu_chmod_opts_t));
 
-    /* cache current real user id */
-    opts->getuid = getuid();
-
-    /* cache current effective user id,
-     * determines uid when considering owner ID of files */
-    opts->geteuid = geteuid();
-
     /* chown with uid==-1 preserves the same owner,
      * default to keeping the owner the same */ 
     opts->uid = -1;
@@ -1271,30 +1276,6 @@ mfu_chmod_opts_t* mfu_chmod_opts_new(void)
      * implied all in symbolic mode, like "+rX" */
     opts->umask = 0;
 
-    /* whether process is running with CAP_CHOWN, allowing
-     * changes to uid/gid of file even when effective id
-     * of the process does not match the file */
-    opts->capchown = false;
-#ifdef HAVE_LIBCAP
-    int cap_rc = cap_get_bound(CAP_CHOWN);
-    if (cap_rc > 0) {
-        /* process is running with CAP_CHOWN capability */
-        opts->capchown = true;
-    }
-#endif
-
-    /* whether process is running with CAP_FOWNER, allowing
-     * changes to permissions of file even when effective user id
-     * of the process does not match the owner of the file */
-    opts->capfowner = false;
-#ifdef HAVE_LIBCAP
-    cap_rc = cap_get_bound(CAP_FOWNER);
-    if (cap_rc > 0) {
-        /* process is running with CAP_FOWNER capability */
-        opts->capfowner = true;
-    }
-#endif
-
     /* avoid calling chmod/chown on all items,
      * if this is set to true, call on every item */
     opts->force = false;
diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index f5acaab..0775116 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -68,6 +68,10 @@
 #include <gpfs.h>
 #endif
 
+#ifdef HPSS_SUPPORT
+#include <linux/hpssfs.h>
+#endif
+
 /****************************************
  * Define types
  ***************************************/
@@ -174,6 +178,9 @@ static int mfu_copy_open_file(
     /* open the new file, this sets mfu_file->fd/obj */
     if (read_flag) {
         int flags = O_RDONLY;
+        if (copy_opts->open_noatime) {
+            flags |= O_NOATIME;
+        }
         if (copy_opts->direct) {
             flags |= O_DIRECT;
         }
@@ -1289,6 +1296,62 @@ static int mfu_create_file(
         }
     }
 
+#ifdef HPSS_SUPPORT
+
+    /*
+     *  For HPSS we want to ensure that the file is placed in the correct Class
+     *  of Service (COS). The simplest way to do that is to give a hint to the
+     *  Core Server about what size the destination file will be.
+     *
+     */
+
+    if ( mfu_is_hpss(dest_path) == true ) {
+
+        uint64_t sourcesize = mfu_flist_file_get_size(list, idx);
+        if (sourcesize != (uint64_t) -1) {
+
+            /*
+             * Get the current size of the destintation file.
+             * If the size is greater than 0, the ioctl will fail, so dont bother.
+             *
+             */
+
+            struct stat hpssst;
+            int hpssrc = mfu_file_lstat(dest_path, &hpssst, mfu_dst_file);
+            if (hpssrc == 0 && hpssst.st_size == 0) {
+                errno = 0;
+                hpssrc = mfu_file_open(dest_path, O_RDWR|O_CREAT|O_NONBLOCK, mfu_dst_file);
+                MFU_LOG(MFU_LOG_DBG, "mfu_open(complete): %s (%d %d %s)", dest_path, mfu_dst_file->fd, errno, strerror(errno));
+                if (hpssrc != -1) {
+                    MFU_LOG(MFU_LOG_DBG, "Calling ioctl...source size is: %lu", sourcesize);
+                    errno = 0;
+                    int ioctlrc = ioctl(mfu_dst_file->fd, HPSSFS_SET_FSIZE_HINT, &sourcesize);
+                    MFU_LOG(MFU_LOG_DBG, "Done Calling ioctl (%d)(%d)(%s)", ioctlrc, errno, strerror(errno));
+                    (void) mfu_file_close(dest_path, mfu_dst_file);
+                } else {
+                    /* had an error opening the destination file */
+                    MFU_LOG(MFU_LOG_ERR, "mfu_file_open() file: `%s' (errno=%d %s)", dest_path, errno, strerror(errno));
+                    rc = -1;
+                }
+
+            } else {
+                /*
+                 * had an error getting the size of the sink file or the size is
+                 * greater than zero. we will allow the sync to continue on without
+                 * setting the COS
+                 */
+                MFU_LOG(MFU_LOG_WARN, "mfu_file_lstat() file: `%s' (errno=%d %s) (size=%llu)", dest_path, errno, strerror(errno), hpssst.st_size);
+            }
+
+        } else {
+            /* had an error getting the size of the source file.
+             * we will allow the sync to continue on without setting the COS */
+            MFU_LOG(MFU_LOG_WARN, "mfu_flist_file_get_size() error: `%s'", src_path);
+        }
+    }
+
+#endif
+
     /* free destination path */
     mfu_free(&dest_path);
 
@@ -1680,12 +1743,20 @@ static int mfu_copy_file_normal(
         /* If we're using O_DIRECT, deal with short reads.
          * Retry with same buffer and offset since those must
          * be aligned at block boundaries. */
+        int retries = 0;
         while (copy_opts->direct &&            /* using O_DIRECT */
                bytes_read > 0 &&               /* read was not an error or eof */
                bytes_read < left_to_read &&    /* shorter than requested */
                (off + bytes_read) < file_size) /* not at end of file */
         {
-            /* TODO: probably should retry a limited number of times then abort */
+            /* try the read a limited number of times then given up with error */
+            retries++;
+            if (retries == 5) {
+              MFU_LOG(MFU_LOG_ERR, "Source file `%s' exceeded short read limit, maybe shorter than expected size of %llu bytes",
+                  src, file_size);
+              return -1;
+            }
+
             bytes_read = mfu_file_pread(src, buf, left_to_read, off, mfu_src_file);
         }
 
@@ -1698,8 +1769,8 @@ static int mfu_copy_file_normal(
 
         /* check for early EOF */
         if (bytes_read == 0) {
-            MFU_LOG(MFU_LOG_ERR, "Source file `%s' shorter than expected %llu (errno=%d %s)",
-                src, file_size, errno, strerror(errno));
+            MFU_LOG(MFU_LOG_ERR, "Source file `%s' shorter than expected size of %llu bytes",
+                src, file_size);
             return -1;
         }
 
@@ -3270,6 +3341,9 @@ mfu_copy_opts_t* mfu_copy_opts_new(void)
     /* By default, don't use O_DIRECT. */
     opts->direct = false;
 
+    /* By default, don't use O_NOATIME. */
+    opts->open_noatime = false;
+
     /* By default, don't use sparse file. */
     opts->sparse = false;
 
diff --git a/src/common/mfu_param_path.c b/src/common/mfu_param_path.c
index 488d4f2..44da9e6 100644
--- a/src/common/mfu_param_path.c
+++ b/src/common/mfu_param_path.c
@@ -401,13 +401,12 @@ char* mfu_param_path_copy_dest(const char* name, int numpaths,
      * if path is root, keep last component.
      * otherwise cut all components listed in source path */
     int cut = src_components;
-    if (mfu_copy_opts->copy_into_dir && cut > 0) {
-        if (strcmp(paths[i].orig, "/") == 0) {
-            cut--;
-        } else if ((mfu_copy_opts->do_sync != 1) &&
-            (paths[i].orig[strlen(paths[i].orig) - 1] != '/')) {
-            cut--;
-        }
+    if (cut > 0 && strcmp(paths[i].orig, "/") == 0) {
+        cut--;
+    }
+    else if ((cut > 0) && mfu_copy_opts->copy_into_dir &&
+            (mfu_copy_opts->do_sync != 1) && (paths[i].orig[strlen(paths[i].orig) - 1] != '/')) {
+        cut--;
     }
 
     /* compute number of components to keep */
diff --git a/src/common/mfu_param_path.h b/src/common/mfu_param_path.h
index 156be26..04b2d51 100644
--- a/src/common/mfu_param_path.h
+++ b/src/common/mfu_param_path.h
@@ -135,6 +135,7 @@ typedef struct {
                                     * this is not a perfect opposite of no_dereference */
     int          no_dereference;   /* if true, don't dereference source symbolic links */
     bool         direct;           /* whether to use O_DIRECT */
+    bool         open_noatime;     /* whether to use O_NOATIME */
     bool         sparse;           /* whether to create sparse files */
     size_t       chunk_size;       /* size to chunk files by */
     size_t       buf_size;         /* buffer size to read/write to file system */
diff --git a/src/common/mfu_proc.c b/src/common/mfu_proc.c
new file mode 100644
index 0000000..3629a3d
--- /dev/null
+++ b/src/common/mfu_proc.c
@@ -0,0 +1,55 @@
+/* Defines a double linked list representing a file path. */
+
+#include "mfu.h"
+
+#include <unistd.h>
+
+#include <errno.h>
+#include <string.h>
+
+#ifdef HAVE_LIBCAP
+#include <sys/capability.h>
+#endif
+
+/* query properties and capabilities of current process */
+void mfu_proc_set(mfu_proc_t* proc)
+{
+    proc->getuid  = getuid();
+    proc->geteuid = geteuid();
+
+    proc->cap_chown  = false;
+    proc->cap_fowner = false;
+
+#ifdef HAVE_LIBCAP
+    /* query current process capability settings */
+    cap_t caps = cap_get_proc();
+    if (caps != NULL) {
+        int rc;
+        cap_flag_value_t flag;
+
+        /* check for CAP_CHOWN */
+        rc = cap_get_flag(caps, CAP_CHOWN, CAP_EFFECTIVE, &flag);
+        if (rc == 0) {
+            proc->cap_chown = (flag == CAP_SET);
+        } else {
+            MFU_LOG(MFU_LOG_ERR, "cap_get_flag(CAP_CHOWN) failed: errno=%d (%s)", errno, strerror(errno));
+        }
+
+        /* check for CAP_FOWNER */
+        rc = cap_get_flag(caps, CAP_FOWNER, CAP_EFFECTIVE, &flag);
+        if (rc == 0) {
+            proc->cap_fowner = (flag == CAP_SET);
+        } else {
+            MFU_LOG(MFU_LOG_ERR, "cap_get_flag(CAP_FOWNER) failed: errno=%d (%s)", errno, strerror(errno));
+        }
+
+        /* free capabilities structure */
+        rc = cap_free(caps);
+        if (rc == -1) {
+            MFU_LOG(MFU_LOG_ERR, "cap_free() failed: errno=%d (%s)", errno, strerror(errno));
+        }
+    } else {
+        MFU_LOG(MFU_LOG_ERR, "cap_get_proc() failed: errno=%d (%s)", errno, strerror(errno));
+    }
+#endif
+}
diff --git a/src/common/mfu_proc.h b/src/common/mfu_proc.h
new file mode 100644
index 0000000..25a930f
--- /dev/null
+++ b/src/common/mfu_proc.h
@@ -0,0 +1,18 @@
+#ifndef MFU_PROC_H
+#define MFU_PROC_H
+
+#include <unistd.h>
+#include <sys/types.h>
+
+/* records properties about the current process */
+typedef struct mfu_proc_struct {
+  uid_t getuid;
+  uid_t geteuid;
+  bool cap_chown;
+  bool cap_fowner;
+} mfu_proc_t;
+
+/* query and cache values for current process */
+void mfu_proc_set(mfu_proc_t* proc);
+
+#endif /* MFU_PROC_H */
diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 0be0fa7..9105e93 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -5,6 +5,7 @@
 #include "mpi.h"
 #include "dtcmp.h"
 #include "mfu_errors.h"
+#include "list.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -49,6 +50,7 @@ int mfu_init()
         MPI_Comm_rank(MPI_COMM_WORLD, &mfu_rank);
         mfu_debug_stream = stdout;
         DTCMP_Init();
+        mfu_init_filesystem_list();
         mfu_initialized++;
     }
 
@@ -62,6 +64,9 @@ int mfu_finalize()
         DTCMP_Finalize();
         mfu_initialized--;
     }
+    if (mfu_initialized == 0) {
+        mfu_destroy_filesystem_list();
+    }
     return MFU_SUCCESS;
 }
 
@@ -720,6 +725,7 @@ int mfu_compare_contents(
     /* extract values from copy options */
     int direct = copy_opts->direct;
     size_t buf_size = copy_opts->buf_size;
+    bool noatime = copy_opts->open_noatime;
 
     /* for O_DIRECT, check that length is a multiple of buf_size */
     if (direct &&                      /* using O_DIRECT */
@@ -732,6 +738,9 @@ int mfu_compare_contents(
 
     /* open source as read only, with optional O_DIRECT */
     int src_flags = O_RDONLY;
+    if (noatime) {
+        src_flags |= O_NOATIME;
+    }
     if (direct) {
         src_flags |= O_DIRECT;
     }
@@ -751,6 +760,9 @@ int mfu_compare_contents(
     if (overwrite) {
         dst_flags = O_RDWR;
     }
+    if (noatime) {
+        dst_flags |= O_NOATIME;
+    }
     if (direct) {
         dst_flags |= O_DIRECT;
     }
@@ -1105,6 +1117,241 @@ bool mfu_is_lustre(const char* path)
     return is_lustre;
 }
 
+static bool             mfu_mi_list_initialized = false;
+static struct list_head mfu_mi_list;
+
+typedef struct mfu_mount_info
+{
+    struct list_head mfu_mi_linkage;
+    dev_t            mfu_mi_dev;
+    char*            mfu_mi_source;
+    char*            mfu_mi_mountpoint;
+    char*            mfu_mi_fstype;
+    char*            mfu_mi_fssubtype;
+    char*            mfu_mi_mountopts;
+} mfu_mount_info_t;
+
+void mfu_mount_info_destroy(struct mfu_mount_info* mip)
+{
+    if (mip == NULL) {
+        return;
+    }
+
+    mfu_free(&mip->mfu_mi_source);
+    mfu_free(&mip->mfu_mi_mountpoint);
+    mfu_free(&mip->mfu_mi_fstype);
+    mfu_free(&mip->mfu_mi_fssubtype);
+    mfu_free(&mip->mfu_mi_mountopts);
+}
+
+int mfu_mount_info_parse_fstype_line(
+    char*                  line,
+    size_t                 size,
+    struct mfu_mount_info* mip)
+{
+    char* saveptr = NULL;
+    char* found = strtok_r(line, ".", &saveptr);
+    if (found == NULL) {
+        return(ENOENT);
+    }
+
+    mip->mfu_mi_fstype = MFU_STRDUP(found);
+
+    found = strtok_r(NULL, ".", &saveptr);
+    if (found == NULL) {
+        return(0);
+    }
+
+    mip->mfu_mi_fssubtype = MFU_STRDUP(found);
+
+    return(0);
+}
+
+int
+mfu_mount_info_parse_mount_line(
+    char*                  line,
+    size_t                 size,
+    struct mfu_mount_info* mip)
+{
+    int num = 0;
+    char* saveptr = NULL;
+    char* found = strtok_r(line, " ", &saveptr);
+    while (found != NULL) {
+        num++;
+        switch (num) {
+            case 1:
+                mip->mfu_mi_source = MFU_STRDUP(found);
+                break;
+            case 2:
+                mip->mfu_mi_mountpoint = MFU_STRDUP(found);
+                break;
+            case 3:
+                mfu_mount_info_parse_fstype_line(found, strlen(found)+1, mip);
+                break;
+            case 4:
+                mip->mfu_mi_mountopts = MFU_STRDUP(found);
+                break;
+            default:
+                break;
+        }
+
+        found = strtok_r(NULL, " ", &saveptr);
+    }
+
+    return(0);
+}
+
+int mfu_mount_info_get_filesystem_list(struct list_head* mfu_mi_list)
+{
+    if (mfu_mi_list == NULL) {
+        return(EINVAL);
+    }
+
+    errno = 0;
+    FILE* mountfp = fopen("/proc/self/mounts", "r");
+    if (mountfp == NULL) {
+        return(errno);
+    }
+
+    char* line = NULL;
+    size_t len = 0;
+    ssize_t bytes = getline(&line, &len, mountfp);
+    while (bytes != -1)
+    {
+        struct mfu_mount_info* itemp = MFU_CALLOC(1, sizeof(struct mfu_mount_info));
+        if (itemp == NULL) {
+            fclose(mountfp);
+            return(ENOMEM);
+        }
+        INIT_LIST_HEAD(&itemp->mfu_mi_linkage);
+
+        /*
+         * Parse one of the lines in /proc/self/mounts
+         */
+        mfu_mount_info_parse_mount_line(line, len, itemp);
+
+        /*
+         *  Get the device for the mountpoint in question.
+         */
+        errno = 0;
+        struct stat st;
+        int rc = stat(itemp->mfu_mi_mountpoint, &st);
+        if (rc == -1) {
+            fclose(mountfp);
+            MFU_LOG(MFU_LOG_ERR, "Could not stat: %s (errno=%d %s)",
+                itemp->mfu_mi_mountpoint, errno, strerror(errno));
+            return(1);
+        }
+        itemp->mfu_mi_dev = st.st_dev;
+
+        /*
+         *  Now we can insert the item into the list.
+         */
+        list_add_tail(&itemp->mfu_mi_linkage, mfu_mi_list);
+        bytes = getline(&line, &len, mountfp);
+    }
+
+    fclose(mountfp);
+    return(0);
+}
+
+void mfu_init_filesystem_list(void)
+{
+    if (mfu_mi_list_initialized == true) {
+        MFU_LOG(MFU_LOG_INFO, "The filesystem list is already initialized...");
+        return;
+    }
+
+    MFU_LOG(MFU_LOG_INFO, "Initializing filesystem list...");
+    INIT_LIST_HEAD(&mfu_mi_list);
+    mfu_mi_list_initialized = true;
+
+    int rc = mfu_mount_info_get_filesystem_list(&mfu_mi_list);
+    if (rc != 0) {
+        struct mfu_mount_info* itemp = NULL;
+        struct mfu_mount_info* tmpitemp = NULL;
+        list_for_each_entry_safe(itemp,
+                                 tmpitemp,
+                                 &mfu_mi_list,
+                                 mfu_mi_linkage)
+        {
+            list_del_init(&itemp->mfu_mi_linkage);
+            mfu_mount_info_destroy(itemp);
+            mfu_free(&itemp);
+        }
+        mfu_mi_list_initialized = false;
+        return;
+    }
+}
+
+void mfu_destroy_filesystem_list(void)
+{
+    if (mfu_mi_list_initialized == false) {
+        MFU_LOG(MFU_LOG_INFO, "The filesystem list is not initialized...");
+        return;
+    }
+
+    struct mfu_mount_info* itemp = NULL;
+    struct mfu_mount_info* tmpitemp = NULL;
+    list_for_each_entry_safe(itemp,
+                             tmpitemp,
+                             &mfu_mi_list,
+                             mfu_mi_linkage)
+    {
+        list_del_init(&itemp->mfu_mi_linkage);
+        mfu_mount_info_destroy(itemp);
+        mfu_free(&itemp);
+    }
+
+    mfu_mi_list_initialized = false;
+}
+
+bool mfu_is_hpss(const char* path)
+{
+    bool is_hpss = false;
+
+#ifdef HPSS_SUPPORT
+    if (mfu_mi_list_initialized == false) {
+        MFU_LOG(MFU_LOG_INFO, "The filesystem list has not been initialized...");
+        return(false);
+    }
+
+    errno = 0;
+    struct stat st;
+    int rc = stat(path, &st);
+    if (rc == -1) {
+        MFU_LOG(MFU_LOG_ERR, "Could not stat: %s (errno=%d %s)",
+            path, errno, strerror(errno));
+        return(false);
+    }
+
+    struct mfu_mount_info* itemp = NULL;
+    struct mfu_mount_info* tmpitemp = NULL;
+    list_for_each_entry_safe(itemp,
+                             tmpitemp,
+                             &mfu_mi_list,
+                             mfu_mi_linkage)
+    {
+        MFU_LOG(MFU_LOG_DBG, "MFU_MI_DEV: %d FILE_DEV: %d MFU_MI_FSTYPE: %s",
+            itemp->mfu_mi_dev, st.st_dev, itemp->mfu_mi_fstype
+        );
+
+        if ((itemp->mfu_mi_dev == st.st_dev) &&
+            (itemp->mfu_mi_fstype != NULL) &&
+            (itemp->mfu_mi_fssubtype != NULL) &&
+            (strncmp(itemp->mfu_mi_fstype, "fuse", 25) == 0) &&
+            (strstr(itemp->mfu_mi_fssubtype, "hpssfs") == itemp->mfu_mi_fssubtype))
+        {
+            MFU_LOG(MFU_LOG_DBG, "Filesystem is HPSSFS-FUSE...");
+            is_hpss = true;
+            break;
+        }
+    }
+#endif
+
+    return is_hpss;
+}
+
 /* executes a logical AND operation on flag on all procs on comm,
  * returns true if all true and false otherwise */
 bool mfu_alltrue(bool flag, MPI_Comm comm)
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index dcc32e5..73b1c27 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -112,6 +112,12 @@ int mfu_init(void);
 /* finalize mfu library */
 int mfu_finalize(void);
 
+/* initialize mfu filesystem list */
+void mfu_init_filesystem_list(void);
+
+/* destroy mfu filesystem list */
+void mfu_destroy_filesystem_list(void);
+
 /* print abort message and call MPI_Abort to kill run */
 #define MFU_ABORT(X, ...) mfu_abort(__FILE__, __LINE__, X, __VA_ARGS__)
 void mfu_abort(
@@ -269,6 +275,9 @@ void mfu_stripe_set(const char *path, uint64_t stripe_size, int stripe_count);
 /* return true if path is on lustre, false otherwise */
 bool mfu_is_lustre(const char* path);
 
+/* return true if path is on hpss, false otherwise */
+bool mfu_is_hpss(const char* path);
+
 /* executes a logical AND operation on flag on all procs on comm,
  * returns 1 if all true and 0 otherwise */
 bool mfu_alltrue(bool flag, MPI_Comm comm);
diff --git a/src/daos-gen/daos-gen.c b/src/daos-gen/daos-gen.c
index d96373a..46ee44d 100644
--- a/src/daos-gen/daos-gen.c
+++ b/src/daos-gen/daos-gen.c
@@ -18,6 +18,14 @@
 #define BUFLEN 80
 #define UUID_STR_LEN 129
 
+#if defined(DAOS_API_VERSION_MAJOR) && defined(DAOS_API_VERSION_MINOR)
+#define CHECK_DAOS_API_VERSION(major, minor)                                            \
+	((DAOS_API_VERSION_MAJOR > (major))                                             \
+	 || (DAOS_API_VERSION_MAJOR == (major) && DAOS_API_VERSION_MINOR >= (minor)))
+#else
+#define CHECK_DAOS_API_VERSION(major, minor) 0
+#endif
+
 static uint32_t obj_id_gen = 1;
 
 /** Print a usage message. */
@@ -176,13 +184,18 @@ int main(int argc, char** argv)
     char                key[keys_per_object];
     int                 i,j;
     char                uuid_str[UUID_STR_LEN];
+    uuid_t              cont_uuid;
+
+#if CHECK_DAOS_API_VERSION(2, 0)
+    enum daos_otype_t   otype;
+    otype = DAOS_OT_KV_HASHED;
+#else
     daos_ofeat_t        ofeats;
+    ofeats = DAOS_OF_KV_FLAT;
+#endif
 
-    ofeats = DAOS_OF_DKEY_UINT64 | DAOS_OF_KV_FLAT | DAOS_OF_KV_FLAT;
     /* connect to pool/cont then broadcast to rest of ranks */
     if (rank == 0) {
-        /* generate container UUID */
-        uuid_generate(daos_args->src_cont);
         daos_pool_info_t pool_info = {0};
         daos_cont_info_t co_info = {0};
 #if DAOS_API_VERSION_MAJOR < 1
@@ -199,14 +212,27 @@ int main(int argc, char** argv)
         }
 
         /* create cont and open */
+#if CHECK_DAOS_API_VERSION(2, 0)
+        rc = daos_cont_create(daos_args->src_poh, &cont_uuid, NULL, NULL);
+#else
+        /* generate container UUID */
+        uuid_generate(daos_args->src_cont);
+        uuid_copy(cont_uuid, daos_args->src_cont);
         rc = daos_cont_create(daos_args->src_poh, daos_args->src_cont, NULL, NULL);
+#endif
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to create cont: "DF_RC, DP_RC(rc));
             rc = 1;
             goto err_cont;
         }
+        uuid_unparse(cont_uuid, uuid_str);
+#if CHECK_DAOS_API_VERSION(2, 0)
+        rc = daos_cont_open(daos_args->src_poh, uuid_str,
+                            DAOS_COO_RW, &daos_args->src_coh, &co_info, NULL);
+#else
         rc = daos_cont_open(daos_args->src_poh, daos_args->src_cont,
                             DAOS_COO_RW, &daos_args->src_coh, &co_info, NULL);
+#endif
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to open container: "DF_RC, DP_RC(rc));
             rc = 1;
@@ -222,8 +248,11 @@ int main(int argc, char** argv)
 	memset(buf, 'A', BUFLEN);
     for (i = 0; i < num_objects; i++) {
         oid[i] = dts_oid_gen(0);
-                                   
+#if CHECK_DAOS_API_VERSION(2, 0)
+        rc = daos_obj_generate_oid(daos_args->src_coh, &oid[i], otype, OC_RP_XSF, 0, 0);
+#else                                   
         rc = daos_obj_generate_oid(daos_args->src_coh, &oid[i], ofeats, OC_RP_XSF, 0, 0);
+#endif
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to generate oid: "DF_RC, DP_RC(rc));
             rc = 1;
@@ -261,7 +290,6 @@ int main(int argc, char** argv)
      * generates same amount */
     if (rank == 0) {
         int total_num_objects = size * num_objects; 
-        uuid_unparse(daos_args->src_cont, uuid_str);
         printf("Container UUID: %s\n\ttotal objects:%d\n"
                "\tkeys per object:%d\n", uuid_str, total_num_objects, keys_per_object);
     }
diff --git a/src/daos-serialize/daos-serialize.c b/src/daos-serialize/daos-serialize.c
index f70f2c7..fc40892 100644
--- a/src/daos-serialize/daos-serialize.c
+++ b/src/daos-serialize/daos-serialize.c
@@ -153,10 +153,10 @@ int main(int argc, char** argv)
          rc = 1;
     }
     
-    tmp_rc = daos_connect(rank, daos_args, &daos_args->src_pool,
-                          &daos_args->src_cont, &daos_args->src_poh,
-                          &daos_args->src_coh, force_serialize, true,
-                          false, false, false, NULL, true);
+    tmp_rc = mfu_daos_connect(rank, daos_args, &daos_args->src_pool,
+                              &daos_args->src_cont, &daos_args->src_poh,
+                              &daos_args->src_coh, force_serialize, true, DAOS_PC_RW,
+                              false, DAOS_COO_RW, false, false, NULL, true);
     if (tmp_rc != 0) {
         daos_fini();
         mfu_finalize();
diff --git a/src/dcmp/dcmp.c b/src/dcmp/dcmp.c
index cc4deb0..2d2c033 100644
--- a/src/dcmp/dcmp.c
+++ b/src/dcmp/dcmp.c
@@ -45,6 +45,7 @@ static void print_usage(void)
     printf("      --daos-api            - DAOS API in {DFS, DAOS} (default uses DFS for POSIX containers)\n");
 #endif
     printf("  -s, --direct              - open files with O_DIRECT\n");
+    printf("      --open-noatime        - open files with O_NOATIME\n");
     printf("      --progress <N>        - print progress every N seconds\n");
     printf("  -v, --verbose             - verbose output\n");
     printf("  -q, --quiet               - quiet output\n");
@@ -2118,9 +2119,9 @@ int main(int argc, char **argv)
         {"base",          0, 0, 'b'},
         {"bufsize",       1, 0, 'B'},
         {"chunksize",     1, 0, 'k'},
-        {"daos-prefix",   1, 0, 'X'},
         {"daos-api",      1, 0, 'x'},
         {"direct",        0, 0, 's'},
+        {"open-noatime",  0, 0, 'U'},
         {"progress",      1, 0, 'R'},
         {"verbose",       0, 0, 'v'},
         {"quiet",         0, 0, 'q'},
@@ -2187,6 +2188,12 @@ int main(int argc, char **argv)
                 MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
             }
             break;
+        case 'U':
+            copy_opts->open_noatime = true;
+            if(rank == 0) {
+                MFU_LOG(MFU_LOG_INFO, "Using O_NOATIME");
+            }
+            break;
         case 'R':
             mfu_progress_timeout = atoi(optarg);
             break;
@@ -2208,9 +2215,6 @@ int main(int argc, char **argv)
             options.debug++;
             break;
 #ifdef DAOS_SUPPORT
-        case 'X':
-            daos_args->dfs_prefix = MFU_STRDUP(optarg);
-            break;
         case 'x':
             if (daos_parse_api_str(optarg, &daos_args->api) != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to parse --daos-api");
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index fc47f19..f1125a0 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -92,8 +92,11 @@ void print_usage(void)
     printf("  -P, --no-dereference     - don't follow links in source\n");
     printf("  -p, --preserve           - preserve permissions, ownership, timestamps (see also --xattrs)\n");
     printf("  -s, --direct             - open files with O_DIRECT\n");
+    printf("      --open-noatime       - open files with O_NOATIME\n");
     printf("  -S, --sparse             - create sparse files when possible\n");
     printf("      --progress <N>       - print progress every N seconds\n");
+    printf("  -G  --gid <GID>          - Set the group id to perform copy\n");
+    printf("  -U  --uid <UID>          - Set the user id to perform copy\n");
     printf("  -v, --verbose            - verbose output\n");
     printf("  -q, --quiet              - quiet output\n");
     printf("  -h, --help               - print usage\n");
@@ -107,6 +110,9 @@ int main(int argc, char** argv)
     /* assume we'll exit with success */
     int rc = 0;
 
+    /* effective group/user id */
+    uid_t gid = 0, uid = 0;
+
     /* initialize MPI */
     MPI_Init(&argc, &argv);
     mfu_init();
@@ -145,7 +151,6 @@ int main(int argc, char** argv)
         {"bufsize"              , required_argument, 0, 'b'},
         {"debug"                , required_argument, 0, 'd'}, // undocumented
         {"grouplock"            , required_argument, 0, 'g'}, // untested
-        {"daos-prefix"          , required_argument, 0, 'Y'},
         {"daos-api"             , required_argument, 0, 'y'},
         {"daos-preserve"        , required_argument, 0, 'D'},
         {"input"                , required_argument, 0, 'i'},
@@ -156,8 +161,11 @@ int main(int argc, char** argv)
         {"preserve"             , no_argument      , 0, 'p'},
         {"synchronous"          , no_argument      , 0, 's'},
         {"direct"               , no_argument      , 0, 's'},
+        {"open-noatime"         , no_argument      , 0, 'A'},
         {"sparse"               , no_argument      , 0, 'S'},
         {"progress"             , required_argument, 0, 'R'},
+        {"gid"                  , required_argument, 0, 'G'},
+        {"uid"                  , required_argument, 0, 'U'},
         {"verbose"              , no_argument      , 0, 'v'},
         {"quiet"                , no_argument      , 0, 'q'},
         {"help"                 , no_argument      , 0, 'h'},
@@ -169,7 +177,7 @@ int main(int argc, char** argv)
     int usage = 0;
     while(1) {
         int c = getopt_long(
-                    argc, argv, "b:d:g:i:k:LPpsSvqhX:",
+                    argc, argv, "b:d:g:G:i:k:LPpsSU:vqhX:",
                     long_options, &option_index
                 );
 
@@ -251,9 +259,6 @@ int main(int argc, char** argv)
                 break;
 #endif
 #ifdef DAOS_SUPPORT
-            case 'Y':
-                daos_args->dfs_prefix = MFU_STRDUP(optarg);
-                break;
             case 'y':
                 if (daos_parse_api_str(optarg, &daos_args->api) != 0) {
                     MFU_LOG(MFU_LOG_ERR, "Failed to parse --daos-api");
@@ -311,6 +316,12 @@ int main(int argc, char** argv)
                     MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
                 }
                 break;
+            case 'A':
+                mfu_copy_opts->open_noatime = true;
+                if(rank == 0) {
+                    MFU_LOG(MFU_LOG_INFO, "Using O_NOATIME");
+                }
+                break;
             case 'S':
                 mfu_copy_opts->sparse = 1;
                 if(rank == 0) {
@@ -320,6 +331,12 @@ int main(int argc, char** argv)
             case 'R':
                 mfu_progress_timeout = atoi(optarg);
                 break;
+            case 'G':
+                gid = atoi(optarg);
+                break;
+            case 'U':
+                uid = atoi(optarg);
+                break;
             case 'v':
                 mfu_debug_level = MFU_LOG_VERBOSE;
                 break;
@@ -378,6 +395,39 @@ int main(int argc, char** argv)
         return 1;
     }
 
+    /* setgroups before set gid or uid */
+    if (gid > 0 || uid > 0) {
+        if (setgroups(0, NULL) < 0) {
+            MFU_LOG(MFU_LOG_ERR, "Could not setgroups: %s", strerror(errno));
+            mfu_finalize();
+            MPI_Finalize();
+            return 1;
+        }
+    }
+
+    /* set egid */
+    if (gid > 0) {
+        if (setegid(gid) < 0) {
+            MFU_LOG(MFU_LOG_ERR, "Could not set Group ID: %s", strerror(errno));
+            mfu_finalize();
+            MPI_Finalize();
+            return 1;
+        }
+        MFU_LOG(MFU_LOG_INFO, "Set Group ID to %u", gid);
+    }
+
+    /* set euid */
+    if (uid > 0) {
+        if (seteuid(uid) < 0) {
+            MFU_LOG(MFU_LOG_ERR, "Could not set User ID: %s", strerror(errno));
+            mfu_finalize();
+            MPI_Finalize();
+            return 1;
+        }
+        MFU_LOG(MFU_LOG_INFO, "Set User ID to %u", uid);
+    }
+
+
 #ifdef DAOS_SUPPORT
     /* Set up DAOS arguments, containers, dfs, etc. */
     if (daos_args->api != DAOS_API_HDF5) {
diff --git a/src/ddup/ddup.c b/src/ddup/ddup.c
index 582ea30..05515dc 100644
--- a/src/ddup/ddup.c
+++ b/src/ddup/ddup.c
@@ -1,9 +1,13 @@
+/* For O_NOATIME support */
+#define _GNU_SOURCE
+
 #include <stdio.h>
 #include <string.h>
 #include <getopt.h>
 #include <openssl/sha.h>
 #include <assert.h>
 #include <inttypes.h>
+
 #include "mpi.h"
 #include "dtcmp.h"
 #include "mfu.h"
@@ -23,6 +27,7 @@ static void print_usage(void)
     printf("Usage: ddup <dir>\n");
     printf("\n");
     printf("Options:\n");
+    printf("      --open-noatime   - open files with O_NOATIME\n");
     printf("  -d, --debug <DEBUG>  - set verbosity, one of: fatal,err,warn,info,dbg\n");
     printf("  -v, --verbose        - verbose output\n");
     printf("  -q, --quiet          - quiet output\n");
@@ -78,9 +83,14 @@ static void mtcmp_cmp_fini(DTCMP_Op* cmp)
 
 /* open the specified file, read specified chunk, and close file,
  * returns -1 on any read error */
-static int read_data(const char* fname, char* chunk_buf, uint64_t chunk_id,
-                     uint64_t chunk_size, uint64_t file_size,
-                     uint64_t* data_size)
+static int read_data(
+    const char* fname,
+    bool noatime,
+    char* chunk_buf,
+    uint64_t chunk_id,
+    uint64_t chunk_size,
+    uint64_t file_size,
+    uint64_t* data_size)
 {
     int status = 0;
 
@@ -93,7 +103,11 @@ static int read_data(const char* fname, char* chunk_buf, uint64_t chunk_id,
     memset(chunk_buf, 0, chunk_size);
 
     /* open the file */
-    int fd = mfu_open(fname, O_RDONLY);
+    int flags = O_RDONLY;
+    if (noatime) {
+        flags |= O_NOATIME;
+    }
+    int fd = mfu_open(fname, flags);
     if (fd < 0) {
         return -1;
     }
@@ -175,7 +189,10 @@ int main(int argc, char** argv)
 
     mfu_debug_level = MFU_LOG_VERBOSE;
 
+    bool open_noatime = false;
+
     static struct option long_options[] = {
+        {"open-noatime", 0, 0, 'U'},
         {"debug",    0, 0, 'd'},
         {"verbose",  0, 0, 'v'},
         {"quiet",    0, 0, 'q'},
@@ -192,6 +209,9 @@ int main(int argc, char** argv)
                             long_options, &option_index)) != -1)
     {
         switch (c) {
+        case 'U':
+            open_noatime = true;
+            break;
         case 'd':
             if (strncmp(optarg, "fatal", 5) == 0) {
                 mfu_debug_level = MFU_LOG_FATAL;
@@ -307,6 +327,10 @@ int main(int argc, char** argv)
 
     /* TODO: spread list among procs? */
 
+    /* determine effective user id and capabilities of current process */
+    mfu_proc_t proc;
+    mfu_proc_set(&proc);
+
     /* get local number of items in flist */
     uint64_t checking_files = mfu_flist_size(flist);
 
@@ -388,15 +412,22 @@ int main(int argc, char** argv)
             /* look up file size */
             file_size = mfu_flist_file_get_size(flist, idx);
 
+            /* open file with O_NOATIME if requested and if possible */
+            bool noatime = false;
+            if (open_noatime) {
+                uid_t owner = (uid_t) mfu_flist_file_get_uid(flist, idx);
+                if (proc.geteuid == owner || proc.cap_fowner) {
+                    noatime = true;
+                }
+            }
+
             /* read a chunk of data from the file into chunk_buf */
             uint64_t data_size;
-            status = read_data(fname, chunk_buf, chunk_id,
+            status = read_data(fname, noatime, chunk_buf, chunk_id,
                                chunk_size, file_size, &data_size);
             if (status) {
                 /* File size has been changed, TODO: handle */
-                printf("failed to read file %s, maybe file "
-                       "size has been modified during the "
-                       "process", fname);
+                MFU_LOG(MFU_LOG_WARN, "Failed to read %s, size may have changed", fname);
             }
 
             /* update the SHA256 context for this file */
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index ac98e14..b7267fc 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -72,6 +72,7 @@ static void print_usage(void)
     printf("  -L, --dereference       - copy original files instead of links\n");
     printf("  -P, --no-dereference    - don't follow links in source\n"); 
     printf("  -s, --direct            - open files with O_DIRECT\n");
+    printf("      --open-noatime      - open files with O_NOATIME\n");
     printf("      --link-dest <DIR>   - hardlink to files in DIR when unchanged\n");
     printf("  -S, --sparse            - create sparse files when possible\n");
     printf("      --progress <N>      - print progress every N seconds\n");
@@ -3022,13 +3023,13 @@ int main(int argc, char **argv)
         {"bufsize",        1, 0, 'B'},
         {"chunksize",      1, 0, 'k'},
         {"xattrs",         1, 0, 'X'},
-        {"daos-prefix",    1, 0, 'Y'},
         {"daos-api",       1, 0, 'y'},
         {"contents",       0, 0, 'c'},
         {"delete",         0, 0, 'D'},
         {"dereference",    0, 0, 'L'},
         {"no-dereference", 0, 0, 'P'},
         {"direct",         0, 0, 's'},
+        {"open-noatime",   0, 0, 'U'},
         {"output",         1, 0, 'o'}, // undocumented
         {"debug",          0, 0, 'd'}, // undocumented
         {"link-dest",      1, 0, 'l'},
@@ -3096,9 +3097,6 @@ int main(int argc, char **argv)
             }
             break;
 #ifdef DAOS_SUPPORT
-        case 'Y':
-            daos_args->dfs_prefix = MFU_STRDUP(optarg);
-            break;
         case 'y':
             if (daos_parse_api_str(optarg, &daos_args->api) != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to parse --daos-api");
@@ -3134,6 +3132,12 @@ int main(int argc, char **argv)
                 MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
             }
             break;
+        case 'U':
+            copy_opts->open_noatime = true;
+            if(rank == 0) {
+                MFU_LOG(MFU_LOG_INFO, "Using O_NOATIME");
+            }
+            break;
         case 'l':
             options.link_dest = MFU_STRDUP(optarg);
             break;
diff --git a/src/dtar/dtar.c b/src/dtar/dtar.c
index 82d5d89..9e92aa3 100644
--- a/src/dtar/dtar.c
+++ b/src/dtar/dtar.c
@@ -145,6 +145,7 @@ static void print_usage(void)
 //    printf("      --preserve-acls     - preserve acls (default ignores acls)\n");
 //    printf("      --preserve-flags    - preserve fflags (default ignores ioctl iflags)\n");
     printf("      --fsync             - sync file data to disk on close\n");
+    printf("      --open-noatime      - open source files with O_NOATIME\n");
     printf("  -b, --bufsize <SIZE>    - IO buffer size in bytes (default " MFU_BUFFER_SIZE_STR ")\n");
     printf("  -k, --chunksize <SIZE>  - work size per task in bytes (default " MFU_CHUNK_SIZE_STR ")\n");
     printf("      --memsize <SIZE>    - memory limit per task for parallel read in bytes (default 256MB)\n");
@@ -200,6 +201,7 @@ int main(int argc, char** argv)
         {"preserve-acls",   0, 0, 'A'},
         {"preserve-flags",  0, 0, 'F'},
         {"fsync",     0, 0, 's'},
+        {"open-noatime",    0, 0, 'U'},
         {"bufsize",   1, 0, 'b'},
         {"chunksize", 1, 0, 'k'},
         {"memsize",   1, 0, 'm'},
@@ -264,6 +266,9 @@ int main(int argc, char** argv)
             case 's':
                 archive_opts->sync_on_close = true;
                 break;
+            case 'U':
+                archive_opts->open_noatime = true;
+                break;
             case 'b':
                 if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
                     if (rank == 0) {
