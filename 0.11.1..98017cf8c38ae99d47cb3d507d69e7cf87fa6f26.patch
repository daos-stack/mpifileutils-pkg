diff --git a/.gitignore b/.gitignore
index ee2bfff..f7d108c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -71,3 +71,6 @@ doc/build
 # spack files
 .spack*
 spack.lock
+
+# Code editors
+.vscode
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index d7c9a01..4ffcf16 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -3,17 +3,12 @@
 *Thank you for taking the time to contribute!*
 
 ## Table of Contents
-[Resources](#resources)
-
 [How To Contribute](#how-to-contribute)
   * [Reporting an Issue & Feature Suggestions](#reporting-an-issue--feature-suggestions)
   * [Pull Requests](#pull-requests)
   * [License](#license)
   * [Contributor's Declaration](#contributors-declaration)
 
-## Resources
-[mpiFileUtils Google Group](https://groups.google.com/forum/#!forum/mpifileutils)
-
 ## How To Contribute
 
 ### Reporting an Issue & Feature Suggestions
diff --git a/doc/rst/build.rst b/doc/rst/build.rst
index 047ba87..aedf67c 100644
--- a/doc/rst/build.rst
+++ b/doc/rst/build.rst
@@ -34,7 +34,7 @@ To be certain of compatibility, it is recommended that one install libarchive-3.
    mkdir install
    installdir=`pwd`/install
 
-   wget https://github.com/libarchive/libarchive/releases/download/3.5.1/libarchive-3.5.1.tar.gz
+   wget https://github.com/libarchive/libarchive/releases/download/v3.5.1/libarchive-3.5.1.tar.gz
    tar -zxf libarchive-3.5.1.tar.gz
    cd libarchive-3.5.1
      ./configure --prefix=$installdir
@@ -135,7 +135,7 @@ which can be done with the following commands:
      wget https://github.com/hpc/libcircle/releases/download/v0.3/libcircle-0.3.0.tar.gz
      wget https://github.com/llnl/lwgrp/releases/download/v1.0.4/lwgrp-1.0.4.tar.gz
      wget https://github.com/llnl/dtcmp/releases/download/v1.1.4/dtcmp-1.1.4.tar.gz
-     wget https://github.com/libarchive/libarchive/releases/download/3.5.1/libarchive-3.5.1.tar.gz
+     wget https://github.com/libarchive/libarchive/releases/download/v3.5.1/libarchive-3.5.1.tar.gz
 
      tar -zxf libcircle-0.3.0.tar.gz
      cd libcircle-0.3.0
diff --git a/src/common/mfu_daos.c b/src/common/mfu_daos.c
index 8f53133..1956f92 100644
--- a/src/common/mfu_daos.c
+++ b/src/common/mfu_daos.c
@@ -210,13 +210,11 @@ static int daos_check_args(
     bool have_src_cont  = strlen(da->src_cont) ? true : false;
     bool have_dst_pool  = strlen(da->dst_pool) ? true : false;
     bool have_dst_cont  = strlen(da->dst_cont) ? true : false;
-    bool have_prefix    = (da->dfs_prefix != NULL);
 
     /* Determine whether any DAOS arguments are supplied. 
      * If not, then there is nothing to check. */
     *flag_daos_args = 0;
-    if (have_src_pool || have_src_cont || have_dst_pool || have_dst_cont
-            || have_prefix) {
+    if (have_src_pool || have_src_cont || have_dst_pool || have_dst_cont) {
         *flag_daos_args = 1;
     }
     if ((have_src_path && (strncmp(src_path, "daos:", 5) == 0)) ||
@@ -276,37 +274,6 @@ static int daos_check_args(
     return rc;
 }
 
-/* Checks if the prefix is valid.
- * If valid, returns matching string into suffix */
-static bool daos_check_prefix(
-    char* path,
-    const char* dfs_prefix,
-    char** suffix)
-{
-    bool is_prefix = false;
-    int prefix_len = strlen(dfs_prefix);
-    int path_len = strlen(path);
-
-    /* ignore trailing '/' on the prefix */
-    if (dfs_prefix[prefix_len-1] == '/') {
-        prefix_len--;
-    }
-
-    /* figure out if dfs_prefix is a prefix of the file path */
-    if (strncmp(path, dfs_prefix, prefix_len) == 0) {
-        /* if equal, assume root */
-        if (path_len == prefix_len) {
-            *suffix = strdup("/");
-            is_prefix = true;
-        }
-        /* if path is longer, it must start with '/' */
-        else if (path_len > prefix_len && path[prefix_len] == '/') {
-            *suffix = strdup(path + prefix_len);
-            is_prefix = true;
-        }
-    }
-    return is_prefix;
-}
 
 /*
  * Parse a path of the format:
@@ -415,106 +382,39 @@ static int daos_set_paths(
 {
     int     rc = 0;
     bool    have_dst = (numpaths > 1);
-    bool    prefix_on_src = false;
-    bool    prefix_on_dst = false;
-    char*   prefix_path = NULL;
     char*   src_path = NULL;
     char*   dst_path = NULL;
 
-    /* find out if a dfs_prefix is being used,
-     * if so, then that means that the container
-     * is not being copied from the root of the
-     * UNS path  */
-    if (da->dfs_prefix != NULL) {
-        char prefix_pool[DAOS_PROP_LABEL_MAX_LEN + 1];
-        char prefix_cont[DAOS_PROP_LABEL_MAX_LEN + 1];
-        int prefix_rc;
-
-        size_t prefix_len = strlen(da->dfs_prefix);
-        prefix_path = strndup(da->dfs_prefix, prefix_len);
-        if (prefix_path == NULL) {
-            MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for DAOS prefix.");
-            rc = 1;
-            goto out;
-        }
-
-        memset(prefix_pool, '\0', DAOS_PROP_LABEL_MAX_LEN + 1);
-        memset(prefix_cont, '\0', DAOS_PROP_LABEL_MAX_LEN + 1);
-
-        /* Get the pool/container uuids from the prefix */
-        prefix_rc = daos_parse_path(prefix_path, prefix_len,
-                                    &prefix_pool, &prefix_cont);
-        if (prefix_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS Prefix UNS path");
-            rc = 1;
-            goto out;
-        }
-
-        /* In case the user tries to give a sub path in the UNS path */
-        if (strcmp(prefix_path, "/") != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS prefix must be a UNS path");
-            rc = 1;
-            goto out;
-        }
-
-        /* Check if the prefix matches the source */
-        prefix_on_src = daos_check_prefix(argpaths[0], da->dfs_prefix, &da->src_path);
-        if (prefix_on_src) {
-            snprintf(da->src_pool, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_pool);
-            snprintf(da->src_cont, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_cont);
-            argpaths[0] = da->src_path;
-        }
-
-        if (have_dst) {
-            /* Check if the prefix matches the destination */
-            prefix_on_dst = daos_check_prefix(argpaths[1], da->dfs_prefix, &da->dst_path);
-            if (prefix_on_dst) {
-                snprintf(da->dst_pool, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_pool);
-                snprintf(da->dst_cont, DAOS_PROP_LABEL_MAX_LEN + 1, "%s", prefix_cont);
-                argpaths[1] = da->dst_path;
-            }
-        }
-
-        if (!prefix_on_src && !prefix_on_dst) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS prefix does not match source or destination");
-            rc = 1;
-            goto out;
-        }
-    }
-
     /*
-     * For the source and destination paths,
-     * if they are not using a prefix,
-     * then just directly try to parse a DAOS path.
+     * Try to parse a DAOS source and/or destination path.
      */
-    if (!prefix_on_src) {
-        size_t src_len = strlen(argpaths[0]);
-        src_path = strndup(argpaths[0], src_len);
-        if (src_path == NULL) {
-            MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
+    size_t src_len = strlen(argpaths[0]);
+    src_path = strndup(argpaths[0], src_len);
+    if (src_path == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
+        rc = 1;
+        goto out;
+    }
+    int src_rc = daos_parse_path(src_path, src_len, &da->src_pool, &da->src_cont);
+    if (src_rc == 0) {
+        if (strlen(da->src_cont) == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source pool requires a source container.");
             rc = 1;
             goto out;
         }
-        int src_rc = daos_parse_path(src_path, src_len, &da->src_pool, &da->src_cont);
-        if (src_rc == 0) {
-            if (strlen(da->src_cont) == 0) {
-                MFU_LOG(MFU_LOG_ERR, "Source pool requires a source container.");
-                rc = 1;
-                goto out;
-            }
-            argpaths[0] = da->src_path = strdup(src_path);
-            if (argpaths[0] == NULL) {
-                MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
-                rc = 1;
-                goto out;
-            }
-        } else if (src_rc == -1) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS source path: daos://<pool>/<cont>[/<path>]");
+        argpaths[0] = da->src_path = strdup(src_path);
+        if (argpaths[0] == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for source path.");
             rc = 1;
             goto out;
         }
+    } else if (src_rc == -1) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS source path: daos://<pool>/<cont>[/<path>]");
+        rc = 1;
+        goto out;
     }
-    if (have_dst && !prefix_on_dst) {
+
+    if (have_dst) {
         size_t dst_len = strlen(argpaths[1]);
         dst_path = strndup(argpaths[1], dst_len);
         if (dst_path == NULL) {
@@ -535,9 +435,7 @@ static int daos_set_paths(
             rc = 1;
             goto out;
         }
-    }
 
-    if (have_dst) {
         int dst_cont_len = strlen(da->dst_cont);
         *dst_cont_passed = dst_cont_len > 0 ? true : false;
         /* Generate a new container uuid if only a pool was given. */
@@ -547,7 +445,6 @@ static int daos_set_paths(
     }
 
 out:
-    mfu_free(&prefix_path);
     mfu_free(&src_path);
     mfu_free(&dst_path);
     return rc;
@@ -1182,7 +1079,9 @@ int daos_connect(
              * If nothing is passed in for destination a uuid is always generated
              * unless user passed one in, because destination container labels are
              * not generated */
-            rc = daos_cont_open(*poh, da->dst_cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+            char cont_str[130];
+            uuid_unparse(da->dst_cont_uuid, cont_str);
+            rc = daos_cont_open(*poh, cont_str, DAOS_COO_RW, coh, &co_info, NULL);
         } else {
             rc = daos_cont_open(*poh, *cont, DAOS_COO_RW, coh, &co_info, NULL);
         }
@@ -1273,14 +1172,12 @@ int daos_connect(
             }
 
             /* try to open it again */
-            if (dst_cont_passed) {
-                if (is_uuid) {
-                    rc = daos_cont_open(*poh, da->dst_cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
-                } else {
-                    rc = daos_cont_open(*poh, *cont, DAOS_COO_RW, coh, &co_info, NULL);
-                }
+            if (dst_cont_passed && !is_uuid) {
+                rc = daos_cont_open(*poh, *cont, DAOS_COO_RW, coh, &co_info, NULL);
             } else {
-                rc = daos_cont_open(*poh, da->dst_cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+                char cont_str[130];
+                uuid_unparse(da->dst_cont_uuid, cont_str);
+                rc = daos_cont_open(*poh, cont_str, DAOS_COO_RW, coh, &co_info, NULL);
             }
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to open container: "DF_RC, DP_RC(rc));
@@ -1436,7 +1333,6 @@ daos_args_t* daos_args_new(void)
     da->dst_poh    = DAOS_HDL_INVAL;
     da->src_coh    = DAOS_HDL_INVAL;
     da->dst_coh    = DAOS_HDL_INVAL;
-    da->dfs_prefix = NULL;
     da->src_path   = NULL;
     da->dst_path   = NULL;
 
@@ -1470,7 +1366,6 @@ void daos_args_delete(daos_args_t** pda)
 {
     if (pda != NULL) {
         daos_args_t* da = *pda;
-        mfu_free(&da->dfs_prefix);
         mfu_free(&da->src_path);
         mfu_free(&da->dst_path);
         mfu_free(&da->daos_preserve_path);
@@ -1639,10 +1534,7 @@ int daos_setup(
         }
     }
 
-    /* Figure out if daos path is the src or dst,
-     * using UNS path, then chop off UNS path
-     * prefix since the path is mapped to the root
-     * of the container in the DAOS DFS mount */
+    /* Figure out if daos path is the src or dst */
     if (!local_daos_error) {
         tmp_rc = daos_set_paths(rank, argpaths, numpaths, da, &dst_cont_passed);
         if (tmp_rc != 0) {
@@ -2420,7 +2312,7 @@ static int mfu_daos_obj_sync(
 
     /* open handle of object in dst container */
     daos_handle_t dst_oh;
-    rc = daos_obj_open(dst_coh, oid, DAOS_OO_EXCL, &dst_oh, NULL);
+    rc = daos_obj_open(dst_coh, oid, DAOS_OO_RW, &dst_oh, NULL);
     if (rc != 0) {
         MFU_LOG(MFU_LOG_ERR, "DAOS object open returned with errors: " MFU_ERRF,
                 MFU_ERRP(-MFU_ERR_DAOS));
@@ -3857,7 +3749,7 @@ static int cont_serialize_prop_str(struct hdf5_args* hdf5,
     hid_t   attr_dspace;
     hid_t   usr_attr;
 
-    if (entry == NULL || entry->dpe_str == NULL) {
+    if (entry == NULL) {
         MFU_LOG(MFU_LOG_ERR, "Property %s not found", prop_str);
         rc = 1;
         goto out;
@@ -3870,7 +3762,7 @@ static int cont_serialize_prop_str(struct hdf5_args* hdf5,
         rc = 1;
         goto out;
     }
-    status = H5Tset_size(attr_dtype, strlen(entry->dpe_str) + 1);
+    status = H5Tset_size(attr_dtype, (entry->dpe_str ? strlen(entry->dpe_str) : 0) + 1);
     if (status < 0) {
         MFU_LOG(MFU_LOG_ERR, "failed to set dtype size");
         rc = 1;
@@ -3895,7 +3787,7 @@ static int cont_serialize_prop_str(struct hdf5_args* hdf5,
         rc = 1;
         goto out;
     }   
-    status = H5Awrite(usr_attr, attr_dtype, entry->dpe_str);
+    status = H5Awrite(usr_attr, attr_dtype, entry->dpe_str ? entry->dpe_str : "");
     if (status < 0) {
         MFU_LOG(MFU_LOG_ERR, "failed to write attribute");
         rc = 1;
@@ -4301,7 +4193,7 @@ int daos_cont_serialize_hdlr(int rank, struct hdf5_args *hdf5, char *output_dir,
                 goto out;
             }
         } else {
-            rc = daos_obj_open(da->src_coh, oid, 0, &oh, NULL);
+            rc = daos_obj_open(da->src_coh, oid, DAOS_OO_RO, &oh, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "failed to open object: "DF_RC, DP_RC(rc));
                 goto out;
@@ -5394,22 +5286,23 @@ int cont_deserialize_all_props(struct hdf5_args *hdf5,
         goto out;
     }
 
-    rc = daos_cont_open(poh, label_entry->dpe_str, DAOS_COO_RW, &coh, &cont_info, NULL);
-    if (rc == -DER_NONEXIST) {
-        /* doesn't exist so ok to deserialize this container label */
-        deserialize_label = true;
-    } else if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "daos_cont_open failed: "DF_RC, DP_RC(rc));
-        goto out;
-    }  else {
-        /* if this succeeds then label already exists, close container after
-         * checking */
-        rc = daos_cont_close(coh, NULL);
-        if (rc != 0) {
+    if (label_entry->dpe_str[0]) {
+        rc = daos_cont_open(poh, label_entry->dpe_str, DAOS_COO_RW, &coh, &cont_info, NULL);
+        if (rc == -DER_NONEXIST) {
+            /* doesn't exist so ok to deserialize this container label */
+            deserialize_label = true;
+        } else if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "daos_cont_open failed: "DF_RC, DP_RC(rc));
             goto out;
+        }  else {
+            /* if this succeeds then label already exists, close container after
+             * checking */
+            rc = daos_cont_close(coh, NULL);
+            if (rc != 0) {
+                goto out;
+            }
         }
     }
-
     if (deserialize_label) {
         num_props++;
     }
@@ -5617,7 +5510,7 @@ int daos_cont_deserialize_connect(daos_args_t *daos_args,
     } else {
         uuid_unparse(daos_args->dst_cont_uuid, cont_str);
         MFU_LOG(MFU_LOG_INFO, "Successfully created container %s", cont_str);
-        rc = daos_cont_open(daos_args->src_poh, daos_args->dst_cont_uuid,
+        rc = daos_cont_open(daos_args->src_poh, cont_str,
                             DAOS_COO_RW, &daos_args->src_coh, &co_info, NULL);
     }
     if (rc != 0) {
@@ -5714,7 +5607,7 @@ int daos_cont_deserialize_hdlr(int rank, daos_args_t *da, const char *h5filename
                 goto out;
             }
         } else {
-            rc = daos_obj_open(da->src_coh, oid, 0, &oh, NULL);
+            rc = daos_obj_open(da->src_coh, oid, DAOS_OO_RW, &oh, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "failed to open object: "DF_RC, DP_RC(rc));
                 goto out;
diff --git a/src/common/mfu_daos.h b/src/common/mfu_daos.h
index 86624c0..4ebb96b 100644
--- a/src/common/mfu_daos.h
+++ b/src/common/mfu_daos.h
@@ -40,7 +40,6 @@ typedef struct {
     char dst_cont[DAOS_PROP_LABEL_MAX_LEN + 1];
     /* if destination container is not created new UUID is generated */
     uuid_t dst_cont_uuid;   /* destination container UUID */
-    char* dfs_prefix;       /* prefix for UNS */
     char* src_path;         /* allocated src path */
     char* dst_path;         /* allocated dst path */
     daos_api_t api;         /* API to use */
diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index f5acaab..0e9c78f 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -1680,12 +1680,20 @@ static int mfu_copy_file_normal(
         /* If we're using O_DIRECT, deal with short reads.
          * Retry with same buffer and offset since those must
          * be aligned at block boundaries. */
+        int retries = 0;
         while (copy_opts->direct &&            /* using O_DIRECT */
                bytes_read > 0 &&               /* read was not an error or eof */
                bytes_read < left_to_read &&    /* shorter than requested */
                (off + bytes_read) < file_size) /* not at end of file */
         {
-            /* TODO: probably should retry a limited number of times then abort */
+            /* try the read a limited number of times then given up with error */
+            retries++;
+            if (retries == 5) {
+              MFU_LOG(MFU_LOG_ERR, "Source file `%s' exceeded short read limit, maybe shorter than expected size of %llu bytes",
+                  src, file_size);
+              return -1;
+            }
+
             bytes_read = mfu_file_pread(src, buf, left_to_read, off, mfu_src_file);
         }
 
@@ -1698,8 +1706,8 @@ static int mfu_copy_file_normal(
 
         /* check for early EOF */
         if (bytes_read == 0) {
-            MFU_LOG(MFU_LOG_ERR, "Source file `%s' shorter than expected %llu (errno=%d %s)",
-                src, file_size, errno, strerror(errno));
+            MFU_LOG(MFU_LOG_ERR, "Source file `%s' shorter than expected size of %llu bytes",
+                src, file_size);
             return -1;
         }
 
diff --git a/src/common/mfu_param_path.c b/src/common/mfu_param_path.c
index 488d4f2..44da9e6 100644
--- a/src/common/mfu_param_path.c
+++ b/src/common/mfu_param_path.c
@@ -401,13 +401,12 @@ char* mfu_param_path_copy_dest(const char* name, int numpaths,
      * if path is root, keep last component.
      * otherwise cut all components listed in source path */
     int cut = src_components;
-    if (mfu_copy_opts->copy_into_dir && cut > 0) {
-        if (strcmp(paths[i].orig, "/") == 0) {
-            cut--;
-        } else if ((mfu_copy_opts->do_sync != 1) &&
-            (paths[i].orig[strlen(paths[i].orig) - 1] != '/')) {
-            cut--;
-        }
+    if (cut > 0 && strcmp(paths[i].orig, "/") == 0) {
+        cut--;
+    }
+    else if ((cut > 0) && mfu_copy_opts->copy_into_dir &&
+            (mfu_copy_opts->do_sync != 1) && (paths[i].orig[strlen(paths[i].orig) - 1] != '/')) {
+        cut--;
     }
 
     /* compute number of components to keep */
diff --git a/src/daos-gen/daos-gen.c b/src/daos-gen/daos-gen.c
index d96373a..46ee44d 100644
--- a/src/daos-gen/daos-gen.c
+++ b/src/daos-gen/daos-gen.c
@@ -18,6 +18,14 @@
 #define BUFLEN 80
 #define UUID_STR_LEN 129
 
+#if defined(DAOS_API_VERSION_MAJOR) && defined(DAOS_API_VERSION_MINOR)
+#define CHECK_DAOS_API_VERSION(major, minor)                                            \
+	((DAOS_API_VERSION_MAJOR > (major))                                             \
+	 || (DAOS_API_VERSION_MAJOR == (major) && DAOS_API_VERSION_MINOR >= (minor)))
+#else
+#define CHECK_DAOS_API_VERSION(major, minor) 0
+#endif
+
 static uint32_t obj_id_gen = 1;
 
 /** Print a usage message. */
@@ -176,13 +184,18 @@ int main(int argc, char** argv)
     char                key[keys_per_object];
     int                 i,j;
     char                uuid_str[UUID_STR_LEN];
+    uuid_t              cont_uuid;
+
+#if CHECK_DAOS_API_VERSION(2, 0)
+    enum daos_otype_t   otype;
+    otype = DAOS_OT_KV_HASHED;
+#else
     daos_ofeat_t        ofeats;
+    ofeats = DAOS_OF_KV_FLAT;
+#endif
 
-    ofeats = DAOS_OF_DKEY_UINT64 | DAOS_OF_KV_FLAT | DAOS_OF_KV_FLAT;
     /* connect to pool/cont then broadcast to rest of ranks */
     if (rank == 0) {
-        /* generate container UUID */
-        uuid_generate(daos_args->src_cont);
         daos_pool_info_t pool_info = {0};
         daos_cont_info_t co_info = {0};
 #if DAOS_API_VERSION_MAJOR < 1
@@ -199,14 +212,27 @@ int main(int argc, char** argv)
         }
 
         /* create cont and open */
+#if CHECK_DAOS_API_VERSION(2, 0)
+        rc = daos_cont_create(daos_args->src_poh, &cont_uuid, NULL, NULL);
+#else
+        /* generate container UUID */
+        uuid_generate(daos_args->src_cont);
+        uuid_copy(cont_uuid, daos_args->src_cont);
         rc = daos_cont_create(daos_args->src_poh, daos_args->src_cont, NULL, NULL);
+#endif
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to create cont: "DF_RC, DP_RC(rc));
             rc = 1;
             goto err_cont;
         }
+        uuid_unparse(cont_uuid, uuid_str);
+#if CHECK_DAOS_API_VERSION(2, 0)
+        rc = daos_cont_open(daos_args->src_poh, uuid_str,
+                            DAOS_COO_RW, &daos_args->src_coh, &co_info, NULL);
+#else
         rc = daos_cont_open(daos_args->src_poh, daos_args->src_cont,
                             DAOS_COO_RW, &daos_args->src_coh, &co_info, NULL);
+#endif
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to open container: "DF_RC, DP_RC(rc));
             rc = 1;
@@ -222,8 +248,11 @@ int main(int argc, char** argv)
 	memset(buf, 'A', BUFLEN);
     for (i = 0; i < num_objects; i++) {
         oid[i] = dts_oid_gen(0);
-                                   
+#if CHECK_DAOS_API_VERSION(2, 0)
+        rc = daos_obj_generate_oid(daos_args->src_coh, &oid[i], otype, OC_RP_XSF, 0, 0);
+#else                                   
         rc = daos_obj_generate_oid(daos_args->src_coh, &oid[i], ofeats, OC_RP_XSF, 0, 0);
+#endif
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to generate oid: "DF_RC, DP_RC(rc));
             rc = 1;
@@ -261,7 +290,6 @@ int main(int argc, char** argv)
      * generates same amount */
     if (rank == 0) {
         int total_num_objects = size * num_objects; 
-        uuid_unparse(daos_args->src_cont, uuid_str);
         printf("Container UUID: %s\n\ttotal objects:%d\n"
                "\tkeys per object:%d\n", uuid_str, total_num_objects, keys_per_object);
     }
diff --git a/src/dcmp/dcmp.c b/src/dcmp/dcmp.c
index cc4deb0..10a31ad 100644
--- a/src/dcmp/dcmp.c
+++ b/src/dcmp/dcmp.c
@@ -2118,7 +2118,6 @@ int main(int argc, char **argv)
         {"base",          0, 0, 'b'},
         {"bufsize",       1, 0, 'B'},
         {"chunksize",     1, 0, 'k'},
-        {"daos-prefix",   1, 0, 'X'},
         {"daos-api",      1, 0, 'x'},
         {"direct",        0, 0, 's'},
         {"progress",      1, 0, 'R'},
@@ -2208,9 +2207,6 @@ int main(int argc, char **argv)
             options.debug++;
             break;
 #ifdef DAOS_SUPPORT
-        case 'X':
-            daos_args->dfs_prefix = MFU_STRDUP(optarg);
-            break;
         case 'x':
             if (daos_parse_api_str(optarg, &daos_args->api) != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to parse --daos-api");
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index fc47f19..05ac769 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -145,7 +145,6 @@ int main(int argc, char** argv)
         {"bufsize"              , required_argument, 0, 'b'},
         {"debug"                , required_argument, 0, 'd'}, // undocumented
         {"grouplock"            , required_argument, 0, 'g'}, // untested
-        {"daos-prefix"          , required_argument, 0, 'Y'},
         {"daos-api"             , required_argument, 0, 'y'},
         {"daos-preserve"        , required_argument, 0, 'D'},
         {"input"                , required_argument, 0, 'i'},
@@ -251,9 +250,6 @@ int main(int argc, char** argv)
                 break;
 #endif
 #ifdef DAOS_SUPPORT
-            case 'Y':
-                daos_args->dfs_prefix = MFU_STRDUP(optarg);
-                break;
             case 'y':
                 if (daos_parse_api_str(optarg, &daos_args->api) != 0) {
                     MFU_LOG(MFU_LOG_ERR, "Failed to parse --daos-api");
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index ac98e14..fe25a28 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -3022,7 +3022,6 @@ int main(int argc, char **argv)
         {"bufsize",        1, 0, 'B'},
         {"chunksize",      1, 0, 'k'},
         {"xattrs",         1, 0, 'X'},
-        {"daos-prefix",    1, 0, 'Y'},
         {"daos-api",       1, 0, 'y'},
         {"contents",       0, 0, 'c'},
         {"delete",         0, 0, 'D'},
@@ -3096,9 +3095,6 @@ int main(int argc, char **argv)
             }
             break;
 #ifdef DAOS_SUPPORT
-        case 'Y':
-            daos_args->dfs_prefix = MFU_STRDUP(optarg);
-            break;
         case 'y':
             if (daos_parse_api_str(optarg, &daos_args->api) != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to parse --daos-api");
