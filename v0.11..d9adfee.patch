diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8cef16b..6107e7c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -92,6 +92,15 @@ IF(ENABLE_LIBARCHIVE)
   ADD_DEFINITIONS(-DLIBARCHIVE_SUPPORT)
 ENDIF(ENABLE_LIBARCHIVE)
 
+## hdf5 
+OPTION(ENABLE_HDF5 "Enable HDF5 library")
+IF(ENABLE_HDF5)
+  FIND_PACKAGE(HDF5 REQUIRED)
+  INCLUDE_DIRECTORIES(${HDF5_INCLUDE_DIRS})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${HDF5_LIBRARIES})
+  ADD_DEFINITIONS(-DHDF5_SUPPORT)
+ENDIF(ENABLE_HDF5)
+
 OPTION(ENABLE_DAOS "Enable DAOS support")
 IF(ENABLE_DAOS)
   SET(CMAKE_EXE_LINKER_FLAGS -luuid)
diff --git a/DAOS-Support.md b/DAOS-Support.md
index 3e01829..9fd2156 100644
--- a/DAOS-Support.md
+++ b/DAOS-Support.md
@@ -1,7 +1,13 @@
 # DAOS Support
 
-[DAOS](https://github.com/daos-stack/daos) is supported as a backend storage system in dcp, dsync, and dcmp. The build instructions for
-enabling DAOS support can be found here:
+[DAOS](https://github.com/daos-stack/daos) is supported as a backend storage system in
+dcp, dsync, and dcmp. Custom serialization and deserialization for DAOS
+containers to and from a POSIX filesystem is provided with daos-serialize and
+daos-deserialize. A DAOS container and its associated
+metadata can be serialized to an HDF5 file for storage on a POSIX filesystem using daos-serialize. The container data
+can be later restored to DAOS via the use of daos-deserialize.
+
+The build instructions for enabling DAOS support can be found here:
 [Enable DAOS](https://mpifileutils.readthedocs.io/en/latest/build.html#build-everything-directly).
 The following are ways that DAOS can be used to move data both across DAOS as well as POSIX
 filesystems in dcp and dsync:
@@ -14,21 +20,7 @@ For dcp, the DAOS->DAOS case supports both POSIX and non-POSIX DAOS containers.
 
 For dsync, the DAOS->DAOS case currently only supports POSIX containers.
 
-## DAOS Data Movement Use Cases
-
-In each use case, it is assumed that the pools and containers used already exist.
-Also, only one DAOS source is supported.
-
-1. **DAOS Destination**
-    * Container is assumed to exist already
-
-2. **DAOS Source**
-    * Source container exists
-
-3. **DAOS Source and Destination**
-    * Copy across two different pools
-    * Copy across containers in the same pool
-    * Copying non-POSIX containers is only supported for the DAOS -> DAOS case in dcp
+For daos-serialize and daos-deserialize, any type of DAOS container is supported. 
 
 ## DAOS POSIX Data Movement Examples with dcp
 
@@ -163,3 +155,62 @@ Number of items that exist in both directories and have different types: 0 (Src:
 Number of items that exist in both directories and have the same content: 1 (Src: 1 Dest: 1)
 Number of items that exist in both directories and have different contents: 0 (Src: 0 Dest: 0)
 ```
+
+## DAOS Serialization and Deserialization Examples
+
+daos-serialize and daos-deserialize can be used on any type of DAOS container.
+They are DAOS only tools that require HDF5.
+
+daos-serialize will serialize a DAOS container to an HDF5 file. Depending on
+the amount of data, multiple files may be written for each rank specified in the job.
+
+daos-deserialize will deserialize or restore the HDF5 files written into a new
+DAOS container, and a pool UUID to deserialize the data to must be specified.
+
+#### Example One
+
+Show the serialization of a DAOS container
+
+```shell
+$ mpirun -np 3 daos-serialize -v /$pool1/$cont1
+Serializing Container to 7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank0.h5
+Serializing Container to 7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank1.h5
+Serializing Container to 7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank2.h5
+```
+
+#### Example Two
+
+Show the serialization of a DAOS container by specifying output directory
+
+```shell
+$ mpirun -np 3 daos-serialize -v -o serialize /$pool1/$cont1
+Serializing Container to serialize/7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank0.h5
+Serializing Container to serialize/7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank1.h5
+Serializing Container to serialize/7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank2.h5
+```
+#### Example Three 
+
+Show the deserialization of an HDF5 file
+
+```shell
+$ mpirun -np 3 daos-deserialize -v 7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank0.h5
+7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank1.h5 2-7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank2.h5
+
+Successfully created container cbc52064-303e-497d-afaf-fa554c18e08f
+    Deserializing filename: 7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank0.h5
+    Deserializing filename: 7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank1.h5
+    Deserializing filename: 7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank2.h5
+```
+
+#### Example Four
+
+Show the deserialization of HDF5 files from a specified directory
+
+```shell
+$ mpirun -np 3 daos-deserialize -v serialize
+
+Successfully created container 8d6a6083-4009-4afe-8364-7caa5ebaa72b
+    Deserializing filename: serialize/7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank0.h5
+    Deserializing filename: serialize/7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank1.h5
+    Deserializing filename: serialize/7bf8037d-823f-4fa5-ac2a-c2cae8f81f57_rank2.h5
+```
diff --git a/cmake/FindHDF5.cmake b/cmake/FindHDF5.cmake
new file mode 100644
index 0000000..75909f4
--- /dev/null
+++ b/cmake/FindHDF5.cmake
@@ -0,0 +1,31 @@
+# - Try to find hdf5
+# Once done this will define
+#  HDF5_FOUND - System has hdf5
+#  HDF5_INCLUDE_DIRS - The hdf5 include directories
+#  HDF5_LIBRARIES - The libraries needed to use hdf5
+
+FIND_PATH(WITH_HDF5_PREFIX
+    NAMES include/hdf5.h
+)
+
+FIND_LIBRARY(HDF5_LIBRARIES
+    NAMES hdf5 
+    HINTS ${WITH_HDF5_PREFIX}/lib
+)
+
+FIND_PATH(HDF5_INCLUDE_DIRS
+    NAMES hdf5.h
+    HINTS ${WITH_HDF5_PREFIX}/include
+)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(HDF5 DEFAULT_MSG
+    HDF5_LIBRARIES
+    HDF5_INCLUDE_DIRS
+)
+
+# Hide these vars from ccmake GUI
+MARK_AS_ADVANCED(
+	HDF5_LIBRARIES
+	HDF5_INCLUDE_DIRS
+)
diff --git a/doc/rst/daos-deserialize.1.rst b/doc/rst/daos-deserialize.1.rst
new file mode 100644
index 0000000..324b454
--- /dev/null
+++ b/doc/rst/daos-deserialize.1.rst
@@ -0,0 +1,51 @@
+daos-deserialize
+===
+
+SYNOPSIS
+--------
+
+**daos-deserialize [OPTION] [<file> <file> ...] || [</path/to/directory>]**
+
+DESCRIPTION
+-----------
+
+Parallel MPI application to deserialize HDF5 files into a DAOS container.
+
+daos-deserialize is a deserialization tool that will restore DAOS data written
+to an HDF5 file with daos-serialize. The tool will restore the data in the
+the HDF5 file into a DAOS container.
+
+OPTIONS
+-------
+.. option:: --pool UUID 
+
+   Specify the pool where the restored DAOS container will be created 
+
+.. option:: -v, --verbose
+
+   Run in verbose mode.
+
+.. option:: -q, --quiet
+
+   Run tool silently. No output is printed.
+
+.. option:: -h, --help
+
+   Print a brief message listing the :manpage:`daos-deserialize(1)` options and usage.
+
+EXAMPLES
+--------
+
+1. To deserialize a DAOS container by specifying individual files:
+
+``mpirun -np 128 daos-deserialize <file1> <file2>``
+
+2. To deserialize a DAOS container by specifying a directory with HDF5 files:
+
+``mpirun -np 128 daos-deserialize /path/to/dir``
+
+SEE ALSO
+--------
+
+The mpiFileUtils source code and all documentation may be downloaded
+from <https://github.com/hpc/mpifileutils>
diff --git a/doc/rst/daos-serialize.1.rst b/doc/rst/daos-serialize.1.rst
new file mode 100644
index 0000000..d9b46bc
--- /dev/null
+++ b/doc/rst/daos-serialize.1.rst
@@ -0,0 +1,54 @@
+daos-serialize
+===
+
+SYNOPSIS
+--------
+
+**daos-serialize [OPTION] /<pool>/<cont>**
+
+DESCRIPTION
+-----------
+
+Parallel MPI application to serialize a DAOS container to an HDF5 file.
+
+daos-serialize is a serialization tool that will allow storing any type
+of DAOS container on a POSIX filesystem. It allows DAOS container data to
+be stored outside of the DAOS system. The DAOS container is converted
+to a set of files in HDF5 format. The serialization format of the container is meant to
+be deserialized by daos-deserialize.
+
+OPTIONS
+-------
+.. option:: -o, --output-path PATH
+
+   Write the HDF5 files generated during serialization to the specified
+   output path.
+
+.. option:: -v, --verbose
+
+   Run in verbose mode.
+
+.. option:: -q, --quiet
+
+   Run tool silently. No output is printed.
+
+.. option:: -h, --help
+
+   Print a brief message listing the :manpage:`daos-serialize(1)` options and usage.
+
+EXAMPLES
+--------
+
+1. To serialize a DAOS container:
+
+``mpirun -np 128 daos-serialize /<pool>/<container>``
+
+2. To serialize a DAOS container to a specific directory:
+
+``mpirun -np 128 daos-serialize -o /path/to/output/dir /<pool>/<container>``
+
+SEE ALSO
+--------
+
+The mpiFileUtils source code and all documentation may be downloaded
+from <https://github.com/hpc/mpifileutils>
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 2f83d2d..1bbfcd2 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -15,6 +15,10 @@ ADD_SUBDIRECTORY(dreln)
 ADD_SUBDIRECTORY(drm)
 ADD_SUBDIRECTORY(dstripe)
 ADD_SUBDIRECTORY(dsync)
+IF(ENABLE_DAOS AND ENABLE_HDF5)
+  ADD_SUBDIRECTORY(daos-serialize)
+  ADD_SUBDIRECTORY(daos-deserialize)
+ENDIF(ENABLE_DAOS AND ENABLE_HDF5)
 IF(ENABLE_LIBARCHIVE)
   ADD_SUBDIRECTORY(dtar)
 ENDIF(ENABLE_LIBARCHIVE)
diff --git a/src/common/mfu_daos.c b/src/common/mfu_daos.c
index c9ebc02..beb2db4 100644
--- a/src/common/mfu_daos.c
+++ b/src/common/mfu_daos.c
@@ -14,10 +14,145 @@
 #include <gurt/common.h>
 #include <gurt/hash.h>
 
+#ifdef HDF5_SUPPORT
+#include <hdf5.h>
+#if H5_VERS_MAJOR == 1 && H5_VERS_MINOR < 12
+#define H5Sencode1 H5Sencode
+#endif
+#endif
+
 /*
  * Private definitions.
  */
 
+typedef struct mfu_daos_copy_stats {
+    uint64_t total_oids;    /* sum of object ids */
+    uint64_t total_dkeys;   /* sum of dkeys */
+    uint64_t total_akeys;   /* sum of akeys */
+    uint64_t bytes_read;    /* sum of bytes read (src and dst) */
+    uint64_t bytes_written; /* sum of bytes written */
+    time_t   time_started;  /* time when copy started */
+    time_t   time_ended;    /* time when copy ended */
+    double   wtime_started; /* relative time when copy started */
+    double   wtime_ended;   /* relative time when copy ended */
+} mfu_daos_copy_stats_t;
+
+static inline void mfu_daos_copy_stats_init(mfu_daos_copy_stats_t* stats)
+{
+    stats->total_oids = 0;
+    stats->total_dkeys = 0;
+    stats->total_dkeys = 0;
+    stats->total_akeys = 0;
+    stats->bytes_read = 0;
+    stats->bytes_written = 0;
+    stats->wtime_started = 0;
+    stats->wtime_ended = 0;
+}
+
+static inline void mfu_daos_copy_stats_start(mfu_daos_copy_stats_t* stats)
+{
+    time(&stats->time_started);
+    stats->wtime_started = MPI_Wtime();
+}
+
+static inline void mfu_daos_copy_stats_end(mfu_daos_copy_stats_t* stats)
+{
+    time(&stats->time_ended);
+    stats->wtime_ended = MPI_Wtime();
+}
+
+static void mfu_daos_copy_stats_sum(mfu_daos_copy_stats_t* stats, mfu_daos_copy_stats_t* stats_sum)
+{
+    int num_values = 5;
+    /* put local values into buffer */
+    uint64_t values[num_values];
+    values[0] = stats->total_oids;
+    values[1] = stats->total_dkeys;
+    values[2] = stats->total_akeys;
+    values[3] = stats->bytes_read;
+    values[4] = stats->bytes_written;
+
+    /* sum the values */
+    MPI_Allreduce(MPI_IN_PLACE, values, num_values, MPI_UINT64_T, MPI_SUM, MPI_COMM_WORLD);
+
+    /* store summed values */
+    stats_sum->total_oids = values[0];
+    stats_sum->total_dkeys = values[1];
+    stats_sum->total_akeys = values[2];
+    stats_sum->bytes_read = values[3];
+    stats_sum->bytes_written = values[4];
+
+    /* copy times */
+    stats_sum->time_started = stats->time_started;
+    stats_sum->time_ended = stats->time_ended;
+    stats_sum->wtime_started = stats->wtime_started;
+    stats_sum->wtime_ended = stats->wtime_ended;
+}
+
+static void mfu_daos_copy_stats_print(mfu_daos_copy_stats_t* stats)
+{
+    /* format start time */
+    char starttime_str[256];
+    struct tm* localstart = localtime(&stats->time_started);
+    strftime(starttime_str, 256, "%b-%d-%Y,%H:%M:%S", localstart);
+
+    /* format end time */
+    char endtime_str[256];
+    struct tm* localend = localtime(&stats->time_ended);
+    strftime(endtime_str, 256, "%b-%d-%Y,%H:%M:%S", localend);
+
+    /* compute relative time elapsed */
+    double rel_time = stats->wtime_ended - stats->wtime_started;
+
+    /* convert read size to units */
+    double read_size_tmp;
+    const char* read_size_units;
+    mfu_format_bytes(stats->bytes_read, &read_size_tmp, &read_size_units);
+
+    /* compute read rate */
+    double read_rate = 0;
+    if (stats->bytes_read > 0) {
+        read_rate = (double) stats->bytes_read / rel_time;
+    }
+
+    /* convert read rate to units */
+    double read_rate_tmp;
+    const char* read_rate_units;
+    mfu_format_bw(read_rate, &read_rate_tmp, &read_rate_units);
+
+    /* convert write size to units */
+    double write_size_tmp;
+    const char* write_size_units;
+    mfu_format_bytes(stats->bytes_written, &write_size_tmp, &write_size_units);
+
+    /* compute write rate */
+    double write_rate = 0;
+    if (stats->bytes_written > 0) {
+        write_rate = (double) stats->bytes_written / rel_time;
+    }
+
+    /* convert write rate to units */
+    double write_rate_tmp;
+    const char* write_rate_units;
+    mfu_format_bw(write_rate, &write_rate_tmp, &write_rate_units);
+
+    MFU_LOG(MFU_LOG_INFO, "Started    : %s", starttime_str);
+    MFU_LOG(MFU_LOG_INFO, "Completed  : %s", endtime_str);
+    MFU_LOG(MFU_LOG_INFO, "Seconds    : %.3lf", rel_time);
+    MFU_LOG(MFU_LOG_INFO, "Objects    : %" PRId64, stats->total_oids);
+    MFU_LOG(MFU_LOG_INFO, "  D-Keys   : %" PRId64, stats->total_dkeys);
+    MFU_LOG(MFU_LOG_INFO, "  A-Keys   : %" PRId64, stats->total_akeys);
+
+    MFU_LOG(MFU_LOG_INFO, "Bytes read    : %.3lf %s (%" PRId64 " bytes)",
+            read_size_tmp, read_size_units, stats->bytes_read);
+    MFU_LOG(MFU_LOG_INFO, "Bytes written : %.3lf %s (%" PRId64 " bytes)",
+            write_size_tmp, write_size_units, stats->bytes_written);
+    MFU_LOG(MFU_LOG_INFO, "Read rate  : %.3lf %s",
+            read_rate_tmp, read_rate_units);
+    MFU_LOG(MFU_LOG_INFO, "Write rate : %.3lf %s",
+            write_rate_tmp, write_rate_units);
+}
+
 static bool daos_uuid_valid(const uuid_t uuid)
 {
     return uuid && !uuid_is_null(uuid);
@@ -58,14 +193,8 @@ static int daos_check_args(
     
     /* Determine whether the source and destination
      * use the same pool and container */
-    bool same_pool = false;
-    bool same_cont = false;
-    if (uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
-        same_pool = true;
-        if (uuid_compare(da->src_cont_uuid, da->dst_cont_uuid) == 0) {
-            same_cont = true;
-        }
-    }
+    bool same_pool = (uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0);
+    bool same_cont = same_pool && (uuid_compare(da->src_cont_uuid, da->dst_cont_uuid) == 0);
 
     /* Determine whether the source and destination paths are the same.
      * Assume NULL == NULL. */
@@ -129,15 +258,17 @@ static bool daos_check_prefix(
  * Returns 1 if a daos path was not parsed.
  * Returns -1 for actual errors.
  */
-static int daos_parse_path(
+int daos_parse_path(
     char* path,
     size_t path_len,
     uuid_t* p_uuid,
-    uuid_t* c_uuid)
+    uuid_t* c_uuid,
+    bool daos_no_prefix)
 {
     struct duns_attr_t  dattr = {0};
     int                 rc;
 
+    dattr.da_no_prefix = daos_no_prefix;
     rc = duns_resolve_path(path, &dattr);
     if (rc == 0) {
         /* daos:// or UNS path */
@@ -148,7 +279,7 @@ static int daos_parse_path(
         } else {
             strncpy(path, dattr.da_rel_path, path_len);
         }
-    } else if (strncmp(path, "daos:", 5) == 0) {
+    } else if (strncmp(path, "daos:", 5) == 0 || daos_no_prefix == false) {
         /* Actual error, since we expect a daos path */
         rc = -1;
     } else {
@@ -172,6 +303,7 @@ static int daos_set_paths(
     int     rc = 0;
     bool    prefix_on_src = false;
     bool    prefix_on_dst = false;
+    bool    daos_no_prefix = false;
 
     /* find out if a dfs_prefix is being used,
      * if so, then that means that the container
@@ -194,7 +326,9 @@ static int daos_set_paths(
         uuid_clear(prefix_c_uuid);
 
         /* Get the pool/container uuids from the prefix */
-        prefix_rc = daos_parse_path(prefix_path, prefix_len, &prefix_p_uuid, &prefix_c_uuid);
+        prefix_rc = daos_parse_path(prefix_path, prefix_len,
+                                    &prefix_p_uuid, &prefix_c_uuid,
+                                    daos_no_prefix);
         if (prefix_rc != 0 || prefix_p_uuid == NULL || prefix_c_uuid == NULL) {
             MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS Prefix UNS path");
             mfu_free(&prefix_path);
@@ -247,7 +381,9 @@ static int daos_set_paths(
             rc = 1;
             goto out;
         }
-        int src_rc = daos_parse_path(src_path, src_len, &da->src_pool_uuid, &da->src_cont_uuid);
+        int src_rc = daos_parse_path(src_path, src_len,
+                                     &da->src_pool_uuid, &da->src_cont_uuid,
+                                     daos_no_prefix);
         if (src_rc == 0) {
             argpaths[0] = da->src_path = strdup(src_path);
             mfu_free(&src_path);
@@ -262,14 +398,55 @@ static int daos_set_paths(
     if (!prefix_on_dst) {
         size_t dst_len = strlen(argpaths[1]);
         char* dst_path = strndup(argpaths[1], dst_len);
-        int dst_rc = daos_parse_path(dst_path, dst_len, &da->dst_pool_uuid, &da->dst_cont_uuid);
+        int dst_rc = daos_parse_path(dst_path, dst_len,
+                                     &da->dst_pool_uuid, &da->dst_cont_uuid,
+                                     daos_no_prefix);
         if (dst_rc == 0) {
             argpaths[1] = da->dst_path = strdup(dst_path);
             mfu_free(&dst_path);
         } else if (dst_rc == -1) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS destination path: daos://<pool>/<cont>[/<path>]");
+            /* The destination has a daos: prefix, so try to parse just the pool uuid. */
+            char* saveptr;
+            char* t = strtok_r(dst_path, "/", &saveptr);
+            if (t == NULL) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS destination path: daos://<pool>/<cont>[/<path>]");
+                rc = 1;
+                goto dst_out;
+            }
+            /* Skip over the daos: prefix */
+            t = strtok_r(NULL, "/", &saveptr);
+            if (t == NULL) {
+                /* No pool provided, so use the source pool uuid */
+                if (!daos_uuid_valid(da->src_pool_uuid)) {
+                    MFU_LOG(MFU_LOG_ERR, "Destination pool and/or container expected.");
+                    rc = 1;
+                    goto dst_out;
+                }
+                uuid_copy(da->dst_pool_uuid, da->src_pool_uuid);
+            } else {
+                /* Make sure the provided pool uuid is valid */
+                dst_rc = uuid_parse(t, da->dst_pool_uuid);
+                if (dst_rc != 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Failed to parse destination pool UUID");
+                    rc = 1;
+                    goto dst_out;
+                }
+            }
+            /* The pool uuid should have been last */
+            t = strtok_r(NULL, "/", &saveptr);
+            if (t != NULL) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS destination path: daos://<pool>/<cont>[/<path>]");
+                rc = 1;
+                goto dst_out;
+            }
+            /* Generate a new container uuid */
+            uuid_generate(da->dst_cont_uuid);
+            argpaths[1] = da->dst_path = strndup("/", 1);
+
+            rc = 0;
+
+dst_out:
             mfu_free(&dst_path);
-            rc = 1;
             goto out;
         }
     }
@@ -311,7 +488,7 @@ static int daos_get_cont_type(
  */
 static int daos_set_api_cont_type(
     mfu_file_t* mfu_file,
-    daos_handle_t coh,
+    enum daos_cont_props cont_type,
     daos_api_t api)
 {
     /* If explicitly using DAOS, just set the type to DAOS */
@@ -320,15 +497,6 @@ static int daos_set_api_cont_type(
         return 0;
     }
 
-    /* Otherwise, query the container type, and use DFS for POSIX containers. */
-    enum daos_cont_props cont_type;
-
-    int rc = daos_get_cont_type(coh, &cont_type);
-    if (rc) {
-        MFU_LOG(MFU_LOG_ERR, "Failed to get DAOS container type.");
-        return rc;
-    }
-
     if (cont_type == DAOS_PROP_CO_LAYOUT_POSIX) {
         mfu_file->type = DFS;
     } else {
@@ -348,7 +516,7 @@ static int daos_set_api_cont_type(
  * Set the mfu_file types to either DAOS or DFS,
  * and make sure they are compatible.
  */
-static int daos_set_api(
+static int daos_set_api_compat(
     mfu_file_t* mfu_src_file,
     mfu_file_t* mfu_dst_file,
     daos_args_t* da,
@@ -362,20 +530,11 @@ static int daos_set_api(
 
     int rc;
 
-    /* If the user explicitly wants to use the DAOS API,
-     * then set both types to DAOS.
-     * Otherwise, query the container type and set to DFS
-     * for POSIX containers. */
-    if (have_src_pool && have_src_cont) {
-        rc = daos_set_api_cont_type(mfu_src_file, da->src_coh, da->api);
-        if (rc) {
-            return rc;
-        }
-    }
-    if (have_dst_pool && have_dst_cont) {
-        rc = daos_set_api_cont_type(mfu_dst_file, da->dst_coh, da->api);
-        if (rc) {
-            return rc;
+    /* Containers must be the same type */
+    if (have_src_cont && have_dst_cont) {
+        if (da->src_cont_type != da->dst_cont_type) {
+            MFU_LOG(MFU_LOG_ERR, "Containers must be the same type.");
+            return 1;
         }
     }
 
@@ -439,7 +598,7 @@ static int daos_any_error(int rank, bool local_daos_error, int flag_daos_args)
 }
 
 /* Distribute process 0's pool or container handle to others. */
-static void daos_bcast_handle(
+void daos_bcast_handle(
   int rank,              /* root rank for broadcast */
   daos_handle_t* handle, /* handle value to be broadcasted */
   daos_handle_t* poh,    /* daos pool for global2local conversion of container handle */
@@ -503,15 +662,25 @@ static void daos_bcast_handle(
 }
 
 /* connect to DAOS pool, and then open container */
-static int daos_connect(
+int daos_connect(
   int rank,
+  daos_args_t* da,
   uuid_t pool_uuid,
   uuid_t cont_uuid,
   daos_handle_t* poh,
   daos_handle_t* coh,
   bool connect_pool,
-  bool create_cont)
+  bool create_cont,
+  bool require_new_cont)
 {
+    /* sanity check */
+    if (require_new_cont && !create_cont) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "create_cont must be true when require_new_cont is true");
+        }
+        return -1;
+    }
+
     /* assume failure until otherwise */
     int valid = 0;
     int rc;
@@ -540,29 +709,44 @@ static int daos_connect(
         daos_cont_info_t co_info = {0};
         rc = daos_cont_open(*poh, cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
         if (rc != 0) {
-            if (!create_cont) {
-                MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
+            if (rc != -DER_NONEXIST || !create_cont) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to open container "DF_RC, DP_RC(rc));
                 goto bcast;
             }
 
-            rc = dfs_cont_create(*poh, cont_uuid, NULL, NULL, NULL);
+            /* Create a new container. */
+            /* TODO copy container properties */
+            /* TODO copy user attributes */
+            if (da->src_cont_type == DAOS_PROP_CO_LAYOUT_POSIX) {
+                //dfs_attr_t attr; /* TODO set and pass this */
+                rc = dfs_cont_create(*poh, cont_uuid, NULL, NULL, NULL);
+            } else {
+                rc = daos_cont_create(*poh, cont_uuid, NULL, NULL);
+            }
             if (rc != 0) {
-                MFU_LOG(MFU_LOG_ERR, "Failed to create DFS container");
+                MFU_LOG(MFU_LOG_ERR, "Failed to create container");
                 goto bcast;
             }
 
+            char uuid_str[130];
+            uuid_unparse_lower(cont_uuid, uuid_str);
+            MFU_LOG(MFU_LOG_INFO, "Successfully created container %s", uuid_str);
+
             /* try to open it again */
             rc = daos_cont_open(*poh, cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
             if (rc != 0) {
-                MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
+                MFU_LOG(MFU_LOG_ERR, "Failed to open container");
                 goto bcast;
             }
+        } else if (require_new_cont) {
+            /* We successfully opened the container, but it should not exist */
+            MFU_LOG(MFU_LOG_ERR, "Destination container already exists");
+            goto bcast;
         }
 
         /* everything looks good so far */
         valid = 1;
     }
-
 bcast:
     /* broadcast valid from rank 0 */
     MPI_Bcast(&valid, 1, MPI_INT, 0, MPI_COMM_WORLD);
@@ -580,12 +764,11 @@ bcast:
 
     /* broadcast container handle from rank 0 */
     daos_bcast_handle(rank, coh, poh, CONT_HANDLE);
-
     return 0;
 }
 
 /* Mount DAOS dfs */
-static int daos_mount(
+static int mfu_dfs_mount(
   mfu_file_t* mfu_file,
   daos_handle_t* poh,
   daos_handle_t* coh)
@@ -603,7 +786,7 @@ static int daos_mount(
 
 /* Unmount DAOS dfs.
  * Cleanup up hash */
-static int daos_umount(
+static int mfu_dfs_umount(
   mfu_file_t* mfu_file)
 {
     /* Unmount dfs */
@@ -612,10 +795,27 @@ static int daos_umount(
         MFU_LOG(MFU_LOG_ERR, "Failed to unmount DFS namespace");
         rc = -1;
     }
+    mfu_file->dfs = NULL;
 
     /* Clean up the hash */
     if (mfu_file->dfs_hash != NULL) {
         d_hash_table_destroy(mfu_file->dfs_hash, true);
+        mfu_file->dfs_hash = NULL;
+    }
+
+    return rc;
+}
+
+static inline int mfu_daos_destroy_snap(daos_handle_t coh, daos_epoch_t epoch)
+{
+    daos_epoch_range_t epr;
+    epr.epr_lo = epoch;
+    epr.epr_hi = epoch;
+
+    int rc = daos_cont_destroy_snap(coh, epr, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "DAOS destroy snapshot failed: ", MFU_ERRF,
+                MFU_ERRP(-MFU_ERR_DAOS));
     }
 
     return rc;
@@ -646,7 +846,15 @@ daos_args_t* daos_args_new(void)
     /* By default, try to automatically determine the API */
     da->api = DAOS_API_AUTO;
 
-    da->epc = 0;
+    /* Default to 0 for "no epoch" */
+    da->src_epc = 0;
+    da->dst_epc = 0;
+
+    /* Default does not allow the destination container to exist for DAOS API */
+    da->allow_exist_dst_cont = false;
+
+    da->src_cont_type = DAOS_PROP_CO_LAYOUT_UNKOWN;
+    da->dst_cont_type = DAOS_PROP_CO_LAYOUT_UNKOWN;
 
     return da;
 }
@@ -757,6 +965,9 @@ int daos_setup(
         return 1;
     }
 
+    /* At this point, we don't have any errors */
+    local_daos_error = false;
+
     /* Check whether we have pool/cont uuids */
     bool have_src_pool  = daos_uuid_valid(da->src_pool_uuid);
     bool have_src_cont  = daos_uuid_valid(da->src_cont_uuid);
@@ -766,67 +977,139 @@ int daos_setup(
     /* Check if containers are in the same pool */
     bool same_pool = (uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0);
 
+    bool connect_pool = true;
+    bool create_cont = false;
+    bool require_new_cont = false;
+
     /* connect to DAOS source pool if uuid is valid */
-    if (!local_daos_error && have_src_pool && have_src_cont) {
-        /* Open pool connection, but do not create container if non-existent */
-        tmp_rc = daos_connect(rank, da->src_pool_uuid,
-                da->src_cont_uuid, &da->src_poh, &da->src_coh, true, false);
+    if (have_src_cont) {
+        /* Sanity check */
+        if (!have_src_pool) {
+            if (rank == 0) {
+                MFU_LOG(MFU_LOG_ERR, "Source container requires source pool");
+            }
+            local_daos_error = true;
+            goto out;
+        }
+        tmp_rc = daos_connect(rank, da, da->src_pool_uuid, da->src_cont_uuid,
+                              &da->src_poh, &da->src_coh,
+                              connect_pool, create_cont, require_new_cont);
         if (tmp_rc != 0) {
             /* tmp_rc from daos_connect is collective */
             local_daos_error = true;
+            goto out;
+        }
+        /* Get the container type */
+        tmp_rc = daos_get_cont_type(da->src_coh, &da->src_cont_type);
+        if (tmp_rc != 0) {
+            /* ideally, this should be the same for each process */
+            local_daos_error = true;
+            goto out;
+        }
+        /* Set the src api based on the container type */
+        tmp_rc = daos_set_api_cont_type(mfu_src_file, da->src_cont_type, da->api);
+        if (tmp_rc != 0) {
+            local_daos_error = true;
+            goto out;
         }
+        /* Sanity check before we create a new container */
+        if (da->src_cont_type != DAOS_PROP_CO_LAYOUT_POSIX) {
+            if (strcmp(da->src_path, "/") != 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Cannot use path with non-POSIX container.");
+                }
+                local_daos_error = true;
+                goto out;
+            }
+        }
+    }
+
+    /* If we're using the DAOS API, the destination container cannot
+     * exist already, unless overriden by allow_exist_dst_cont. */
+    if (mfu_src_file->type != POSIX && mfu_src_file->type != DFS && !da->allow_exist_dst_cont) {
+        require_new_cont = true;
     }
 
     /* If the source and destination are in the same pool,
      * then open the container in that pool.
      * Otherwise, connect to the second pool and open the container */
-    if (!local_daos_error && have_dst_pool && have_dst_cont) {
+    if (have_dst_pool) {
+        /* Sanity check before we create a new container */
+        if (require_new_cont && da->api == DAOS_API_DAOS) {
+            if (strcmp(da->dst_path, "/") != 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Cannot use path with non-POSIX container.");
+                }
+                local_daos_error = true;
+                goto out;
+            }
+        }
+
+        create_cont = true;
         if (same_pool) {
-            /* Don't reconnect to pool, but do create container if non-existent */
-            tmp_rc = daos_connect(rank, da->dst_pool_uuid,
-                    da->dst_cont_uuid, &da->src_poh, &da->dst_coh, false, true);
+            connect_pool = false;
+            tmp_rc = daos_connect(rank, da, da->dst_pool_uuid, da->dst_cont_uuid,
+                                  &da->src_poh, &da->dst_coh,
+                                  connect_pool, create_cont, require_new_cont);
         } else {
-            /* Open pool connection, and create container if non-existent */
-            tmp_rc = daos_connect(rank, da->dst_pool_uuid,
-                    da->dst_cont_uuid, &da->dst_poh, &da->dst_coh, true, true);
+            connect_pool = true;
+            tmp_rc = daos_connect(rank, da, da->dst_pool_uuid, da->dst_cont_uuid,
+                                  &da->dst_poh, &da->dst_coh,
+                                  connect_pool, create_cont, require_new_cont);
         }
         if (tmp_rc != 0) {
             /* tmp_rc from daos_connect is collective */
             local_daos_error = true;
+            goto out;
         }
-    }
-
-    /* Figure out if we should use the DFS or DAOS API */
-    if (!local_daos_error) {
-        tmp_rc = daos_set_api(mfu_src_file, mfu_dst_file, da, argpaths);
+        /* Get the container type */
+        tmp_rc = daos_get_cont_type(da->dst_coh, &da->dst_cont_type);
+        if (tmp_rc != 0) {
+            /* ideally, this should be the same for each process */
+            local_daos_error = true;
+            goto out;
+        }
+        /* Set the dst api based on the container type */
+        tmp_rc = daos_set_api_cont_type(mfu_dst_file, da->dst_cont_type, da->api);
         if (tmp_rc != 0) {
             local_daos_error = true;
+            goto out;
         }
     }
 
+    /* Figure out if we should use the DFS or DAOS API */
+    tmp_rc = daos_set_api_compat(mfu_src_file, mfu_dst_file, da, argpaths);
+    if (tmp_rc != 0) {
+        local_daos_error = true;
+        goto out;
+    }
+
     /* Mount source DFS container */
-    if (!local_daos_error && mfu_src_file->type == DFS) {
-        tmp_rc = daos_mount(mfu_src_file, &da->src_poh, &da->src_coh);
+    if (mfu_src_file->type == DFS) {
+        tmp_rc = mfu_dfs_mount(mfu_src_file, &da->src_poh, &da->src_coh);
         if (tmp_rc != 0) {
             local_daos_error = true;
+            goto out;
         }
     }
 
     /* Mount destination DFS container */
-    if (!local_daos_error && mfu_dst_file->type == DFS) {
+    if (mfu_dst_file->type == DFS) {
         if (same_pool) {
-            tmp_rc = daos_mount(mfu_dst_file, &da->src_poh, &da->dst_coh);
+            tmp_rc = mfu_dfs_mount(mfu_dst_file, &da->src_poh, &da->dst_coh);
         } else {
-            tmp_rc = daos_mount(mfu_dst_file, &da->dst_poh, &da->dst_coh);
+            tmp_rc = mfu_dfs_mount(mfu_dst_file, &da->dst_poh, &da->dst_coh);
         }
         if (tmp_rc != 0) {
             local_daos_error = true;
+            goto out;
         }
     }
 
+out:
+
     /* Return if any process had a daos error */
     if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
-        tmp_rc = daos_fini();
         return 1;
     }
 
@@ -843,15 +1126,34 @@ int daos_cleanup(
     int rc = 0;
     int tmp_rc;
 
-    bool same_pool = false;
-    if (daos_uuid_valid(da->src_pool_uuid) && daos_uuid_valid(da->dst_pool_uuid)
-            && uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
-        same_pool = true;
+    /* get our rank */
+    int rank;
+    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
+
+    bool same_pool = (uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0);
+
+    /* Destroy source snapshot */
+    if (rank == 0 && da->src_epc != 0) {
+        tmp_rc = mfu_daos_destroy_snap(da->src_coh, da->src_epc);
+        if (tmp_rc != 0) {
+            rc = 1;
+        }
+    }
+
+    /* Destroy destination snapshot */
+    if (rank == 0 && da->dst_epc != 0) {
+        tmp_rc = mfu_daos_destroy_snap(da->dst_coh, da->dst_epc);
+        if (tmp_rc != 0) {
+            rc = 1;
+        }
     }
 
+    /* Don't close containers until snapshots are destroyed */
+    MPI_Barrier(MPI_COMM_WORLD);
+
     /* Unmount source DFS container */
-    if (mfu_src_file->type == DFS) {
-        tmp_rc = daos_umount(mfu_src_file);
+    if (mfu_src_file->dfs != NULL) {
+        tmp_rc = mfu_dfs_umount(mfu_src_file);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
             rc = 1;
@@ -859,18 +1161,19 @@ int daos_cleanup(
     }
 
     /* Close source container */
-    if (mfu_src_file->type == DFS || mfu_src_file->type == DAOS) {
+    if (daos_handle_is_valid(da->src_coh)) {
         tmp_rc = daos_cont_close(da->src_coh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+            MFU_LOG(MFU_LOG_ERR, "Failed to close source container "DF_RC, DP_RC(tmp_rc));
             rc = 1;
         }
+        da->src_coh = DAOS_HDL_INVAL;
     }
 
     /* Unmount destination DFS container */
-    if (mfu_dst_file->type == DFS) {
-        tmp_rc = daos_umount(mfu_dst_file);
+    if (mfu_dst_file->dfs != NULL) {
+        tmp_rc = mfu_dfs_umount(mfu_dst_file);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
             rc = 1;
@@ -878,33 +1181,36 @@ int daos_cleanup(
     }
 
     /* Close destination container */
-    if (mfu_dst_file->type == DFS || mfu_dst_file->type == DAOS) {
+    if (daos_handle_is_valid(da->dst_coh)) {
         tmp_rc = daos_cont_close(da->dst_coh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+            MFU_LOG(MFU_LOG_ERR, "Failed to close destination container "DF_RC, DP_RC(tmp_rc));
             rc = 1;
         }
+        da->dst_coh = DAOS_HDL_INVAL;
     }
 
     /* Close source pool */
-    if (mfu_src_file->type == DFS || mfu_src_file->type == DAOS) {
+    if (daos_handle_is_valid(da->src_poh)) {
         tmp_rc = daos_pool_disconnect(da->src_poh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from source pool");
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from source pool "DF_RC, DP_RC(tmp_rc));
             rc = 1;
         }
+        da->src_poh = DAOS_HDL_INVAL;
     }
 
     /* Close destination pool */
-    if ((mfu_dst_file->type == DFS || mfu_dst_file->type == DAOS) && !same_pool) {
+    if (daos_handle_is_valid(da->dst_poh) && !same_pool) {
         tmp_rc = daos_pool_disconnect(da->dst_poh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool");
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool "DF_RC, DP_RC(tmp_rc));
             rc = 1;
         }
+        da->dst_poh = DAOS_HDL_INVAL;
     }
 
     /* Finalize DAOS */
@@ -919,118 +1225,301 @@ int daos_cleanup(
     return rc;
 }
 
-static int daos_copy_recx_single(daos_key_t *dkey,
-                            daos_handle_t *src_oh,
-                            daos_handle_t *dst_oh,
-                            daos_iod_t *iod)
+/* Copy a single recx from a src obj to dst obj for a given dkey/akey.
+ * returns -1 on error, 0 if same, 1 if different. */
+static int mfu_daos_obj_sync_recx_single(
+    daos_key_t *dkey,
+    daos_handle_t *src_oh,
+    daos_handle_t *dst_oh,
+    daos_iod_t *iod,
+    bool compare_dst,
+    bool write_dst,
+    mfu_daos_copy_stats_t* stats)
 {
-    /* if iod_type is single value just fetch iod size from source
-     * and update in destination object */
-    int buf_len = (int)(*iod).iod_size;
-    char buf[buf_len];
-    d_sg_list_t sgl;
-    d_iov_t iov;
-    int rc;
-
-    /* set sgl values */
-    sgl.sg_nr     = 1;
-    sgl.sg_nr_out = 0;
-    sgl.sg_iovs   = &iov;
-    d_iov_set(&iov, buf, buf_len);
-    rc = daos_obj_fetch(*src_oh, DAOS_TX_NONE, 0, dkey, 1, iod, &sgl, NULL, NULL);
+    bool        dst_equal = false;  /* equal until found otherwise */
+    uint64_t    src_buf_len = (*iod).iod_size;
+    char        src_buf[src_buf_len];
+    d_sg_list_t src_sgl;
+    d_iov_t     src_iov;
+    int         rc;
+
+    /* set src_sgl values */
+    src_sgl.sg_nr     = 1;
+    src_sgl.sg_nr_out = 0;
+    src_sgl.sg_iovs   = &src_iov;
+    d_iov_set(&src_iov, src_buf, src_buf_len);
+
+    /* Fetch the source */
+    rc = daos_obj_fetch(*src_oh, DAOS_TX_NONE, 0, dkey, 1, iod, &src_sgl, NULL, NULL);
     if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "DAOS object fetch returned with errors: ", MFU_ERRF,
-	        MFU_ERRP(-MFU_ERR_DAOS));
-        return 1;
+        MFU_LOG(MFU_LOG_ERR, "DAOS object fetch returned with errors "DF_RC, DP_RC(rc));
+        goto out_err;
     }
-    rc = daos_obj_update(*dst_oh, DAOS_TX_NONE, 0, dkey, 1, iod, &sgl, NULL);
-    if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "DAOS object update returned with errors: ", MFU_ERRF,
-	        MFU_ERRP(-MFU_ERR_DAOS));
-        return 1;
+    stats->bytes_read += src_buf_len;
+
+    /* Sanity check */
+    if (src_sgl.sg_nr_out != 1) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to fetch single recx.");
+        goto out_err;
     }
-    return rc;
+
+    /* Conditionally compare the destination before writing */
+    if (compare_dst) {
+        uint64_t    dst_buf_len = (*iod).iod_size;
+        char        dst_buf[dst_buf_len];
+        d_sg_list_t dst_sgl;
+        d_iov_t     dst_iov;
+
+        dst_sgl.sg_nr       = 1;
+        dst_sgl.sg_nr_out   = 0;
+        dst_sgl.sg_iovs     = &dst_iov;
+
+        d_iov_set(&dst_iov, dst_buf, dst_buf_len);
+        rc = daos_obj_fetch(*dst_oh, DAOS_TX_NONE, 0, dkey, 1, iod, &dst_sgl, NULL, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "DAOS object fetch returned with errors "DF_RC, DP_RC(rc));
+            goto out_err;
+        }
+        /* Reset iod values after fetching the destination */
+        (*iod).iod_nr = 1;
+        (*iod).iod_size = src_buf_len;
+
+        /* Determine whether the dst is equal to the src */
+        if (dst_sgl.sg_nr_out > 0) {
+            stats->bytes_read += dst_buf_len;
+            dst_equal = (memcmp(src_buf, dst_buf, src_buf_len) == 0);
+        }
+    }
+
+    /* Conditionally write to the destination */
+    if (write_dst && !dst_equal) {
+        rc = daos_obj_update(*dst_oh, DAOS_TX_NONE, 0, dkey, 1, iod, &src_sgl, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "DAOS object update returned with errors "DF_RC, DP_RC(rc));
+            goto out_err;
+        }
+        stats->bytes_written += src_buf_len;
+    }
+
+    /* return 0 if equal, 1 if different */
+    if (dst_equal) {
+        return 0;
+    }
+    return 1;
+
+out_err:
+    /* return -1 on true error */
+    return -1;
+}
+
+/* Free a buffer created with alloc_iov_buf */
+static void free_iov_buf(
+    uint32_t    number, /* buffer length */
+    char**      buf)    /* pointer to static buffer */
+{
+    if (buf != NULL) {
+        for (uint32_t i = 0; i < number; i++) {
+            mfu_free(&buf[i]);
+        }
+    }
+}
+
+/* Create a buffer based on recxs and set iov for each index */
+static int alloc_iov_buf(
+    uint32_t        number, /* number of recxs, iovs, and buffer */
+    daos_size_t     size,   /* size of each record */
+    daos_recx_t*    recxs,  /* array of recxs */
+    d_iov_t*        iov,    /* array of iovs */
+    char**          buf,    /* pointer to static buffer */
+    uint64_t*       buf_len)/* pointer to static buffer lengths */
+{
+    for (uint32_t i = 0; i < number; i++) {
+        buf_len[i] = recxs[i].rx_nr * size;
+        buf[i] = calloc(buf_len[i], sizeof(void*));
+        if (buf[i] == NULL) {
+            free_iov_buf(number, buf);
+            return -1;
+        }
+        d_iov_set(&iov[i], buf[i], buf_len[i]);
+    }
+
+    return 0;
+}
+
+/* Sum an array of uint64_t */
+static uint64_t sum_uint64_t(uint32_t number, uint64_t* buf)
+{
+    uint64_t sum = 0;
+    for (uint32_t i = 0; i < number; i++) {
+        sum += buf[i];
+    }
+    return sum;
 }
 
-static int daos_copy_recx_array(daos_key_t *dkey,
-                           daos_key_t *akey,
-                           daos_handle_t *src_oh,
-                           daos_handle_t *dst_oh,
-                           daos_iod_t *iod)
+/* Copy all array recx from a src obj to dst obj for a given dkey/akey.
+ * returns -1 on error, 0 if same, 1 if different */
+static int mfu_daos_obj_sync_recx_array(
+    daos_key_t *dkey,
+    daos_key_t *akey,
+    daos_handle_t *src_oh,
+    daos_handle_t *dst_oh,
+    daos_iod_t *iod,
+    bool compare_dst,
+    bool write_dst,
+    mfu_daos_copy_stats_t* stats)
 {
-    daos_anchor_t recx_anchor = {0}; 
+    bool        all_dst_equal = true;   /* equal until found otherwise */
+    uint32_t    max_number = 5;         /* max recxs per fetch */
+    char*       src_buf[max_number];    /* src buffer data */
+    uint64_t    src_buf_len[max_number];/* src buffer lengths */
+    d_sg_list_t src_sgl;
+    daos_recx_t recxs[max_number];
+    daos_size_t size;
+    daos_epoch_range_t eprs[max_number];
+
+    daos_anchor_t recx_anchor = {0};
     int rc;
-    int i;
     while (!daos_anchor_is_eof(&recx_anchor)) {
-        daos_epoch_range_t	eprs[5];
-        daos_recx_t		recxs[5];
-        daos_size_t		size;
-
         /* list all recx for this dkey/akey */
-        uint32_t number = 5;
+        uint32_t number = max_number;
         rc = daos_obj_list_recx(*src_oh, DAOS_TX_NONE, dkey, akey,
-	                        &size, &number, recxs, eprs,
-				&recx_anchor, true, NULL);
+                                &size, &number, recxs, eprs,
+                                &recx_anchor, true, NULL);
         if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_list_recx returned with errors: ", MFU_ERRF,
-	            MFU_ERRP(-MFU_ERR_DAOS));
-            return 1;
+            MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_list_recx returned with errors "DF_RC, DP_RC(rc));
+            goto out_err;
         }
 
         /* if no recx is returned for this dkey/akey move on */
         if (number == 0) 
             continue;
 
-        for (i = 0; i < number; i++) {
-            uint64_t    buf_len = recxs[i].rx_nr;
-            char        buf[buf_len];
-            d_sg_list_t sgl;
-            d_iov_t     iov;
+        d_iov_t src_iov[number];
 
-            /* set iod values */
-            (*iod).iod_type  = DAOS_IOD_ARRAY;
-            (*iod).iod_size  = 1;
-            (*iod).iod_nr    = 1;
-            (*iod).iod_recxs = &recxs[i];
+        /* set iod values */
+        (*iod).iod_type  = DAOS_IOD_ARRAY;
+        (*iod).iod_nr    = number;
+        (*iod).iod_recxs = recxs;
+        (*iod).iod_size  = size;
 
-            /* set sgl values */
-            sgl.sg_nr     = 1;
-            sgl.sg_nr_out = 0;
-            sgl.sg_iovs   = &iov;
+        /* set src_sgl values */
+        src_sgl.sg_nr_out = 0;
+        src_sgl.sg_iovs   = src_iov;
+        src_sgl.sg_nr     = number;
 
-            /* fetch recx values from source */
-            d_iov_set(&iov, buf, buf_len);	
-            rc = daos_obj_fetch(*src_oh, DAOS_TX_NONE, 0, dkey, 1, iod,
-                                &sgl, NULL, NULL);
+        /* allocate and setup src_buf */
+        if (alloc_iov_buf(number, size, recxs, src_iov, src_buf, src_buf_len) != 0) {
+            MFU_LOG(MFU_LOG_ERR, "DAOS failed to allocate source buffer.");
+            goto out_err;
+        }
+
+        bool recx_equal = false;
+        uint64_t total_bytes = sum_uint64_t(number, src_buf_len);
+
+        /* fetch recx values from source */
+        rc = daos_obj_fetch(*src_oh, DAOS_TX_NONE, 0, dkey, 1, iod,
+                            &src_sgl, NULL, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "DAOS object fetch returned with errors "DF_RC, DP_RC(rc));
+            goto out_err;
+        }
+
+        /* Sanity check */
+        if (src_sgl.sg_nr_out != number) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to fetch array recxs.");
+            goto out_err;
+        }
+
+        stats->bytes_read += total_bytes;
+
+        /* Conditionally compare the destination before writing */
+        if (compare_dst) {
+            char*       dst_buf[number];
+            uint64_t    dst_buf_len[number];
+            d_sg_list_t dst_sgl;
+            d_iov_t     dst_iov[number];
+
+            dst_sgl.sg_nr_out = 0;
+            dst_sgl.sg_iovs   = dst_iov;
+            dst_sgl.sg_nr     = number;
+
+            /* allocate and setup dst_buf */
+            if (alloc_iov_buf(number, size, recxs, dst_iov, dst_buf, dst_buf_len) != 0) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS failed to allocate destination buffer.");
+                goto out_err;
+            }
+
+            rc = daos_obj_fetch(*dst_oh, DAOS_TX_NONE, 0, dkey, 1, iod,
+                                &dst_sgl, NULL, NULL);
             if (rc != 0) {
-                MFU_LOG(MFU_LOG_ERR, "DAOS object fetch returned with errors: ", MFU_ERRF,
-	                MFU_ERRP(-MFU_ERR_DAOS));
-                return 1;
+                MFU_LOG(MFU_LOG_ERR, "DAOS object fetch returned with errors "DF_RC, DP_RC(rc));
+                free_iov_buf(number, dst_buf);
+                goto out_err;
+            }
+
+            /* Reset iod values after fetching the destination */
+            (*iod).iod_nr    = number;
+            (*iod).iod_size  = size;
+
+            /* Determine whether all recxs in the dst are equal to the src.
+             * If any recx is different, update all recxs in dst and flag
+             * this akey as different. */
+            if (dst_sgl.sg_nr_out > 0) {
+                stats->bytes_read += total_bytes;
+                recx_equal = true;
+                for (uint32_t i = 0; i < number; i++) {
+                    if (memcmp(src_buf[i], dst_buf[i], src_buf_len[i]) != 0) {
+                        recx_equal = false;
+                        all_dst_equal = false;
+                        break;
+                    }
+                }
             }
+            free_iov_buf(number, dst_buf);
+        }
 
-            /* update fetched recx values and place in destination object */
+        /* Conditionally write to the destination */
+        if (write_dst && !recx_equal) {
             rc = daos_obj_update(*dst_oh, DAOS_TX_NONE, 0, dkey, 1, iod,
-                                 &sgl, NULL);
+                                 &src_sgl, NULL);
             if (rc != 0) {
-                MFU_LOG(MFU_LOG_ERR, "DAOS object update returned with errors: ", MFU_ERRF,
-	                MFU_ERRP(-MFU_ERR_DAOS));
-                return 1;
+                MFU_LOG(MFU_LOG_ERR, "DAOS object update returned with errors "DF_RC, DP_RC(rc));
+                goto out_err;
             }
-	
+            stats->bytes_written += total_bytes;
         }
+        free_iov_buf(number, src_buf);
     }
-    return rc;
+
+    /* return 0 if equal, 1 if different */
+    if (all_dst_equal) {
+        return 0;
+    }
+    return 1;
+
+out_err:
+    /* return -1 on true errors */
+    return -1;
 }
 
-static int daos_copy_list_keys(daos_handle_t *src_oh,
-                          daos_handle_t *dst_oh)
+/* Copy all dkeys and akeys from a src obj to dst obj.
+ * returns -1 on error, 0 if same, 1 if different */
+static int mfu_daos_obj_sync_keys(
+  daos_handle_t* src_oh,
+  daos_handle_t* dst_oh,
+  bool compare_dst,
+  bool write_dst,
+  mfu_daos_copy_stats_t* stats)
 {
+    /* Assume src and dst are equal until found otherwise */
+    bool all_dst_equal = true;
+
     /* loop to enumerate dkeys */
     daos_anchor_t dkey_anchor = {0}; 
     int rc;
     while (!daos_anchor_is_eof(&dkey_anchor)) {
-        d_sg_list_t     dkey_sgl;
-        d_iov_t         dkey_iov;
+        d_sg_list_t     dkey_sgl = {0};
+        d_iov_t         dkey_iov = {0};
         daos_key_desc_t dkey_kds[ENUM_DESC_NR]       = {0};
         uint32_t        dkey_number                  = ENUM_DESC_NR;
         char            dkey_enum_buf[ENUM_DESC_BUF] = {0};
@@ -1046,9 +1535,8 @@ static int daos_copy_list_keys(daos_handle_t *src_oh,
         rc = daos_obj_list_dkey(*src_oh, DAOS_TX_NONE, &dkey_number, dkey_kds,
                                 &dkey_sgl, &dkey_anchor, NULL);
         if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_list_dkey returned with errors: ", MFU_ERRF,
-	            MFU_ERRP(-MFU_ERR_DAOS));
-            return 1;
+            MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_list_dkey returned with errors "DF_RC, DP_RC(rc));
+            goto out_err;
         }
 
         /* if no dkeys were returned move on */
@@ -1058,20 +1546,20 @@ static int daos_copy_list_keys(daos_handle_t *src_oh,
         char* dkey_ptr;
         int   i;
 
-        /* parse out individual dkeys based on key length and numver of dkeys returned */
+        /* parse out individual dkeys based on key length and number of dkeys returned */
         for (dkey_ptr = dkey_enum_buf, i = 0; i < dkey_number; i++) {
 
             /* Print enumerated dkeys */
             daos_key_t diov;
-            snprintf(dkey, dkey_kds[i].kd_key_len + 1, "%s", dkey_ptr);
+            memcpy(dkey, dkey_ptr, dkey_kds[i].kd_key_len);
             d_iov_set(&diov, (void*)dkey, dkey_kds[i].kd_key_len);
             dkey_ptr += dkey_kds[i].kd_key_len;
 
             /* loop to enumerate akeys */
             daos_anchor_t akey_anchor = {0}; 
             while (!daos_anchor_is_eof(&akey_anchor)) {
-                d_sg_list_t     akey_sgl;
-                d_iov_t         akey_iov;
+                d_sg_list_t     akey_sgl = {0};
+                d_iov_t         akey_iov = {0};
                 daos_key_desc_t akey_kds[ENUM_DESC_NR]       = {0};
                 uint32_t        akey_number                  = ENUM_DESC_NR;
                 char            akey_enum_buf[ENUM_DESC_BUF] = {0};
@@ -1087,9 +1575,8 @@ static int daos_copy_list_keys(daos_handle_t *src_oh,
                 rc = daos_obj_list_akey(*src_oh, DAOS_TX_NONE, &diov, &akey_number, akey_kds,
                                         &akey_sgl, &akey_anchor, NULL);
                 if (rc != 0) {
-                    MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_list_akey returned with errors: ", MFU_ERRF,
-	                    MFU_ERRP(-MFU_ERR_DAOS));
-                    return 1;
+                    MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_list_akey returned with errors "DF_RC, DP_RC(rc));
+                    goto out_err;
                 }
 
                 /* if no akeys returned move on */
@@ -1099,12 +1586,12 @@ static int daos_copy_list_keys(daos_handle_t *src_oh,
                 int j;
                 char* akey_ptr;
 
-                /* parse out individual akeys based on key length and numver of dkeys returned */
+                /* parse out individual akeys based on key length and number of dkeys returned */
                 for (akey_ptr = akey_enum_buf, j = 0; j < akey_number; j++) {
-                    daos_key_t aiov;
-                    daos_iod_t iod;
-                    daos_recx_t recx;
-                    snprintf(akey, akey_kds[j].kd_key_len + 1, "%s", akey_ptr);
+                    daos_key_t aiov = {0};
+                    daos_iod_t iod = {0};
+                    daos_recx_t recx = {0};
+                    memcpy(akey, akey_ptr, akey_kds[j].kd_key_len);
                     d_iov_set(&aiov, (void*)akey, akey_kds[j].kd_key_len);
 
                     /* set iod values */
@@ -1112,47 +1599,125 @@ static int daos_copy_list_keys(daos_handle_t *src_oh,
                     iod.iod_type  = DAOS_IOD_SINGLE;
                     iod.iod_size  = DAOS_REC_ANY;
                     iod.iod_recxs = NULL;
-
-                    d_iov_set(&iod.iod_name, (void*)akey, strlen(akey));
+                    iod.iod_name  = aiov;
 
                     /* Do a fetch (with NULL sgl) of single value type, and if that
                      * returns iod_size == 0, then a single value does not exist. */
                     rc = daos_obj_fetch(*src_oh, DAOS_TX_NONE, 0, &diov, 1, &iod, NULL, NULL, NULL);
                     if (rc != 0) {
-                        MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_fetch returned with errors: ", MFU_ERRF,
-	                        MFU_ERRP(-MFU_ERR_DAOS));
-                        return 1;
+                        MFU_LOG(MFU_LOG_ERR, "DAOS daos_obj_fetch returned with errors "DF_RC, DP_RC(rc));
+                        goto out_err;
                     }
 
                     /* if iod_size == 0 then this is a DAOS_IOD_ARRAY type */
                     if ((int)iod.iod_size == 0) {
-                        rc = daos_copy_recx_array(&diov, &aiov, src_oh, dst_oh, &iod);
-                        if (rc != 0) {
-                            MFU_LOG(MFU_LOG_ERR, "DAOS daos_copy_recx_array returned with errors: ", MFU_ERRF,
-	                            MFU_ERRP(-MFU_ERR_DAOS));
-                            return 1;
+                        rc = mfu_daos_obj_sync_recx_array(&diov, &aiov, src_oh, dst_oh,
+                                                          &iod, compare_dst, write_dst, stats);
+                        if (rc == -1) {
+                            MFU_LOG(MFU_LOG_ERR, "DAOS mfu_daos_obj_sync_recx_array returned with errors: ",
+                                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+                            goto out_err;
+                        } else if (rc == 1) {
+                            all_dst_equal = false;
                         }
                     } else {
-                        rc = daos_copy_recx_single(&diov, src_oh, dst_oh, &iod);
-                        if (rc != 0) {
-                            MFU_LOG(MFU_LOG_ERR, "DAOS daos_copy_recx_single returned with errors: ", MFU_ERRF,
-	                            MFU_ERRP(-MFU_ERR_DAOS));
-                            return 1;
+                        rc = mfu_daos_obj_sync_recx_single(&diov, src_oh, dst_oh,
+                                                           &iod, compare_dst, write_dst, stats);
+                        if (rc == -1) {
+                            MFU_LOG(MFU_LOG_ERR, "DAOS mfu_daos_obj_sync_recx_single returned with errors: ",
+                                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+                            goto out_err;
+                        } else if (rc == 1) {
+                            all_dst_equal = false;
                         }
                     }
 
+                    /* Increment akeys traversed */
+                    stats->total_akeys++;
+
                     /* advance to next akey returned */	
                     akey_ptr += akey_kds[j].kd_key_len;
                 }
             }
+
+            /* Increment dkeys traversed */
+            stats->total_dkeys++;
         }
     }
-    return rc;
+
+    /* return 0 if equal, 1 if different */
+    if (all_dst_equal) {
+        return 0;
+    }
+    return 1;
+
+out_err:
+    /* return -1 on true errors */
+    return -1;
 }
 
-static int daos_obj_copy(
+static int mfu_daos_obj_sync(
     daos_args_t* da,
-    mfu_flist bflist)
+    daos_handle_t src_coh,
+    daos_handle_t dst_coh,
+    daos_obj_id_t oid,
+    bool compare_dst,             /* Whether to compare the src and dst before writing */
+    bool write_dst,               /* Whether to write to the dst */
+    mfu_daos_copy_stats_t* stats)
+{
+    int rc = 0;
+
+    /* open handle of object in src container */
+    daos_handle_t src_oh;
+    rc = daos_obj_open(src_coh, oid, DAOS_OO_RO, &src_oh, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "DAOS object open returned with errors: ", MFU_ERRF,
+                MFU_ERRP(-MFU_ERR_DAOS));
+        goto out_err;
+    }
+
+    /* open handle of object in dst container */
+    daos_handle_t dst_oh;
+    rc = daos_obj_open(dst_coh, oid, DAOS_OO_EXCL, &dst_oh, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "DAOS object open returned with errors: ", MFU_ERRF,
+                MFU_ERRP(-MFU_ERR_DAOS));
+        /* make sure to close the source if opening dst fails */
+        daos_obj_close(src_oh, NULL);
+        goto out_err;
+    }
+    int copy_rc = mfu_daos_obj_sync_keys(&src_oh, &dst_oh, compare_dst, write_dst, stats);
+    if (copy_rc == -1) {
+        MFU_LOG(MFU_LOG_ERR, "DAOS copy list keys returned with errors: ", MFU_ERRF,
+                MFU_ERRP(-MFU_ERR_DAOS));
+        /* cleanup object handles on failure */
+        daos_obj_close(src_oh, NULL);
+        daos_obj_close(dst_oh, NULL);
+        goto out_err;
+    }
+
+    stats->total_oids++;
+
+    /* close source and destination object */
+    daos_obj_close(src_oh, NULL);
+    daos_obj_close(dst_oh, NULL);
+
+    return copy_rc;
+
+out_err:
+    /* return -1 on true error */
+    return -1;
+}
+
+/* returns -1 on error, 0 if same, 1 if different */
+static int mfu_daos_flist_obj_sync(
+  daos_args_t* da,
+  mfu_flist bflist,
+  daos_handle_t src_coh,
+  daos_handle_t dst_coh,
+  bool compare_dst,
+  bool write_dst,
+  mfu_daos_copy_stats_t* stats)
 {
     int rc = 0;
 
@@ -1161,75 +1726,46 @@ static int daos_obj_copy(
     uint64_t i;
     const elem_t* p = flist->list_head;
     for (i = 0; i < flist->list_count; i++) {
-        /* open DAOS object based on oid[i] to get obj handle */
-        daos_handle_t oh;
         daos_obj_id_t oid;
-        oid.lo = p->obj_id_lo;	
-        oid.hi = p->obj_id_hi;	
-        rc = daos_obj_open(da->src_coh, oid, 0, &oh, NULL);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS object open returned with errors: ", MFU_ERRF,
-	            MFU_ERRP(-MFU_ERR_DAOS));
-	    return 1;
-        }
-
-        /* open handle of object in dst container */
-        daos_handle_t dst_oh;
-        rc = daos_obj_open(da->dst_coh, oid, 0, &dst_oh, NULL);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS object open returned with errors: ", MFU_ERRF,
-	            MFU_ERRP(-MFU_ERR_DAOS));
-            /* make sure to close the source if opening dst fails */
-            daos_obj_close(oh, NULL);
-	    return 1;
-        }
-        rc = daos_copy_list_keys(&oh, &dst_oh);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS copy list keys returned with errors: ", MFU_ERRF,
-                    MFU_ERRP(-MFU_ERR_DAOS));
-            /* cleanup object handles on failure */
-            daos_obj_close(oh, NULL);
-            daos_obj_close(dst_oh, NULL);
-	    return 1;
+        oid.lo = p->obj_id_lo;
+        oid.hi = p->obj_id_hi;
+
+        /* Copy this object */
+        rc = mfu_daos_obj_sync(da, src_coh, dst_coh, oid,
+                               compare_dst, write_dst, stats);
+        if (rc == -1) {
+            MFU_LOG(MFU_LOG_ERR, "mfu_daos_obj_sync return with error");
+            return rc;
         }
 
-        /* close source and destination object */
-        daos_obj_close(oh, NULL);
-        daos_obj_close(dst_oh, NULL);
         p = p->next;
     }
 
     return rc;
 }
 
-static int daos_obj_list_oids(daos_args_t* da, mfu_flist bflist) {
-    /* List objects in src container to be copied to 
-     * destination container */
-    static const int     OID_ARR_SIZE = 50;
+/*
+ * Create a snapshot and oit at the supplied epc.
+ * Add an flist entry for each oid in the oit.
+ */
+static int mfu_daos_obj_list_oids(
+    daos_args_t* da, mfu_flist bflist,
+    daos_handle_t coh, daos_epoch_t epoch)
+{
     daos_obj_id_t        oids[OID_ARR_SIZE];
     daos_anchor_t        anchor;
     uint32_t             oids_nr;
-    daos_handle_t        toh;
+    daos_handle_t        toh = DAOS_HDL_INVAL;
     uint32_t             oids_total = 0;
     int                  rc = 0;
 
-    /* create snapshot to pass to object iterator table */
-    rc = daos_cont_create_snap_opt(da->src_coh, &da->epc, NULL,
-    				   DAOS_SNAP_OPT_CR | DAOS_SNAP_OPT_OIT,
-				   NULL);
+    /* open object iterator table */
+    rc = daos_oit_open(coh, epoch, &toh, NULL);
     if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "DAOS failed to create snapshot: ", MFU_ERRF,
-                MFU_ERRP(-MFU_ERR_DAOS));
-        return 1;
-    }
-
-    /* open object iterator table */
-    rc = daos_oit_open(da->src_coh, da->epc, &toh, NULL);
-    if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "DAOS failed to open oit: ", MFU_ERRF,
-                MFU_ERRP(-MFU_ERR_DAOS));
+        MFU_LOG(MFU_LOG_ERR, "DAOS failed to open oit "DF_RC, DP_RC(rc));
         return 1;
     }
+    memset(&oids, 0, OID_ARR_SIZE*sizeof(daos_obj_id_t));
     memset(&anchor, 0, sizeof(anchor));
     flist_t* flist = (flist_t*) bflist;
 
@@ -1238,34 +1774,51 @@ static int daos_obj_list_oids(daos_args_t* da, mfu_flist bflist) {
         oids_nr = OID_ARR_SIZE;
         rc = daos_oit_list(toh, oids, &oids_nr, &anchor, NULL);
         if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS daos_oit_list returned with errors: ", MFU_ERRF,
-	            MFU_ERRP(-MFU_ERR_DAOS));
+            MFU_LOG(MFU_LOG_ERR, "DAOS daos_oit_list returned with errors "DF_RC, DP_RC(rc));
+            daos_oit_close(toh, NULL);
+            return 1;
+        }
+
+        if (oids_nr < 1) {
+            MFU_LOG(MFU_LOG_ERR, "No Objects Currently in Container, Exiting.");
             daos_oit_close(toh, NULL);
             return 1;
         }
-	int i;
-	/* create element in flist for each obj id retrived */
- 	for (i = 0; i < oids_nr; i++) {
+
+        /* create element in flist for each obj id retrived */
+        for (int i = 0; i < oids_nr; i++) {
             uint64_t idx = mfu_flist_file_create(bflist);
             mfu_flist_file_set_oid(bflist, idx, oids[i]);
-	}
-	oids_total = oids_nr + oids_total;
- 	if (daos_anchor_is_eof(&anchor)) {
- 		break;
- 	}
+            char* name = NULL;
+            if (asprintf(&name, "%llu.%llu", oids[i].hi, oids[i].lo) == -1) {
+                MFU_LOG(MFU_LOG_ERR, "Unable to allocate space for object.");
+                daos_oit_close(toh, NULL);
+                return 1;
+            }
+            mfu_flist_file_set_name(bflist, idx, name);
+            mfu_free(&name);
+        }
+        oids_total = oids_nr + oids_total;
+        if (daos_anchor_is_eof(&anchor)) {
+            break;
+        }
     }
 
     /* close object iterator */
     rc = daos_oit_close(toh, NULL);
     if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "DAOS failed to close oit: ", MFU_ERRF,
-                MFU_ERRP(-MFU_ERR_DAOS));
+        MFU_LOG(MFU_LOG_ERR, "DAOS failed to close oit "DF_RC, DP_RC(rc));
+        rc = 1;
     }
     return rc;
 }
 
-int mfu_flist_walk_daos(
+/* Walk objects in daos and insert to given flist.
+ * Returns -1 on failure, 0 on success. */
+int mfu_daos_flist_walk(
     daos_args_t* da,
+    daos_handle_t coh,
+    daos_epoch_t* epoch,
     mfu_flist flist)
 {
     /* assume we'll succeed */
@@ -1277,39 +1830,2940 @@ int mfu_flist_walk_daos(
 
     /* have rank 0 do the work of listing the objects */
     if (rank == 0) {
-        rc = daos_obj_list_oids(da, flist);
+        /* TODO give this some meaningful name? (arg 3) */
+        rc = daos_cont_create_snap_opt(coh, epoch, NULL,
+                                       DAOS_SNAP_OPT_CR | DAOS_SNAP_OPT_OIT,
+                                       NULL);
         if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "DAOS failed to list oids: ",
-                MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+            MFU_LOG(MFU_LOG_ERR, "DAOS failed to create snapshot "DF_RC, DP_RC(rc));
+            rc = -1;
+            goto out_broadcast;
+        }
+
+        rc = mfu_daos_obj_list_oids(da, flist, coh, *epoch);
+        if (rc != 0) {
+            rc = -1;
+            goto out_broadcast;
         }
     }
 
     /* summarize list since we added items to it */
     mfu_flist_summarize(flist);
 
+out_broadcast:
     /* broadcast return code from rank 0 so everyone knows whether walk succeeded */
     MPI_Bcast(&rc, 1, MPI_INT, 0, MPI_COMM_WORLD);
 
     return rc;
 }
 
-int mfu_flist_copy_daos(
-    daos_args_t* da,
-    mfu_flist flist)
+/* Collectively copy/sync objects in flist to destination listed in daos args.
+ * Copies DAOS data at object level (non-posix).
+ * Returns 0 on success, 1 on failure. */
+int mfu_daos_flist_sync(
+    daos_args_t* da,    /* DAOS args */
+    mfu_flist flist,    /* flist containing oids */
+    bool compare_dst,   /* whether to compare the dst before writing */
+    bool write_dst)     /* whether to actually write to the dst */
 {
-    /* copy object ids listed in flist to destination in daos args */
-    int rc = daos_obj_copy(da, flist);
-    if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "DAOS object copy failed: ",
-            MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
-    }
+    /* get our rank */
+    int rank;
+    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
+
+    /* Initialize some stats */
+    mfu_daos_copy_stats_t stats;
+    mfu_daos_copy_stats_init(&stats);
+    mfu_daos_copy_stats_start(&stats);
+
+    /* evenly spread the objects across all ranks */
+    mfu_flist newflist = mfu_flist_spread(flist);
+
+    /* copy object ids listed in newflist to destination in daos args */
+    int rc = mfu_daos_flist_obj_sync(da, newflist, da->src_coh, da->dst_coh,
+                                     compare_dst, write_dst, &stats);
 
     /* wait until all procs are done copying,
-     * and determine whether everyone succeeded */
-    if (! mfu_alltrue(rc == 0, MPI_COMM_WORLD)) {
+     * and determine whether everyone succeeded. */
+    if (! mfu_alltrue(rc != -1, MPI_COMM_WORLD)) {
         /* someone failed, so return failure on all ranks */
         rc = 1;
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "DAOS object copy failed: ",
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+        }
+    } else {
+        /* either rc == 0 or rc == 1.
+         * both are success. */
+        rc = 0;
+    }
+
+    /* Record end time */
+    mfu_daos_copy_stats_end(&stats);
+
+    /* Sum and print the stats */
+    mfu_daos_copy_stats_t stats_sum;
+    mfu_daos_copy_stats_sum(&stats, &stats_sum);
+    if (rank == 0) {
+        mfu_daos_copy_stats_print(&stats_sum);
+    }
+
+    mfu_flist_free(&newflist);
+
+    return rc;
+}
+
+#ifdef HDF5_SUPPORT
+static inline void init_hdf5_args(struct hdf5_args *hdf5)
+{
+    hdf5->status = 0;
+    hdf5->file = -1;
+    /* User attribute data */
+    hdf5->usr_attr_memtype = 0;
+    hdf5->usr_attr_name_vtype = 0;
+    hdf5->usr_attr_val_vtype = 0;
+    /* OID Data */
+    hdf5->oid_memtype = 0;
+    hdf5->oid_dspace = 0;
+    hdf5->oid_dset = 0;
+    /* DKEY Data */
+    hdf5->dkey_memtype = 0;
+    hdf5->dkey_vtype = 0;
+    hdf5->dkey_dspace = 0;
+    hdf5->dkey_dset = 0;
+    /* AKEY Data */
+    hdf5->akey_memtype = 0;
+    hdf5->akey_vtype = 0;
+    hdf5->akey_dspace = 0;
+    hdf5->akey_dset = 0;
+    /* dims for dsets */
+    hdf5->oid_dims[0] = 0;
+    hdf5->dkey_dims[0] = 0;     
+    hdf5->akey_dims[0] = 0;     
+    /* data for keys */
+    hdf5->oid_data = NULL;
+    hdf5->dkey_data = NULL;
+    hdf5->akey_data = NULL;
+    hdf5->oid = NULL;
+    hdf5->dk = NULL;
+    hdf5->ak = NULL;
+}
+
+static int serialize_recx_single(struct hdf5_args *hdf5, 
+                                 daos_key_t *dkey,
+                                 daos_handle_t *oh,
+                                 daos_iod_t *iod)
+{
+    /* if iod_type is single value just fetch iod size from source
+     * and update in destination object */
+    int         buf_len = (int)(*iod).iod_size;
+    //void        *buf[buf_len * 2];
+    void        *buf;
+    d_sg_list_t sgl;
+    d_iov_t     iov;
+    int         rc;
+    herr_t      err;
+    buf = MFU_CALLOC(1, buf_len);
+
+    /* set sgl values */
+    sgl.sg_nr     = 1;
+    sgl.sg_nr_out = 0;
+    sgl.sg_iovs   = &iov;
+    d_iov_set(&iov, buf, buf_len);
+    rc = daos_obj_fetch(*oh, DAOS_TX_NONE, 0, dkey, 1, iod, &sgl,
+                        NULL, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to fetch object");
+        goto out;
+    }
+
+    /* Sanity check */
+    if (sgl.sg_nr_out != 1) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to fetch single recx.");
+        rc = 1;
+        goto out;
+    }
+
+    /* write single val record to dataset */
+    err = H5Dwrite(hdf5->single_dset, hdf5->single_dtype, H5S_ALL,
+                   hdf5->single_dspace, H5P_DEFAULT, sgl.sg_iovs[0].iov_buf);
+    if (err < 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to write single record dataset");
+        goto out;
+    }
+out:
+    mfu_free(&buf);
+    return rc;
+}
+
+static int serialize_recx_array(struct hdf5_args *hdf5,
+                                daos_key_t *dkey,
+                                daos_key_t *akey,
+                                char *rec_name,
+                                uint64_t *ak_index,
+                                daos_handle_t *oh,
+                                daos_iod_t *iod)
+{
+    int                 rc = 0;
+    int                 i = 0;
+    int                 attr_num = 0;
+    int                 buf_len = 0;
+    int                 path_len = 0;
+    int                 encode_buf_len;
+    uint32_t            number = 5;
+    size_t              nalloc;
+    daos_anchor_t       recx_anchor = {0}; 
+    daos_anchor_t       fetch_anchor = {0}; 
+    daos_epoch_range_t  eprs[5];
+    daos_recx_t         recxs[5];
+    daos_size_t         size = 0;
+    char                attr_name[ATTR_NAME_LEN];
+    char                number_str[ATTR_NAME_LEN];
+    char                attr_num_str[ATTR_NAME_LEN];
+    unsigned char       *encode_buf = NULL;
+    d_sg_list_t         sgl;
+    d_iov_t             iov;
+    hid_t               status = 0;
+
+    hdf5->rx_dset = 0;
+    hdf5->selection_attr = 0;
+    hdf5->rx_memspace = 0;
+    hdf5->rx_dtype = 0;
+
+    /* need to do a fetch for size, so that we can
+     * create the dataset with the correct datatype size */
+    number = 1;
+    rc = daos_obj_list_recx(*oh, DAOS_TX_NONE, dkey,
+                            akey, &size, &number, NULL, eprs, &fetch_anchor,
+                            true, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to list recx "DF_RC, DP_RC(rc));
+        goto out;
+    }
+    if (number == 0) {
+        rc = 0;
+        goto out;
+    }
+
+    if (size > 2000) {
+        MFU_LOG(MFU_LOG_ERR, "recx size is too large: %llu", size);
+        rc = 1;
+        goto out;
+    }
+
+    /* create the dataset with the correct type size */
+    hdf5->rx_dtype = H5Tcreate(H5T_OPAQUE, size);
+    if (hdf5->rx_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create rx_dtype");
+        rc = 1;
+        goto out;
+    }
+
+    hdf5->rx_dset = H5Dcreate(hdf5->file,
+                              rec_name,
+                              hdf5->rx_dtype,
+                              hdf5->rx_dspace,
+                              H5P_DEFAULT,
+                              hdf5->plist,
+                              H5P_DEFAULT);
+    if (hdf5->rx_dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create rx_dset");
+        rc = 1;
+        goto out;
+    }
+    size = 0;
+
+    hdf5->rx_dims[0] = 0;
+    while (!daos_anchor_is_eof(&recx_anchor)) {
+        memset(recxs, 0, sizeof(recxs));
+        memset(eprs, 0, sizeof(eprs));
+
+        /* list all recx for this dkey/akey */
+        number = 5;
+        rc = daos_obj_list_recx(*oh, DAOS_TX_NONE, dkey,
+                                akey, &size, &number, recxs, eprs, &recx_anchor,
+                                true, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to list recx "DF_RC, DP_RC(rc));
+            goto out;
+        }
+
+        /* if no recx is returned for this dkey/akey move on */
+        if (number == 0) 
+            continue;
+        for (i = 0; i < number; i++) {
+            buf_len = recxs[i].rx_nr * size;
+            char buf[buf_len];
+
+            memset(&sgl, 0, sizeof(sgl));
+            memset(&iov, 0, sizeof(iov));
+
+            /* set iod values */
+            (*iod).iod_type  = DAOS_IOD_ARRAY;
+            (*iod).iod_size  = size;
+            (*iod).iod_nr    = 1;
+            (*iod).iod_recxs = &recxs[i];
+
+            /* set sgl values */
+            sgl.sg_nr     = 1;
+            sgl.sg_nr_out = 0;
+            sgl.sg_iovs   = &iov;
+
+            d_iov_set(&iov, buf, buf_len);  
+            /* fetch recx values from source */
+            rc = daos_obj_fetch(*oh, DAOS_TX_NONE, 0, dkey, 1, iod,
+                                &sgl, NULL, NULL);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to fetch object "DF_RC, DP_RC(rc));
+                goto out;
+            }
+
+            /* Sanity check */
+            if (sgl.sg_nr_out != 1) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to fetch array recxs.");
+                rc = 1;
+                goto out;
+            }
+
+            /* write data to record dset */
+            hdf5->mem_dims[0] = recxs[i].rx_nr;
+            hdf5->rx_memspace = H5Screate_simple(1, hdf5->mem_dims,
+                                                 hdf5->mem_dims);
+            if (hdf5->rx_memspace < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to create rx_memspace");
+                rc = 1;
+                goto out;
+            }
+            /* extend dataset */
+            hdf5->rx_dims[0] += recxs[i].rx_nr;
+            status = H5Dset_extent(hdf5->rx_dset, hdf5->rx_dims);
+            if (status < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to extend rx_dset");
+                rc = 1;
+                goto out;
+            }
+            /* retrieve extended dataspace */
+            hdf5->rx_dspace = H5Dget_space(hdf5->rx_dset);
+            if (hdf5->rx_dspace < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to get rx_dspace");
+                rc = 1;
+                goto out;
+            }
+            hsize_t dset_size = H5Sget_simple_extent_npoints(hdf5->rx_dspace);
+            hsize_t start = (hsize_t)recxs[i].rx_idx;
+            hsize_t count = (hsize_t)recxs[i].rx_nr;
+            status = H5Sselect_hyperslab(hdf5->rx_dspace,
+                                         H5S_SELECT_AND, &start,
+                                         NULL, &count, NULL);
+            if (status < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to select hyperslab");
+                rc = 1;
+                goto out;
+            }
+
+            status = H5Dwrite(hdf5->rx_dset, hdf5->rx_dtype,
+                              hdf5->rx_memspace, hdf5->rx_dspace,
+                              H5P_DEFAULT, sgl.sg_iovs[0].iov_buf);
+            if (status < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to write rx_dset");
+                rc = 1;
+                goto out;
+            }
+            /* get size of buffer needed
+             * from nalloc
+             */
+            status = H5Sencode1(hdf5->rx_dspace, NULL, &nalloc);
+            if (status < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to get size of buffer needed");
+                rc = 1;
+                goto out;
+            }
+            /* encode dataspace description
+             * in buffer then store in
+             * attribute on dataset
+             */
+            encode_buf = MFU_CALLOC(nalloc, sizeof(unsigned char));
+            if (encode_buf == NULL) {
+                rc = ENOMEM;
+                goto out;
+            }
+            status = H5Sencode1(hdf5->rx_dspace, encode_buf,
+                                &nalloc);
+            if (status < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to encode dataspace");
+                rc = 1;
+                goto out;
+            }
+            /* created attribute in HDF5 file with encoded
+             * dataspace for this record extent */
+            memset(attr_name, 0, ATTR_NAME_LEN);
+            memset(number_str, 0, ATTR_NAME_LEN);
+            memset(attr_num_str, 0, ATTR_NAME_LEN);
+            path_len = snprintf(number_str, ATTR_NAME_LEN, "%d",
+                                (int)(*ak_index));
+            if (path_len >= ATTR_NAME_LEN) {
+                MFU_LOG(MFU_LOG_ERR, "number_str is too long");
+                rc = 1;
+                goto out;
+            }
+            path_len = snprintf(attr_num_str, ATTR_NAME_LEN, "-%d", attr_num);
+            if (path_len >= ATTR_NAME_LEN) {
+                MFU_LOG(MFU_LOG_ERR, "attr number str is too long");
+                rc = 1;
+                goto out;
+            }
+            path_len = snprintf(attr_name, ATTR_NAME_LEN, "%s%s%s", "A-",
+                                number_str, attr_num_str);
+            if (path_len >= ATTR_NAME_LEN) {
+                MFU_LOG(MFU_LOG_ERR, "attr name is too long");
+                rc = 1;
+                goto out;
+            }
+            hdf5->attr_dims[0] = 1;
+            hdf5->attr_dspace = H5Screate_simple(1, hdf5->attr_dims, NULL);
+            if (hdf5->attr_dspace < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to create attr");
+                rc = 1;
+                goto out;
+            }
+            hdf5->attr_dtype = H5Tcreate(H5T_OPAQUE, nalloc);
+            if (hdf5->attr_dtype < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to create attr dtype");
+                rc = 1;
+                goto out;
+            }
+            hdf5->selection_attr = H5Acreate2(hdf5->rx_dset,
+                                              attr_name,
+                                              hdf5->attr_dtype,
+                                              hdf5->attr_dspace,
+                                              H5P_DEFAULT,
+                                              H5P_DEFAULT);
+            if (hdf5->selection_attr < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to create selection attr");
+                rc = 1;
+                goto out;
+            }
+            status = H5Awrite(hdf5->selection_attr, hdf5->attr_dtype,
+                              encode_buf);
+            if (status < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to write attr");
+                rc = 1;
+                goto out;
+            }
+            if (hdf5->selection_attr > 0) {
+                H5Aclose(hdf5->selection_attr);
+            }
+            if (hdf5->rx_memspace > 0) {
+                H5Sclose(hdf5->rx_memspace);
+            }
+            if (hdf5->attr_dtype > 0) {
+                H5Tclose(hdf5->attr_dtype);
+            }
+            mfu_free(&encode_buf);
+            attr_num++;
+        }
+    }
+out:
+    if (hdf5->rx_dset > 0) {
+        H5Dclose(hdf5->rx_dset);
+    }
+    if (hdf5->rx_dtype > 0) {
+        H5Tclose(hdf5->rx_dtype);
+    }
+    if (rc != 0) {
+        if (hdf5->selection_attr > 0) {
+            H5Aclose(hdf5->selection_attr);
+        }
+        if (hdf5->rx_memspace > 0) {
+            H5Sclose(hdf5->rx_memspace);
+        }
+        mfu_free(&encode_buf);
+    }
+    return rc;
+}
+
+static int init_recx_data(struct hdf5_args *hdf5)
+{
+    int     rc = 0;
+    herr_t  err = 0;
+
+    hdf5->single_dims[0] = 1;
+    hdf5->rx_dims[0] = 0;
+    hdf5->rx_max_dims[0] = H5S_UNLIMITED;
+    hdf5->rx_chunk_dims[0] = 131072;
+
+    hdf5->plist = H5Pcreate(H5P_DATASET_CREATE);
+    if (hdf5->plist < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create prop list");
+        rc = 1;
+        goto out;
+    }
+    hdf5->rx_dspace = H5Screate_simple(1, hdf5->rx_dims, hdf5->rx_max_dims);
+    if (hdf5->rx_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create rx_dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->single_dspace = H5Screate_simple(1, hdf5->single_dims, NULL);
+    if (hdf5->single_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create single_dspace");
+        rc = 1;
+        goto out;
+    }
+    err = H5Pset_layout(hdf5->plist, H5D_CHUNKED);
+    if (err < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to set property layout");
+        rc = 1;
+        goto out;
+    }
+    err = H5Pset_chunk(hdf5->plist, 1, hdf5->rx_chunk_dims);
+    if (err < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to set chunk size");
+        rc = 1;
+        goto out;
+    }
+out:
+    if (rc != 0) {
+        H5Tclose(hdf5->usr_attr_memtype);
+        H5Tclose(hdf5->usr_attr_name_vtype);
+        H5Tclose(hdf5->usr_attr_val_vtype);
+        H5Tclose(hdf5->dkey_memtype);
+        H5Tclose(hdf5->dkey_vtype);
+        H5Tclose(hdf5->akey_memtype);
+        H5Tclose(hdf5->akey_vtype);
+    }
+    return rc;
+}
+
+static int serialize_akeys(struct hdf5_args *hdf5,
+                           daos_key_t diov,
+                           uint64_t *dk_index,
+                           uint64_t *ak_index,
+                           uint64_t *total_akeys,
+                           daos_handle_t *oh)
+{
+    int             rc = 0;
+    herr_t          err = 0;
+    int             j = 0;
+    daos_anchor_t   akey_anchor = {0}; 
+    d_sg_list_t     akey_sgl;
+    d_iov_t         akey_iov;
+    daos_key_desc_t akey_kds[ENUM_DESC_NR] = {0};
+    uint32_t        akey_number = ENUM_DESC_NR;
+    char            akey_enum_buf[ENUM_DESC_BUF] = {0};
+    char            akey[ENUM_KEY_BUF] = {0};
+    char            *akey_ptr = NULL;
+    daos_key_t      aiov;
+    daos_iod_t      iod;
+    char            rec_name[32];
+    int             path_len = 0;
+    int             size = 0;
+    hvl_t           *akey_val;
+
+    (*hdf5->dk)[*dk_index].akey_offset = *ak_index;
+    while (!daos_anchor_is_eof(&akey_anchor)) {
+        memset(akey_kds, 0, sizeof(akey_kds));
+        memset(akey, 0, sizeof(akey));
+        memset(akey_enum_buf, 0, sizeof(akey_enum_buf));
+        akey_number = ENUM_DESC_NR;
+
+        akey_sgl.sg_nr     = 1;
+        akey_sgl.sg_nr_out = 0;
+        akey_sgl.sg_iovs   = &akey_iov;
+
+        d_iov_set(&akey_iov, akey_enum_buf, ENUM_DESC_BUF);
+
+        /* get akeys */
+        rc = daos_obj_list_akey(*oh, DAOS_TX_NONE, &diov,
+                                &akey_number, akey_kds,
+                                &akey_sgl, &akey_anchor, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to list akeys: %d", rc);
+            goto out;
+        }
+
+        /* if no akeys returned move on */
+        if (akey_number == 0)
+            continue;
+
+        size = (akey_number + *total_akeys) * sizeof(akey_t);
+        *hdf5->ak = realloc(*hdf5->ak, size);
+        if (*hdf5->ak == NULL) {
+            rc = ENOMEM;
+            goto out;
+        }
+
+        /* parse out individual akeys based on key length and
+         * numver of dkeys returned
+         */
+        for (akey_ptr = akey_enum_buf, j = 0; j < akey_number; j++) {
+            memcpy(akey, akey_ptr, akey_kds[j].kd_key_len);
+            memset(&aiov, 0, sizeof(diov));
+            d_iov_set(&aiov, (void*)akey,
+                      akey_kds[j].kd_key_len);
+            akey_val = &(*hdf5->ak)[*ak_index].akey_val;
+            akey_val->p = MFU_CALLOC((uint64_t)akey_kds[j].kd_key_len, sizeof(char));
+            if (akey_val->p == NULL) {
+                rc = ENOMEM;
+                goto out;
+            }
+            memcpy(akey_val->p, (void*)akey_ptr,
+                   (uint64_t)akey_kds[j].kd_key_len);
+            akey_val->len = (uint64_t)akey_kds[j].kd_key_len; 
+            (*hdf5->ak)[*ak_index].rec_dset_id = *ak_index;
+
+            /* set iod values */
+            iod.iod_nr   = 1;
+            iod.iod_type = DAOS_IOD_SINGLE;
+            iod.iod_size = DAOS_REC_ANY;
+            iod.iod_recxs = NULL;
+            iod.iod_name  = aiov;
+
+            /* do a fetch (with NULL sgl) of single value type,
+            * and if that returns iod_size == 0, then a single
+            * value does not exist.
+            */
+            rc = daos_obj_fetch(*oh, DAOS_TX_NONE, 0, &diov,
+                                1, &iod, NULL, NULL, NULL);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to fetch object");
+                rc = 1;
+                goto out;
+            }
+
+            /* if iod_size == 0 then this is a
+             * DAOS_IOD_ARRAY type
+             */
+            /* TODO: create a record dset for each
+             * akey
+             */
+            memset(&rec_name, FILENAME_LEN, sizeof(rec_name));
+            path_len = snprintf(rec_name, FILENAME_LEN, "%lu", *ak_index);
+            if (path_len > FILENAME_LEN) {
+                MFU_LOG(MFU_LOG_ERR, "record name too long");
+                rc = 1;
+                goto out;
+            }
+            if ((int)iod.iod_size == 0) {
+                rc = serialize_recx_array(hdf5, &diov, &aiov, rec_name,
+                                          ak_index, oh, &iod);
+                if (rc != 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to serialize recx array: %d",
+                            rc);
+                    goto out;
+                }
+            } else {
+                hdf5->single_dtype = H5Tcreate(H5T_OPAQUE, iod.iod_size);
+                if (hdf5->single_dtype < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to create single record dtype");
+                    rc = 1;
+                    goto out;
+                }
+                hdf5->single_dset = H5Dcreate(hdf5->file,
+                                              rec_name,
+                                              hdf5->single_dtype,
+                                              hdf5->single_dspace,
+                                              H5P_DEFAULT,
+                                              H5P_DEFAULT,
+                                              H5P_DEFAULT);
+                if (hdf5->single_dset < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed create single record dataset");
+                    rc = 1;
+                    goto out;
+                }
+                rc = serialize_recx_single(hdf5, &diov, oh,
+                                           &iod);
+                if (rc != 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to serialize recx single: %d",
+                            rc);
+                    goto out;
+                }
+                err = H5Dclose(hdf5->single_dset);
+                if (err < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to close recx single");
+                    rc = 1;
+                    goto out;
+                }
+                err = H5Tclose(hdf5->single_dtype);
+                if (err < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to close single_dtype");
+                    rc = 1;
+                    goto out;
+                }
+            }
+            /* advance to next akey returned */ 
+            akey_ptr += akey_kds[j].kd_key_len;
+            (*ak_index)++;
+        }
+        *total_akeys = (*total_akeys) + akey_number;
+    }
+out:
+    return rc;
+}
+
+static int serialize_dkeys(struct hdf5_args *hdf5,
+                           uint64_t *dk_index,
+                           uint64_t *ak_index,
+                           uint64_t *total_dkeys,
+                           uint64_t *total_akeys,
+                           daos_handle_t *oh,
+                           int *oid_index)
+{
+    int             rc = 0;
+    herr_t          err = 0;
+    int             i = 0;
+    daos_anchor_t   dkey_anchor = {0}; 
+    d_sg_list_t     dkey_sgl;
+    d_iov_t         dkey_iov;
+    daos_key_desc_t dkey_kds[ENUM_DESC_NR] = {0};
+    uint32_t        dkey_number = ENUM_DESC_NR;
+    char            dkey_enum_buf[ENUM_DESC_BUF] = {0};
+    char            dkey[ENUM_KEY_BUF] = {0};
+    char            *dkey_ptr;
+    daos_key_t      diov;
+    int             path_len = 0;
+    hvl_t           *dkey_val;
+    int             size = 0;
+
+    rc = init_recx_data(hdf5);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to initialize recx data: %d", rc);
+        rc = 1;
+        goto out;
     }
+    (*hdf5->oid)[*oid_index].dkey_offset = *dk_index;
+    while (!daos_anchor_is_eof(&dkey_anchor)) {
+        memset(dkey_kds, 0, sizeof(dkey_kds));
+        memset(dkey, 0, sizeof(dkey));
+        memset(dkey_enum_buf, 0, sizeof(dkey_enum_buf));
+        dkey_number = ENUM_DESC_NR;
 
+        dkey_sgl.sg_nr     = 1;
+        dkey_sgl.sg_nr_out = 0;
+        dkey_sgl.sg_iovs   = &dkey_iov;
+
+        d_iov_set(&dkey_iov, dkey_enum_buf, ENUM_DESC_BUF);
+
+        /* get dkeys */
+        rc = daos_obj_list_dkey(*oh, DAOS_TX_NONE, &dkey_number,
+                                dkey_kds, &dkey_sgl, &dkey_anchor,
+                                NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to list dkeys: %d", rc);
+            goto out;
+        }
+        /* if no dkeys were returned move on */
+        if (dkey_number == 0)
+            continue;
+        *hdf5->dk = realloc(*hdf5->dk,
+                            (dkey_number + *total_dkeys) * sizeof(dkey_t));
+        if (*hdf5->dk == NULL) {
+            rc = ENOMEM;
+            goto out;
+        }
+        /* parse out individual dkeys based on key length and
+         * number of dkeys returned
+         */
+        for (dkey_ptr = dkey_enum_buf, i = 0; i < dkey_number; i++) {
+            /* Print enumerated dkeys */
+            memcpy(dkey, dkey_ptr, dkey_kds[i].kd_key_len);
+            memset(&diov, 0, sizeof(diov));
+            d_iov_set(&diov, (void*)dkey, dkey_kds[i].kd_key_len);
+            dkey_val = &(*hdf5->dk)[*dk_index].dkey_val;
+            dkey_val->p = MFU_CALLOC((uint64_t)dkey_kds[i].kd_key_len, sizeof(char));
+            if (dkey_val->p == NULL) {
+                rc = ENOMEM;
+                goto out;
+            }
+            memcpy(dkey_val->p, (void*)dkey_ptr,
+                   (uint64_t)dkey_kds[i].kd_key_len);
+            dkey_val->len = (uint64_t)dkey_kds[i].kd_key_len; 
+            rc = serialize_akeys(hdf5, diov, dk_index, ak_index,
+                                 total_akeys, oh); 
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to list akeys: %d", rc);
+                rc = 1;
+                goto out;
+            }
+            dkey_ptr += dkey_kds[i].kd_key_len;
+            (*dk_index)++;
+        }
+        *total_dkeys = (*total_dkeys) + dkey_number;
+    }
+    err = H5Sclose(hdf5->rx_dspace);
+    if (err < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close rx_dspace");
+        rc = 1;
+        goto out;
+    }
+    err = H5Sclose(hdf5->single_dspace);
+    if (err < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close single_dspace");
+        rc = 1;
+        goto out;
+    }
+out:
     return rc;
 }
+
+static int init_hdf5_file(struct hdf5_args *hdf5, char *filename) {
+    int rc = 0;
+    hdf5->file = H5Fcreate(filename, H5F_ACC_TRUNC, H5P_DEFAULT,
+                           H5P_DEFAULT);
+    if (hdf5->file < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create hdf5 file");
+        rc = 1;
+        goto out;
+    }
+
+    /* Set user attribute dataset types */
+    hdf5->usr_attr_memtype = H5Tcreate(H5T_COMPOUND, sizeof(usr_attr_t));
+    if (hdf5->usr_attr_memtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create user attr memtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->usr_attr_name_vtype = H5Tcopy(H5T_C_S1);
+    if (hdf5->usr_attr_name_vtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create user attr name vtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tset_size(hdf5->usr_attr_name_vtype, H5T_VARIABLE);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create user attr name vtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->usr_attr_val_vtype = H5Tvlen_create(H5T_NATIVE_OPAQUE);
+    if (hdf5->usr_attr_val_vtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create user attr val vtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->usr_attr_memtype, "Attribute Name",
+                             HOFFSET(usr_attr_t, attr_name), hdf5->usr_attr_name_vtype);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert user attr name");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->usr_attr_memtype, "Attribute Value",
+                             HOFFSET(usr_attr_t, attr_val), hdf5->usr_attr_val_vtype);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert user attr val");
+        rc = 1;
+        goto out;
+    }
+
+    /* Set oid dataset types */
+    hdf5->oid_memtype = H5Tcreate(H5T_COMPOUND, sizeof(oid_t));
+    if (hdf5->oid_memtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create oid memtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->oid_memtype, "OID Hi",
+                             HOFFSET(oid_t, oid_hi), H5T_NATIVE_UINT64);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert oid hi");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->oid_memtype, "OID Low",
+                             HOFFSET(oid_t, oid_low), H5T_NATIVE_UINT64);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert oid low");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->oid_memtype, "Dkey Offset",
+                             HOFFSET(oid_t, dkey_offset), H5T_NATIVE_UINT64);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert dkey offset");
+        rc = 1;
+        goto out;
+    }
+
+    /* Set dkey dataset types */
+    hdf5->dkey_memtype = H5Tcreate(H5T_COMPOUND, sizeof(dkey_t));
+    if (hdf5->dkey_memtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create dkey memtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->dkey_vtype = H5Tvlen_create(H5T_NATIVE_OPAQUE);
+    if (hdf5->dkey_vtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create dkey vtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->dkey_memtype, "Akey Offset",
+                             HOFFSET(dkey_t, akey_offset),
+                             H5T_NATIVE_UINT64);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert akey offset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->dkey_memtype, "Dkey Value",
+                             HOFFSET(dkey_t, dkey_val), hdf5->dkey_vtype);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert dkey value");
+        rc = 1;
+        goto out;
+    }
+
+    /* Set akey dataset types */
+    hdf5->akey_memtype = H5Tcreate(H5T_COMPOUND, sizeof(akey_t));
+    if (hdf5->akey_memtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create akey memtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->akey_vtype = H5Tvlen_create(H5T_NATIVE_OPAQUE);
+    if (hdf5->akey_vtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create akey vtype");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->akey_memtype, "Dataset ID",
+                             HOFFSET(akey_t, rec_dset_id),
+                             H5T_NATIVE_UINT64);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert record dset id");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Tinsert(hdf5->akey_memtype, "Akey Value",
+                             HOFFSET(akey_t, akey_val), hdf5->akey_vtype);
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to insert akey value");
+        rc = 1;
+        goto out;
+    }
+out:
+    return rc;
+}
+
+static int cont_serialize_version(struct hdf5_args *hdf5, float version)
+{
+    int     rc = 0;
+    hid_t   status = 0;
+    char    *version_name = "Version";
+
+    hdf5->version_attr_dims[0] = 1;
+    hdf5->version_attr_type = H5Tcopy(H5T_NATIVE_FLOAT);
+    status = H5Tset_size(hdf5->version_attr_type, 4);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version dtype");
+        rc = 1;
+        goto out;
+    }
+    if (hdf5->version_attr_type < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version attr type");
+        rc = 1;
+        goto out;
+    }
+    hdf5->version_attr_dspace = H5Screate_simple(1, hdf5->version_attr_dims,
+                                                 NULL);
+    if (hdf5->version_attr_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version attr dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->version_attr = H5Acreate2(hdf5->file,
+                                    version_name,
+                                    hdf5->version_attr_type,
+                                    hdf5->version_attr_dspace,
+                                    H5P_DEFAULT,
+                                    H5P_DEFAULT);
+    if (hdf5->version_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version attr");
+        rc = 1;
+        goto out;
+    }   
+    status = H5Awrite(hdf5->version_attr, hdf5->version_attr_type,
+                      &version);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write attribute");
+        rc = 1;
+        goto out;
+    }
+    status = H5Aclose(hdf5->version_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close attribute");
+        rc = 1;
+        goto out;
+    }
+out:
+    return rc;
+}
+
+/*
+ * Free the user attribute buffers created by cont_get_usr_attrs.
+ */
+static void cont_free_usr_attrs(int n, char*** _names, void*** _buffers,
+                               size_t** _sizes)
+{
+    char**  names = *_names;
+    void**  buffers = *_buffers;
+
+    if (names != NULL) {
+        for (size_t i = 0; i < n; i++) {
+            mfu_free(&names[i]);
+        }
+        mfu_free(_names);
+    }
+    if (buffers != NULL) {
+        for (size_t i = 0; i < n; i++) {
+            mfu_free(&buffers[i]);
+        }
+        mfu_free(_buffers);
+    }
+    mfu_free(_sizes);
+}
+
+/*
+ * Get the user attributes for a container in a format similar
+ * to what daos_cont_set_attr expects.
+ * cont_free_usr_attrs should be called to free the allocations.
+ * Returns 1 on error, 0 on success.
+ */
+static int cont_get_usr_attrs(daos_handle_t coh,
+                              int* _n, char*** _names, void*** _buffers,
+                              size_t** _sizes)
+{
+    int         rc = 0;
+    uint64_t    total_size = 0;
+    uint64_t    cur_size = 0;
+    uint64_t    num_attrs = 0;
+    uint64_t    name_len = 0;
+    char*       name_buf = NULL;
+    char**      names = NULL;
+    void**      buffers = NULL;
+    size_t*     sizes = NULL;
+
+    /* Get the total size needed to store all names */
+    rc = daos_cont_list_attr(coh, NULL, &total_size, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to list user attributes "DF_RC, DP_RC(rc));
+        rc = 1;
+        goto out;
+    }
+
+    /* no attributes found */
+    if (total_size == 0) {
+        *_n = 0;
+        goto out;
+    }
+
+    /* Allocate a buffer to hold all attribute names */
+    name_buf = MFU_CALLOC(total_size, sizeof(char));
+    if (name_buf == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attribute buffer");
+        rc = 1;
+        goto out;
+    }
+
+    /* Get the attribute names */
+    rc = daos_cont_list_attr(coh, name_buf, &total_size, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to list user attributes "DF_RC, DP_RC(rc));
+        rc = 1;
+        goto out;
+    }
+
+    /* Figure out the number of attributes */
+    while (cur_size < total_size) {
+        name_len = strnlen(name_buf + cur_size, total_size - cur_size);
+        if (name_len == total_size - cur_size) {
+            /* end of buf reached but no end of string, ignoring */
+            break;
+        }
+        num_attrs++;
+        cur_size += name_len + 1;
+    }
+
+    /* Sanity check */
+    if (num_attrs == 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to parse user attributes");
+        rc = 1;
+        goto out;
+    }
+
+    /* Allocate arrays for attribute names, buffers, and sizes */
+    names = MFU_CALLOC(num_attrs, sizeof(char*));
+    if (names == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attribute buffer");
+        rc = 1;
+        goto out;
+    }
+    sizes = MFU_CALLOC(num_attrs, sizeof(size_t));
+    if (sizes == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attribute buffer");
+        rc = 1;
+        goto out;
+    }
+    buffers = MFU_CALLOC(num_attrs, sizeof(void*));
+    if (buffers == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attribute buffer");
+        rc = 1;
+        goto out;
+    }
+
+    /* Create the array of names */
+    cur_size = 0;
+    for (uint64_t i = 0; i < num_attrs; i++) {
+        name_len = strnlen(name_buf + cur_size, total_size - cur_size);
+        if (name_len == total_size - cur_size) {
+            /* end of buf reached but no end of string, ignoring */
+            break;
+        }
+        names[i] = strndup(name_buf + cur_size, name_len + 1);
+        cur_size += name_len + 1;
+    }
+
+    /* Get the buffer sizes */
+    rc = daos_cont_get_attr(coh, num_attrs,
+                            (const char* const*)names,
+                            NULL, sizes, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get user attribute sizes "DF_RC, DP_RC(rc));
+        rc = 1;
+        goto out;
+    }
+
+    /* Allocate space for each value */
+    for (uint64_t i = 0; i < num_attrs; i++) {
+        buffers[i] = MFU_CALLOC(sizes[i], sizeof(size_t));
+        if (buffers[i] == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "failed to allocate user attribute buffer");
+            rc = 1;
+            goto out;
+        }
+    }
+
+    /* Get the attribute values */
+    rc = daos_cont_get_attr(coh, num_attrs,
+                            (const char* const*)names,
+                            (void * const*)buffers, sizes,
+                            NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get user attribute values "DF_RC, DP_RC(rc));
+        rc = 1;
+        goto out;
+    }
+
+    /* Return values to the caller */
+    *_n = num_attrs;
+    *_names = names;
+    *_buffers = buffers;
+    *_sizes = sizes;
+out:
+    if (rc != 0) {
+        cont_free_usr_attrs(num_attrs, &names, &buffers, &sizes);
+    }
+
+    mfu_free(&name_buf);
+    return rc;
+}
+
+static int cont_serialize_usr_attrs(struct hdf5_args *hdf5, daos_handle_t cont)
+{
+    int         rc = 0;
+    hid_t       status = 0;
+    hid_t       dset = 0;
+    hid_t       dspace = 0;
+    hid_t       vtype = 0;
+    hsize_t     dims[1];
+    usr_attr_t* attr_data = NULL;
+    int         num_attrs = 0;
+    char**      names = NULL;
+    void**      buffers = NULL;
+    size_t*     sizes = NULL;
+
+    /* Get all user attributes */
+    rc = cont_get_usr_attrs(cont, &num_attrs, &names, &buffers, &sizes);
+    if (rc != 0) {
+        rc = 1;
+        goto out;
+    }
+
+    if (num_attrs == 0) {
+        goto out_no_attrs;
+    }
+
+    /* Create the user attribute data space */
+    dims[0] = num_attrs;
+    dspace = H5Screate_simple(1, dims, NULL);
+    if (dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create user attr dspace");
+        rc = 1;
+        goto out;
+    }
+
+    /* Create the user attribute dataset */
+    dset = H5Dcreate(hdf5->file, "User Attributes",
+                     hdf5->usr_attr_memtype, dspace,
+                     H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+    if (dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create user attribute dset");
+        rc = 1;
+        goto out;
+    }
+
+    /* Allocate space for all attributes */
+    attr_data = MFU_CALLOC(num_attrs, sizeof(usr_attr_t));
+    if (attr_data == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attributes");
+        rc = 1;
+        goto out;
+    }
+
+    /* Set the data for all attributes */
+    for (int i = 0; i < num_attrs; i++) {
+        attr_data[i].attr_name = names[i];
+        attr_data[i].attr_val.p = buffers[i];
+        attr_data[i].attr_val.len = sizes[i];
+    }
+
+    status = H5Dwrite(dset, hdf5->usr_attr_memtype, H5S_ALL,
+                      H5S_ALL, H5P_DEFAULT, attr_data);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write user attr dset");
+        rc = 1;
+        goto out;
+    }
+
+out:
+    cont_free_usr_attrs(num_attrs, &names, &buffers, &sizes);
+    mfu_free(&attr_data);
+    H5Dclose(dset);
+    H5Sclose(dspace);
+out_no_attrs:
+    return rc;
+}
+
+static int cont_serialize_prop_acl(struct hdf5_args* hdf5,
+                                   struct daos_prop_entry* entry,
+                                   const char* prop_str)
+{
+    int                 rc = 0;
+    hid_t               status = 0;
+	struct daos_acl     *acl = NULL;
+    char                **acl_strs = NULL;
+    size_t              len_acl = 0;
+
+    if (entry == NULL || entry->dpe_val_ptr == NULL) {
+        goto out;
+    }
+
+    /* convert acl to list of strings */
+    acl = (struct daos_acl *)entry->dpe_val_ptr;                         
+    rc = daos_acl_to_strs(acl, &acl_strs, &len_acl);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to convert acl to strs");
+        goto out;
+    }
+    hdf5->attr_dims[0] = len_acl;
+    hdf5->attr_dtype = H5Tcopy(H5T_C_S1);
+    if (hdf5->attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create acl type");
+        rc = 1;
+        goto out;
+    }
+    status = H5Tset_size(hdf5->attr_dtype, H5T_VARIABLE);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to set acl dtype size");
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dspace = H5Screate_simple(1, hdf5->attr_dims,
+                                         NULL);
+    if (hdf5->attr_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version attribute");
+        rc = 1;
+        goto out;
+    }
+    hdf5->usr_attr = H5Acreate2(hdf5->file,
+                                prop_str,
+                                hdf5->attr_dtype,
+                                hdf5->attr_dspace,
+                                H5P_DEFAULT,
+                                H5P_DEFAULT);
+    if (hdf5->usr_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create attribute");
+        rc = 1;
+        goto out;
+    }   
+    status = H5Awrite(hdf5->usr_attr, hdf5->attr_dtype,
+                      acl_strs);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write attribute");
+        rc = 1;
+        goto out;
+    }
+    status = H5Aclose(hdf5->usr_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close attribute");
+        rc = 1;
+        goto out;
+    }
+out:
+    return rc;
+}
+
+static int cont_serialize_prop_str(struct hdf5_args* hdf5,
+                                   struct daos_prop_entry* entry,
+                                   const char* prop_str)
+{
+    int rc = 0;
+    hid_t status = 0;
+
+    if (entry == NULL || entry->dpe_str == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "Property %s not found", prop_str);
+        rc = 1;
+        goto out;
+    }
+
+    hdf5->attr_dims[0] = 1;
+    hdf5->attr_dtype = H5Tcopy(H5T_C_S1);
+    if (hdf5->attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create usr attr type");
+        rc = 1;
+        goto out;
+    }
+    status = H5Tset_size(hdf5->attr_dtype, strlen(entry->dpe_str) + 1);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to set dtype size");
+        rc = 1;
+        goto out;
+    }
+    status = H5Tset_strpad(hdf5->attr_dtype, H5T_STR_NULLTERM);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to set null terminator");
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dspace = H5Screate_simple(1, hdf5->attr_dims,
+                                         NULL);
+    if (hdf5->attr_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version attribute dataspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->usr_attr = H5Acreate2(hdf5->file,
+                                prop_str,
+                                hdf5->attr_dtype,
+                                hdf5->attr_dspace,
+                                H5P_DEFAULT,
+                                H5P_DEFAULT);
+    if (hdf5->usr_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create attribute");
+        rc = 1;
+        goto out;
+    }   
+    status = H5Awrite(hdf5->usr_attr, hdf5->attr_dtype,
+                      entry->dpe_str);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write attribute");
+        rc = 1;
+        goto out;
+    }
+    status = H5Aclose(hdf5->usr_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close attribute");
+        rc = 1;
+        goto out;
+    }
+
+out:
+    return rc;
+}
+
+int daos_cont_serialize_files_generated(struct hdf5_args *hdf5,
+                                        uint64_t *files_generated)
+{
+    int     rc = 0;
+    hid_t   status = 0;
+
+    hdf5->attr_dims[0] = 1;
+    hdf5->attr_dtype = H5Tcopy(H5T_NATIVE_UINT64);
+    status = H5Tset_size(hdf5->attr_dtype, 8);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version dtype");
+        rc = 1;
+        goto out;
+    }
+    if (hdf5->attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create usr attr type");
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dspace = H5Screate_simple(1, hdf5->attr_dims,
+                                         NULL);
+    if (hdf5->attr_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version attr dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->usr_attr = H5Acreate2(hdf5->file,
+                                "Files Generated",
+                                hdf5->attr_dtype,
+                                hdf5->attr_dspace,
+                                H5P_DEFAULT,
+                                H5P_DEFAULT);
+    if (hdf5->usr_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create attr");
+        rc = 1;
+        goto out;
+    }   
+    status = H5Awrite(hdf5->usr_attr, hdf5->attr_dtype,
+                      files_generated);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write attr");
+        rc = 1;
+        goto out;
+    }
+    status = H5Aclose(hdf5->usr_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close attr");
+        rc = 1;
+        goto out;
+    }
+out:
+    if (hdf5->file > 0) {
+        H5Fclose(hdf5->file);
+    }
+    return rc;
+}
+
+static int cont_serialize_prop_uint(struct hdf5_args *hdf5,
+                                    struct daos_prop_entry* entry,
+                                    const char *prop_str)
+{
+    int     rc = 0;
+    hid_t   status = 0;
+
+    if (entry == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "Property %s not found", prop_str);
+        rc = 1;
+        goto out;
+    }
+
+    hdf5->attr_dims[0] = 1;
+    hdf5->attr_dtype = H5Tcopy(H5T_NATIVE_UINT64);
+    status = H5Tset_size(hdf5->attr_dtype, 8);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version dtype");
+        rc = 1;
+        goto out;
+    }
+    if (hdf5->attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create usr attr type");
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dspace = H5Screate_simple(1, hdf5->attr_dims,
+                                         NULL);
+    if (hdf5->attr_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create version attr dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->usr_attr = H5Acreate2(hdf5->file,
+                                prop_str,
+                                hdf5->attr_dtype,
+                                hdf5->attr_dspace,
+                                H5P_DEFAULT,
+                                H5P_DEFAULT);
+    if (hdf5->usr_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create attr");
+        rc = 1;
+        goto out;
+    }   
+    status = H5Awrite(hdf5->usr_attr, hdf5->attr_dtype,
+                      &entry->dpe_val);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write attr");
+        rc = 1;
+        goto out;
+    }
+    status = H5Aclose(hdf5->usr_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close attr");
+        rc = 1;
+        goto out;
+    }
+
+out:
+    return rc;
+}
+
+
+static int cont_serialize_props(struct hdf5_args *hdf5,
+                                    daos_handle_t cont)
+{
+    int                     rc = 0;
+    daos_prop_t*            prop_query;
+    daos_prop_t*            prop_acl = NULL;
+    struct daos_prop_entry* entry;
+    char                    cont_str[DAOS_PROP_LABEL_MAX_LEN];
+
+    /*
+     * Get all props except the ACL first.
+     */
+    prop_query = daos_prop_alloc(16);
+    if (prop_query == NULL) {
+        return ENOMEM;
+    }
+
+    prop_query->dpp_entries[0].dpe_type = DAOS_PROP_CO_LABEL;
+    prop_query->dpp_entries[1].dpe_type = DAOS_PROP_CO_LAYOUT_TYPE;
+    prop_query->dpp_entries[2].dpe_type = DAOS_PROP_CO_LAYOUT_VER;
+    prop_query->dpp_entries[3].dpe_type = DAOS_PROP_CO_CSUM;
+    prop_query->dpp_entries[4].dpe_type = DAOS_PROP_CO_CSUM_CHUNK_SIZE;
+    prop_query->dpp_entries[5].dpe_type = DAOS_PROP_CO_CSUM_SERVER_VERIFY;
+    prop_query->dpp_entries[6].dpe_type = DAOS_PROP_CO_REDUN_FAC;
+    prop_query->dpp_entries[7].dpe_type = DAOS_PROP_CO_REDUN_LVL;
+    prop_query->dpp_entries[8].dpe_type = DAOS_PROP_CO_SNAPSHOT_MAX;
+    prop_query->dpp_entries[9].dpe_type = DAOS_PROP_CO_COMPRESS;
+    prop_query->dpp_entries[10].dpe_type = DAOS_PROP_CO_ENCRYPT;
+    prop_query->dpp_entries[11].dpe_type = DAOS_PROP_CO_OWNER;
+    prop_query->dpp_entries[12].dpe_type = DAOS_PROP_CO_OWNER_GROUP;
+    prop_query->dpp_entries[13].dpe_type = DAOS_PROP_CO_DEDUP;
+    prop_query->dpp_entries[14].dpe_type = DAOS_PROP_CO_DEDUP_THRESHOLD;
+    prop_query->dpp_entries[15].dpe_type = DAOS_PROP_CO_ALLOCED_OID;
+
+    rc = daos_cont_query(cont, NULL, prop_query, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to query container "DF_RC, DP_RC(rc));
+        rc = 1;
+        goto out;
+    }
+
+    /* Fetch the ACL separately in case user doesn't have access */
+    rc = daos_cont_get_acl(cont, &prop_acl, NULL);
+    if (rc && rc != -DER_NO_PERM) {
+        MFU_LOG(MFU_LOG_ERR, "failed to query container ACL "DF_RC, DP_RC(rc));
+        rc = 1;
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[0];
+    rc = cont_serialize_prop_str(hdf5, entry, "DAOS_PROP_CO_LABEL");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[1];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_LAYOUT_TYPE");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[2];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_LAYOUT_VER");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[3];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_CSUM");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[4];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_CSUM_CHUNK_SIZE");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[5];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_CSUM_SERVER_VERIFY");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[6];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_REDUN_FAC");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[7];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_REDUN_LVL");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[8];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_SNAPSHOT_MAX");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[9];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_COMPRESS");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[10];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ENCRYPT");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[11];
+    rc = cont_serialize_prop_str(hdf5, entry, "DAOS_PROP_CO_OWNER");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[12];
+    rc = cont_serialize_prop_str(hdf5, entry, "DAOS_PROP_CO_OWNER_GROUP");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[13];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_DEDUP");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[14];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_DEDUP_THRESHOLD");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop_query->dpp_entries[15];
+    rc = cont_serialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ALLOCED_OID");
+    if (rc != 0) {
+        goto out;
+    }
+
+    /* serialize ACL */
+    if (prop_acl != NULL) {
+        entry = &prop_acl->dpp_entries[0];
+        rc = cont_serialize_prop_acl(hdf5, entry, "DAOS_PROP_CO_ACL");
+        if (rc != 0) {
+            goto out;
+        }
+    }
+
+out:
+    daos_prop_free(prop_query);
+    daos_prop_free(prop_acl);
+    return rc;
+}
+
+int daos_cont_serialize_hdlr(int rank, struct hdf5_args *hdf5, char *output_dir,
+                             uint64_t *files_written, daos_args_t *da,
+                             mfu_flist flist, uint64_t num_oids)
+{
+    int             rc = 0;
+    int             i = 0;
+    int             path_len = 0;
+    uint64_t        total_dkeys = 0;
+    uint64_t        total_akeys = 0;
+    uint64_t        dk_index = 0;
+    uint64_t        ak_index = 0;
+    daos_handle_t   toh;
+    daos_epoch_t    epoch;
+    daos_handle_t   oh;
+    float           version = 0.0;
+    herr_t          err = 0;
+    char            filename[FILENAME_LEN];
+    char            cont_str[FILENAME_LEN];
+    char            rank_str[FILENAME_LEN];
+
+    /* init HDF5 args */
+    init_hdf5_args(hdf5);
+
+    memset(rank_str, 0, FILENAME_LEN);
+    memset(cont_str, 0, FILENAME_LEN);
+    memset(filename, 0, FILENAME_LEN);
+    path_len = snprintf(rank_str, FILENAME_LEN, "%d", rank);
+    if (path_len >= FILENAME_LEN) {
+        MFU_LOG(MFU_LOG_ERR, "filename is too long");
+        rc = 1;
+        goto out;
+    }
+    uuid_unparse(da->src_cont_uuid, cont_str);
+
+    /* if output dir is given, then write to that directory,
+     * the default is to write into the current working directory */
+    path_len = snprintf(filename, FILENAME_LEN, "%s/%s%s%s%s%s", output_dir,
+                        cont_str, "_", "rank", rank_str, ".h5");
+    if (path_len >= FILENAME_LEN) {
+        MFU_LOG(MFU_LOG_ERR, "filename is too long");
+        rc = 1;
+        goto out;
+    }
+
+    printf("Serializing Container to %s\n", filename);
+
+    /* keep track of number of files written */
+    (*files_written)++;
+
+    /* init HDF5 datatypes in HDF5 file */
+    rc = init_hdf5_file(hdf5, filename);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to init hdf5 file");
+        rc = 1;
+        goto out;
+    }
+    hdf5->oid_data = MFU_CALLOC(num_oids, sizeof(oid_t));
+    if (hdf5->oid_data == NULL) {
+        rc = ENOMEM;
+        goto out;
+    }
+    hdf5->dkey_data = MFU_CALLOC(1, sizeof(dkey_t));
+    if (hdf5->dkey_data == NULL) {
+        rc = ENOMEM;
+        mfu_free(&hdf5->oid_data);
+        goto out;
+    }
+    hdf5->akey_data = MFU_CALLOC(1, sizeof(akey_t));
+    if (hdf5->akey_data == NULL) {
+        rc = ENOMEM;
+        mfu_free(&hdf5->oid_data);
+        mfu_free(&hdf5->dkey_data);
+        goto out;
+    }
+    hdf5->dk = &(hdf5->dkey_data);
+    hdf5->ak = &(hdf5->akey_data);
+    hdf5->oid = &(hdf5->oid_data);
+
+    /* size is total oids for this rank, loop over each oid and serialize */
+    for (i = 0; i < num_oids; i++) {
+        /* open DAOS object based on oid to get obj
+         * handle
+         */
+        daos_obj_id_t oid;
+        oid.hi = mfu_flist_file_get_oid_high(flist, i);
+        oid.lo = mfu_flist_file_get_oid_low(flist, i);
+        (*hdf5->oid)[i].oid_hi = oid.hi;
+        (*hdf5->oid)[i].oid_low = oid.lo;
+        rc = daos_obj_open(da->src_coh, oid, 0, &oh, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to open object: %d", rc);
+            goto out;
+        }
+        rc = serialize_dkeys(hdf5, &dk_index, &ak_index,
+                             &total_dkeys, &total_akeys,
+                             &oh, &i);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to serialize keys: %d", rc);
+            goto out;
+        }
+        /* close source and destination object */
+        rc = daos_obj_close(oh, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to close object: %d", rc);
+            goto out;
+        }
+    }
+
+    /* write container version as attribute */
+    rc = cont_serialize_version(hdf5, version);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to serialize version");
+        goto out;
+    }
+
+    rc = cont_serialize_usr_attrs(hdf5, da->src_coh);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to serialize user attributes");
+        goto out;
+    }
+
+    rc = cont_serialize_props(hdf5, da->src_coh);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to serialize cont layout");
+        goto out;
+    }
+
+    hdf5->oid_dims[0] = num_oids;
+    hdf5->oid_dspace = H5Screate_simple(1, hdf5->oid_dims, NULL);
+    if (hdf5->oid_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create oid dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->oid_dset = H5Dcreate(hdf5->file, "Oid Data",
+                              hdf5->oid_memtype, hdf5->oid_dspace,
+                              H5P_DEFAULT, H5P_DEFAULT,
+                              H5P_DEFAULT);
+    if (hdf5->oid_dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create oid dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->dkey_dims[0] = total_dkeys;     
+    hdf5->dkey_dspace = H5Screate_simple(1, hdf5->dkey_dims, NULL);
+    if (hdf5->dkey_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create dkey dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->dkey_dset = H5Dcreate(hdf5->file, "Dkey Data",
+                                hdf5->dkey_memtype, hdf5->dkey_dspace,
+                                H5P_DEFAULT, H5P_DEFAULT,
+                                H5P_DEFAULT);
+    if (hdf5->dkey_dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create dkey dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->akey_dims[0] = total_akeys;     
+    hdf5->akey_dspace = H5Screate_simple(1, hdf5->akey_dims, NULL);
+    if (hdf5->akey_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create akey dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->akey_dset = H5Dcreate(hdf5->file, "Akey Data",
+                                hdf5->akey_memtype, hdf5->akey_dspace,
+                                H5P_DEFAULT, H5P_DEFAULT,
+                                H5P_DEFAULT);
+    if (hdf5->akey_dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create akey dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Dwrite(hdf5->oid_dset, hdf5->oid_memtype, H5S_ALL,
+                            H5S_ALL, H5P_DEFAULT, *(hdf5->oid));
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write oid dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Dwrite(hdf5->dkey_dset, hdf5->dkey_memtype,
+                           H5S_ALL, H5S_ALL, H5P_DEFAULT,
+                           *(hdf5->dk));
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write dkey dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->status = H5Dwrite(hdf5->akey_dset, hdf5->akey_memtype,
+                           H5S_ALL, H5S_ALL, H5P_DEFAULT,
+                           *(hdf5->ak));
+    if (hdf5->status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to write akey dset");
+        rc = 1;
+        goto out;
+    }
+out:
+    if (hdf5->oid_dset > 0)
+        H5Dclose(hdf5->oid_dset);
+    if (hdf5->dkey_dset > 0)
+        H5Dclose(hdf5->dkey_dset);
+    if (hdf5->akey_dset > 0)
+        H5Dclose(hdf5->akey_dset);
+    if (hdf5->oid_dspace > 0)
+        H5Sclose(hdf5->oid_dspace);
+    if (hdf5->dkey_dspace > 0)
+        H5Sclose(hdf5->dkey_dspace);
+    if (hdf5->akey_dspace > 0)
+        H5Sclose(hdf5->akey_dspace);
+    if (hdf5->oid_memtype > 0)
+        H5Tclose(hdf5->oid_memtype);
+    if (hdf5->dkey_memtype > 0)
+        H5Tclose(hdf5->dkey_memtype);
+    if (hdf5->akey_memtype > 0)
+        H5Tclose(hdf5->akey_memtype);
+    mfu_free(&hdf5->oid_data);
+    mfu_free(&hdf5->dkey_data);
+    mfu_free(&hdf5->akey_data);
+    /* dont close file until the files generated is serialized */
+    return rc;
+}
+
+static int hdf5_read_key_data(struct hdf5_args *hdf5)
+{
+    int     rc = 0;
+    hid_t   status = 0;
+    int     oid_ndims = 0;
+    int     dkey_ndims = 0;
+    int     akey_ndims = 0;
+
+    /* read oid data */
+    hdf5->oid_dset = H5Dopen(hdf5->file, "Oid Data", H5P_DEFAULT);
+    if (hdf5->oid_dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open OID dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->oid_dspace = H5Dget_space(hdf5->oid_dset);
+    if (hdf5->oid_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get oid dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->oid_dtype = H5Dget_type(hdf5->oid_dset);
+    if (hdf5->oid_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get oid dtype");
+        rc = 1;
+        goto out;
+    }
+    oid_ndims = H5Sget_simple_extent_dims(hdf5->oid_dspace, hdf5->oid_dims,
+                                          NULL);
+    if (oid_ndims < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get oid dimensions");
+        rc = 1;
+        goto out;
+    }
+    hdf5->oid_data = MFU_CALLOC(hdf5->oid_dims[0], sizeof(oid_t));
+    if (hdf5->oid_data == NULL) {
+        rc = ENOMEM;
+        goto out;
+    }
+    status = H5Dread(hdf5->oid_dset, hdf5->oid_dtype, H5S_ALL, H5S_ALL,
+                     H5P_DEFAULT, hdf5->oid_data);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read oid data");
+        rc = 1;
+        goto out;
+    }
+
+    /* read dkey data */
+    hdf5->dkey_dset = H5Dopen(hdf5->file, "Dkey Data", H5P_DEFAULT);
+    if (hdf5->dkey_dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open dkey dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->dkey_dspace = H5Dget_space(hdf5->dkey_dset);
+    if (hdf5->dkey_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get dkey dspace");
+        rc = 1;
+        goto out;
+    }
+    hdf5->dkey_vtype = H5Dget_type(hdf5->dkey_dset);
+    if (hdf5->dkey_vtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get dkey vtype");
+        rc = 1;
+        goto out;
+    }
+    dkey_ndims = H5Sget_simple_extent_dims(hdf5->dkey_dspace,
+                                           hdf5->dkey_dims, NULL);
+    if (dkey_ndims < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get dkey dimensions");
+        rc = 1;
+        goto out;
+    }
+    hdf5->dkey_data = MFU_CALLOC(hdf5->dkey_dims[0], sizeof(dkey_t));
+    if (hdf5->dkey_data == NULL) {
+        rc = ENOMEM;
+        goto out;
+    }
+    status = H5Dread(hdf5->dkey_dset, hdf5->dkey_vtype, H5S_ALL, H5S_ALL,
+                     H5P_DEFAULT, hdf5->dkey_data);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read dkey data");
+        rc = 1;
+        goto out;
+    }
+
+    /* read akey data */
+    hdf5->akey_dset = H5Dopen(hdf5->file, "Akey Data", H5P_DEFAULT);
+    if (hdf5->akey_dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open akey dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->akey_dspace = H5Dget_space(hdf5->akey_dset);
+    if (hdf5->akey_dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get akey dset");
+        rc = 1;
+        goto out;
+    }
+    hdf5->akey_vtype = H5Dget_type(hdf5->akey_dset);
+    if (hdf5->akey_vtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get akey vtype");
+        rc = 1;
+        goto out;
+    }
+    akey_ndims = H5Sget_simple_extent_dims(hdf5->akey_dspace,
+                                           hdf5->akey_dims, NULL);
+    if (akey_ndims < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get akey dimensions");
+        rc = 1;
+        goto out;
+    }
+    hdf5->akey_data = MFU_CALLOC(hdf5->akey_dims[0], sizeof(akey_t));
+    if (hdf5->akey_data == NULL) {
+        rc = ENOMEM;
+        goto out;
+    }
+    status = H5Dread(hdf5->akey_dset, hdf5->akey_vtype, H5S_ALL, H5S_ALL,
+                     H5P_DEFAULT, hdf5->akey_data);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read akey data");
+        rc = 1;
+        goto out;
+    }
+out:
+    return rc;
+}
+
+static int cont_deserialize_recx(struct hdf5_args *hdf5,
+                                 daos_handle_t *oh,
+                                 daos_key_t diov,
+                                 int num_attrs,
+                                 uint64_t ak_off,
+                                 int k)
+{
+    int             rc = 0;
+    hid_t           status = 0;
+    int             i = 0;
+    ssize_t         attr_len = 0;
+    char            attr_name_buf[124]; 
+    hsize_t         attr_space;
+    hid_t           attr_type;
+    size_t          type_size;
+    size_t          rx_dtype_size;
+    unsigned char   *decode_buf;
+    hid_t           rx_range_id;
+    hsize_t         *rx_range = NULL;
+    uint64_t        recx_len = 0;
+    void            *recx_data = NULL;
+    hssize_t        nblocks = 0;
+    d_sg_list_t     sgl;
+    d_iov_t         iov;
+    daos_iod_t      iod;
+    daos_recx_t     recxs;
+    hid_t           aid;
+
+    for (i = 0; i < num_attrs; i++) {
+        memset(attr_name_buf, 0, sizeof(attr_name_buf));
+        aid = H5Aopen_idx(hdf5->rx_dset, (unsigned int)i);
+        if (aid < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get open attr");
+            rc = 1;
+            goto out;
+        }
+        attr_len = H5Aget_name(aid, 124, attr_name_buf);
+        if (attr_len < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get attr name");
+            rc = 1;
+            goto out;
+        }
+        attr_space = H5Aget_storage_size(aid);
+        if (attr_len < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get attr space");
+            rc = 1;
+            goto out;
+        }
+        attr_type = H5Aget_type(aid);
+        if (attr_type < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get attr type");
+            rc = 1;
+            goto out;
+        }
+        type_size = H5Tget_size(attr_type);
+        if (type_size < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get type size");
+            rc = 1;
+            goto out;
+        }
+        rx_dtype_size = H5Tget_size(hdf5->rx_dtype);
+        if (rx_dtype_size < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get rx type size");
+            rc = 1;
+            goto out;
+        }
+        decode_buf = MFU_CALLOC(1, type_size * attr_space);
+        if (decode_buf == NULL) {
+            rc = ENOMEM;
+            goto out;
+        }
+        rx_range = MFU_CALLOC(1, type_size * attr_space);
+        if (rx_range == NULL) {
+            rc = ENOMEM;
+            goto out;
+        }
+        status = H5Aread(aid, attr_type, decode_buf);
+        if (status < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to read attribute");
+            rc = 1;
+            goto out;
+        }
+        rx_range_id = H5Sdecode(decode_buf);
+        if (rx_range_id < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to decode attribute buffer");
+            rc = 1;
+            goto out;
+        }
+        nblocks = H5Sget_select_hyper_nblocks(rx_range_id);
+        if (nblocks < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get hyperslab blocks");
+            rc = 1;
+            goto out;
+        }
+        status = H5Sget_select_hyper_blocklist(rx_range_id, 0,
+                                               nblocks, rx_range);
+        if (status < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get blocklist");
+            rc = 1;
+            goto out;
+        }
+
+        /* read recx data then update */
+        hdf5->rx_dspace = H5Dget_space(hdf5->rx_dset);
+        if (hdf5->rx_dspace < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get rx_dspace");
+            rc = 1;
+            goto out;
+        }
+
+        hsize_t start = rx_range[0];
+        hsize_t count = (rx_range[1] - rx_range[0]) + 1;
+        status = H5Sselect_hyperslab(hdf5->rx_dspace,
+                                     H5S_SELECT_AND,
+                                     &start, NULL,
+                                     &count, NULL);
+        if (status < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to select hyperslab");
+            rc = 1;
+            goto out;
+        }
+        recx_len = count;
+        recx_data = MFU_CALLOC(recx_len, rx_dtype_size);
+        if (recx_data == NULL) {
+            rc = ENOMEM;
+            goto out;
+        }
+        hdf5->mem_dims[0] = count;
+        hdf5->rx_memspace = H5Screate_simple(1, hdf5->mem_dims,
+                                             hdf5->mem_dims);
+        status = H5Dread(hdf5->rx_dset,
+                         hdf5->rx_dtype,
+                         hdf5->rx_memspace,
+                         hdf5->rx_dspace,
+                         H5P_DEFAULT,
+                         recx_data);
+        if (status < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to read record extent");
+            rc = 1;
+            goto out;
+        }
+        memset(&sgl, 0, sizeof(sgl));
+        memset(&iov, 0, sizeof(iov));
+        memset(&iod, 0, sizeof(iod));
+        memset(&recxs, 0, sizeof(recxs));
+        d_iov_set(&iod.iod_name,
+                  (void*)hdf5->akey_data[ak_off + k].akey_val.p,
+                  hdf5->akey_data[ak_off + k].akey_val.len);
+        /* set iod values */
+        iod.iod_type  = DAOS_IOD_ARRAY;
+        iod.iod_size  = rx_dtype_size;
+        iod.iod_nr    = 1;
+
+        recxs.rx_nr = recx_len;
+        recxs.rx_idx = start;
+        iod.iod_recxs = &recxs;
+
+        /* set sgl values */
+        sgl.sg_nr     = 1;
+        sgl.sg_iovs   = &iov;
+
+        d_iov_set(&iov, recx_data, recx_len * rx_dtype_size); 
+
+        /* update fetched recx values and place in destination object */
+        rc = daos_obj_update(*oh, DAOS_TX_NONE, 0, &diov, 1, &iod,
+                             &sgl, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to update object: %d", rc);
+            goto out;
+        }
+        H5Aclose(aid);
+        mfu_free(&rx_range);
+        mfu_free(&recx_data);
+        mfu_free(&decode_buf);
+    }
+out:
+    return rc;
+}
+
+static int cont_deserialize_keys(struct hdf5_args *hdf5,
+                                 uint64_t *total_dkeys_this_oid,
+                                 uint64_t *dk_off,
+                                 daos_handle_t *oh)
+{
+    int             rc = 0;
+    hid_t           status = 0;
+    int             j = 0;
+    daos_key_t      diov;
+    char            dkey[ENUM_KEY_BUF] = {0};
+    uint64_t        ak_off = 0;
+    uint64_t        ak_next = 0;
+    uint64_t        total_akeys_this_dkey = 0;
+    int             k = 0;
+    daos_key_t      aiov;
+    char            akey[ENUM_KEY_BUF] = {0};
+    int             rx_ndims;
+    uint64_t        index = 0;
+    int             len = 0;
+    int             num_attrs;
+    size_t          single_tsize;
+    void            *single_data = NULL;
+    d_sg_list_t     sgl;
+    d_iov_t         iov;
+    daos_iod_t      iod;
+    
+    for(j = 0; j < *total_dkeys_this_oid; j++) {
+        memset(&diov, 0, sizeof(diov));
+        memset(dkey, 0, sizeof(dkey));
+        memcpy(dkey, hdf5->dkey_data[*dk_off + j].dkey_val.p,
+               hdf5->dkey_data[*dk_off + j].dkey_val.len);
+        d_iov_set(&diov, (void*)hdf5->dkey_data[*dk_off + j].dkey_val.p,
+                  hdf5->dkey_data[*dk_off + j].dkey_val.len);
+        ak_off = hdf5->dkey_data[*dk_off + j].akey_offset;
+        ak_next = 0;
+        total_akeys_this_dkey = 0;
+        if (*dk_off + j + 1 < (int)hdf5->dkey_dims[0]) {
+            ak_next = hdf5->dkey_data[(*dk_off + j) + 1].akey_offset;
+            total_akeys_this_dkey = ak_next - ak_off;
+        } else if (*dk_off + j == ((int)hdf5->dkey_dims[0] - 1)) {
+            total_akeys_this_dkey = ((int)hdf5->akey_dims[0]) - ak_off;
+        }
+
+        for(k = 0; k < total_akeys_this_dkey; k++) {
+            memset(&aiov, 0, sizeof(aiov));
+            memset(akey, 0, sizeof(akey));
+            memcpy(akey, hdf5->akey_data[ak_off + k].akey_val.p,
+                   hdf5->akey_data[ak_off + k].akey_val.len);
+            d_iov_set(&aiov, (void*)hdf5->akey_data[ak_off + k].akey_val.p,
+                  hdf5->akey_data[ak_off + k].akey_val.len);
+
+            /* read record data for each akey */
+            index = ak_off + k;
+            len = snprintf(NULL, 0, "%lu", index);
+            char dset_name[len + 1];    
+            snprintf(dset_name, len + 1, "%lu", index);
+            hdf5->rx_dset = H5Dopen(hdf5->file, dset_name,
+                                    H5P_DEFAULT);
+            if (hdf5->rx_dset < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to read rx_dset");
+                rc = 1;
+                goto out;
+            }
+            hdf5->rx_dspace = H5Dget_space(hdf5->rx_dset);
+            if (hdf5->rx_dspace < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to read rx_dspace");
+                rc = 1;
+                goto out;
+            }
+            hdf5->rx_dtype = H5Dget_type(hdf5->rx_dset);
+            if (hdf5->rx_dtype < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to read rx_dtype");
+                rc = 1;
+                goto out;
+            }
+            hdf5->plist = H5Dget_create_plist(hdf5->rx_dset);
+            if (hdf5->plist < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to get plist");
+                rc = 1;
+                goto out;
+            }
+            rx_ndims = H5Sget_simple_extent_dims(hdf5->rx_dspace,
+                                                 hdf5->rx_dims,
+                                                 NULL);
+            if (rx_ndims < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to get rx_ndims");
+                rc = 1;
+                goto out;
+            }
+            num_attrs = H5Aget_num_attrs(hdf5->rx_dset);
+            if (num_attrs < 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to get num attrs");
+                rc = 1;
+                goto out;
+            }
+            if (num_attrs > 0) {
+                rc = cont_deserialize_recx(hdf5, oh, diov,
+                                           num_attrs, ak_off, k);
+                if (rc != 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to deserialize recx");
+                    rc = 1;
+                    goto out;
+                }
+            } else {
+                memset(&sgl, 0, sizeof(sgl));
+                memset(&iov, 0, sizeof(iov));
+                memset(&iod, 0, sizeof(iod));
+                single_tsize = H5Tget_size(hdf5->rx_dtype);
+                if (single_tsize == 0) {
+                    rc = 1;
+                    MFU_LOG(MFU_LOG_ERR, "failed to get size of type in single "
+                                         "record datatype");
+                }
+                single_data = MFU_CALLOC(1, single_tsize);
+                if (single_data == NULL) {
+                    rc = ENOMEM;
+                    goto out;
+                }
+                status = H5Dread(hdf5->rx_dset, hdf5->rx_dtype,
+                                 H5S_ALL, hdf5->rx_dspace,
+                                 H5P_DEFAULT, single_data);
+                if (status < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to read record");
+                    rc = 1;
+                    goto out;
+                }
+
+                /* set iod values */
+                iod.iod_type  = DAOS_IOD_SINGLE;
+                iod.iod_size  = single_tsize;
+                iod.iod_nr    = 1;
+                iod.iod_recxs = NULL;
+                iod.iod_name  = aiov;
+
+                /* set sgl values */
+                sgl.sg_nr     = 1;
+                sgl.sg_nr_out = 0;
+                sgl.sg_iovs   = &iov;
+
+                d_iov_set(&iov, single_data, single_tsize);
+
+                /* update fetched recx values and place in destination object */
+                rc = daos_obj_update(*oh, DAOS_TX_NONE, 0,
+                                     &diov, 1, &iod, &sgl, NULL);
+                if (rc != 0) {
+                    MFU_LOG(MFU_LOG_ERR, "failed to update object: "DF_RC, DP_RC(rc));
+                    goto out;
+                }
+
+                mfu_free(&single_data);
+            }
+            H5Pclose(hdf5->plist);  
+            H5Tclose(hdf5->rx_dtype);   
+            H5Sclose(hdf5->rx_dspace);  
+            H5Dclose(hdf5->rx_dset);    
+        }
+    }
+out:
+    mfu_free(&single_data);
+    return rc;
+}
+
+static int cont_deserialize_prop_str(struct hdf5_args* hdf5,
+                                     struct daos_prop_entry* entry,
+                                     const char* prop_str)
+{
+    hid_t   status = 0;
+    int     rc = 0;
+
+    hdf5->cont_attr = H5Aopen(hdf5->file, prop_str, H5P_DEFAULT);
+    if (hdf5->cont_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dtype = H5Aget_type(hdf5->cont_attr);
+    if (hdf5->attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open property attribute type %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    size_t buf_size = H5Tget_size(hdf5->attr_dtype);
+    if (buf_size <= 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get size for property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    entry->dpe_str = MFU_CALLOC(1, buf_size);
+    if (entry->dpe_str == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    status = H5Aread(hdf5->cont_attr, hdf5->attr_dtype, entry->dpe_str);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    status = H5Aclose(hdf5->cont_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+
+out:
+    return rc;
+}
+
+static int cont_deserialize_prop_uint(struct hdf5_args* hdf5,
+                                      struct daos_prop_entry* entry,
+                                      const char* prop_str)
+{
+    hid_t   status = 0;
+    int     rc = 0;
+
+    hdf5->cont_attr = H5Aopen(hdf5->file, prop_str, H5P_DEFAULT);
+    if (hdf5->cont_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dtype = H5Aget_type(hdf5->cont_attr);
+    if (hdf5->attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open property attribute type %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    status = H5Aread(hdf5->cont_attr, hdf5->attr_dtype, &entry->dpe_val);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    status = H5Aclose(hdf5->cont_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+
+out:
+    return rc;
+}
+
+static int cont_deserialize_prop_acl(struct hdf5_args* hdf5,
+                                     struct daos_prop_entry* entry,
+                                     const char* prop_str)
+{
+    hid_t           status = 0;
+    int             rc = 0;
+    int             i = 0;
+    int             ndims = 0;
+    const char      **rdata = NULL;
+    struct daos_acl *acl;
+
+    hdf5->cont_attr = H5Aopen(hdf5->file, prop_str, H5P_DEFAULT);
+    if (hdf5->cont_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dtype = H5Aget_type(hdf5->cont_attr);
+    if (hdf5->attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open property attribute type %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    hdf5->attr_dspace = H5Aget_space(hdf5->cont_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read acl dspace");
+        rc = 1;
+        goto out;
+    }
+    ndims = H5Sget_simple_extent_dims(hdf5->attr_dspace, hdf5->attr_dims, NULL);
+    if (ndims < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get dimensions of dspace");
+        rc = 1;
+        goto out;
+    }
+    rdata = MFU_CALLOC(hdf5->attr_dims[0], sizeof(char*));
+    if (rdata == NULL) {
+        rc = ENOMEM;
+        goto out;
+    }
+    hdf5->attr_dtype = H5Tcopy(H5T_C_S1);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to create dtype");
+        rc = 1;
+        goto out;
+    }
+    status = H5Tset_size(hdf5->attr_dtype, H5T_VARIABLE);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to set acl dtype size");
+        rc = 1;
+        goto out;
+    }
+    status = H5Aread(hdf5->cont_attr, hdf5->attr_dtype, rdata);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+    /* convert acl strings back to struct acl, then store in entry */
+    rc = daos_acl_from_strs(rdata, (size_t)hdf5->attr_dims[0], &acl);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to convert acl strs");
+        goto out;
+    }
+    entry->dpe_val_ptr = (void*)acl;
+    status = H5Aclose(hdf5->cont_attr);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to close property attribute %s", prop_str);
+        rc = 1;
+        goto out;
+    }
+out:
+    mfu_free(&rdata);
+    return rc;
+}
+
+static int cont_deserialize_usr_attrs(struct hdf5_args* hdf5,
+                                      daos_handle_t coh)
+{
+    hid_t       status = 0;
+    int         rc = 0;
+    int         num_attrs = 0;
+    int         num_dims = 0;
+    char**      names = NULL;
+    void**      buffers = NULL;
+    size_t*     sizes = NULL;
+    hid_t       dset = 0;
+    hid_t       dspace = 0;
+    hid_t       vtype = 0;
+    hsize_t     dims[1];
+    usr_attr_t* attr_data = NULL;
+
+    /* Read the user attributes */
+    dset= H5Dopen(hdf5->file, "User Attributes", H5P_DEFAULT);
+    if (dset < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open user attributes dset");
+        rc = 1;
+        goto out;
+    }
+    dspace = H5Dget_space(dset);
+    if (dspace < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get user attributes dspace");
+        rc = 1;
+        goto out;
+    }
+    vtype = H5Dget_type(dset);
+    if (vtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get user attributes vtype");
+        rc = 1;
+        goto out;
+    }
+    num_dims = H5Sget_simple_extent_dims(dspace, dims, NULL);
+    if (num_dims < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get user attributes dimensions");
+        rc = 1;
+        goto out;
+    }
+    num_attrs = dims[0];
+    attr_data = MFU_CALLOC(dims[0], sizeof(usr_attr_t));
+    if (attr_data == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attributes");
+        rc = 1;
+        goto out;
+    }
+    status = H5Dread(dset, vtype, H5S_ALL, H5S_ALL,
+                     H5P_DEFAULT, attr_data);
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read user attributes data");
+        rc = 1;
+        goto out;
+    }
+
+    names = MFU_CALLOC(num_attrs, sizeof(char*));
+    if (names == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attributes");
+        rc = 1;
+        goto out;
+    }
+    buffers = MFU_CALLOC(num_attrs, sizeof(void*));
+    if (buffers == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attributes");
+        rc = 1;
+        goto out;
+    }
+    sizes = MFU_CALLOC(num_attrs, sizeof(size_t));
+    if (sizes == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "failed to allocate user attributes");
+        rc = 1;
+        goto out;
+    }
+
+    /* Set the user attribute buffers */
+    MFU_LOG(MFU_LOG_INFO, "num_attrs = %llu", num_attrs);
+    for (int i = 0; i < num_attrs; i++) {
+        MFU_LOG(MFU_LOG_INFO, "attr_data[%llu].attr_name = %s", i, attr_data[i].attr_name);
+        MFU_LOG(MFU_LOG_INFO, "attr_data[%llu].attr_val.p = %s", i, attr_data[i].attr_val.p);
+        MFU_LOG(MFU_LOG_INFO, "attr_data[%llu].attr_val.len = %llu", i, attr_data[i].attr_val.len);
+        names[i] = attr_data[i].attr_name;
+        buffers[i] = attr_data[i].attr_val.p;
+        sizes[i] = attr_data[i].attr_val.len;
+    }
+
+    rc = daos_cont_set_attr(coh, num_attrs,
+                            (const char * const*) names,
+                            (const void * const*) buffers,
+                            sizes, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to set user attributes "DF_RC, DP_RC(rc));
+        rc = 1;
+        goto out;
+    }
+
+out:
+    H5Dclose(dset);
+    H5Sclose(dspace);
+    H5Tclose(vtype);
+    cont_free_usr_attrs(num_attrs, &names, &buffers, &sizes);
+    mfu_free(&attr_data);
+    return rc;
+}
+
+static int cont_deserialize_all_props(struct hdf5_args *hdf5, daos_prop_t *prop, 
+                                      struct daos_prop_entry *entry,
+                                      daos_cont_layout_t *cont_type)
+{
+    int rc = 0;
+
+    prop = daos_prop_alloc(17);
+    if (prop == NULL) {
+        return ENOMEM;
+    }
+
+    prop->dpp_entries[0].dpe_type = DAOS_PROP_CO_LABEL; 
+    prop->dpp_entries[1].dpe_type = DAOS_PROP_CO_LAYOUT_TYPE;
+    prop->dpp_entries[2].dpe_type = DAOS_PROP_CO_LAYOUT_VER;
+    prop->dpp_entries[3].dpe_type = DAOS_PROP_CO_CSUM;
+    prop->dpp_entries[4].dpe_type = DAOS_PROP_CO_CSUM_CHUNK_SIZE;
+    prop->dpp_entries[5].dpe_type = DAOS_PROP_CO_CSUM_SERVER_VERIFY;
+    prop->dpp_entries[6].dpe_type = DAOS_PROP_CO_REDUN_FAC;
+    prop->dpp_entries[7].dpe_type = DAOS_PROP_CO_REDUN_LVL;
+    prop->dpp_entries[8].dpe_type = DAOS_PROP_CO_SNAPSHOT_MAX;
+    prop->dpp_entries[9].dpe_type = DAOS_PROP_CO_COMPRESS;
+    prop->dpp_entries[10].dpe_type = DAOS_PROP_CO_ENCRYPT;
+    prop->dpp_entries[11].dpe_type = DAOS_PROP_CO_OWNER;
+    prop->dpp_entries[12].dpe_type = DAOS_PROP_CO_OWNER_GROUP;
+    prop->dpp_entries[13].dpe_type = DAOS_PROP_CO_DEDUP;
+    prop->dpp_entries[14].dpe_type = DAOS_PROP_CO_DEDUP_THRESHOLD;
+    prop->dpp_entries[15].dpe_type = DAOS_PROP_CO_ALLOCED_OID;
+    prop->dpp_entries[16].dpe_type = DAOS_PROP_CO_ACL;
+
+    entry = &prop->dpp_entries[0];
+    rc = cont_deserialize_prop_str(hdf5, entry, "DAOS_PROP_CO_LABEL");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[1];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_LAYOUT_TYPE");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[2];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_LAYOUT_VER");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[3];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_CSUM");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[4];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_CSUM_CHUNK_SIZE");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[5];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_CSUM_SERVER_VERIFY");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[6];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_REDUN_FAC");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[7];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_REDUN_LVL");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[8];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_SNAPSHOT_MAX");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[9];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_COMPRESS");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[10];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ENCRYPT");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[11];
+    rc = cont_deserialize_prop_str(hdf5, entry, "DAOS_PROP_CO_OWNER");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[12];
+    rc = cont_deserialize_prop_str(hdf5, entry, "DAOS_PROP_CO_OWNER_GROUP");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[13];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_DEDUP");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[14];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_DEDUP_THRESHOLD");
+    if (rc != 0) {
+        goto out;
+    }
+
+    entry = &prop->dpp_entries[15];
+    rc = cont_deserialize_prop_uint(hdf5, entry, "DAOS_PROP_CO_ALLOCED_OID");
+    if (rc != 0) {
+        goto out;
+    }
+
+    /* TODO fetch ACL into a different prop and merge the two props
+     * only if the ACL succeeds. Otherwise, if the ACL fails, the entry will
+     * be invalid/NULL */
+    /* Ignore missing ACL in case user didn't have access when serializing */
+    entry = &prop->dpp_entries[16];
+    /* read acl as a list of strings in deserialize, then convert
+     * back to acl for property entry
+     */
+    rc = cont_deserialize_prop_acl(hdf5, entry, "DAOS_PROP_CO_ACL");
+    if (rc != 0) {
+        goto out;
+    }
+    *cont_type = prop->dpp_entries[1].dpe_val;
+out:
+    return rc;
+}
+
+/* on rank 0, connect to pool, read cont properties because
+ * MAX_OID can only works if set on container creation,
+ * and then broadcast handles to all ranks */
+int daos_cont_deserialize_connect(daos_args_t *daos_args,
+                                  struct hdf5_args *hdf5,
+                                  daos_prop_t *prop,
+                                  daos_cont_layout_t *cont_type,
+                                  struct daos_prop_entry *entry)
+{
+    int rc = 0;
+
+    /* generate container UUID */
+    uuid_generate(daos_args->src_cont_uuid);
+
+    daos_pool_info_t pool_info = {0};
+    daos_cont_info_t co_info = {0};
+#if DAOS_API_VERSION_MAJOR < 1
+    rc = daos_pool_connect(daos_args->src_pool_uuid, NULL, NULL, DAOS_PC_RW,
+                           &daos_args->src_poh, &pool_info, NULL);
+#else
+    rc = daos_pool_connect(daos_args->src_pool_uuid, NULL, DAOS_PC_RW,
+                           &daos_args->src_poh, &pool_info, NULL);
+#endif
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to connect to pool");
+        goto out;
+    }
+
+    /* need to read cont props before creating container, then
+     * broadcast handles to the rest of the ranks */
+    rc = cont_deserialize_all_props(hdf5, prop, entry, cont_type);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to deserialize container properties");
+        goto out;
+    }
+
+    if (*cont_type == DAOS_PROP_CO_LAYOUT_POSIX) {
+        dfs_attr_t attr;
+        attr.da_id = 0;
+        attr.da_props = prop;
+        attr.da_oclass_id = OC_UNKNOWN; /* TODO serialize this? */
+        attr.da_chunk_size = 0; /* TODO serialize this? */
+        rc = dfs_cont_create(daos_args->src_poh, daos_args->src_cont_uuid, &attr, NULL, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to create posix container: %d", rc);
+            goto out;
+        }
+    } else {
+        rc = daos_cont_create(daos_args->src_poh, daos_args->src_cont_uuid, prop, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to create container: %d", rc);
+            goto out;
+        }
+    }
+
+    char cont_str[130];
+    uuid_unparse(daos_args->src_cont_uuid, cont_str);
+    fprintf(stdout, "Successfully created container %s\n", cont_str);
+    rc = daos_cont_open(daos_args->src_poh, daos_args->src_cont_uuid,
+                        DAOS_COO_RW, &daos_args->src_coh, &co_info, NULL);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open container: %d", rc);
+        goto out;
+    }
+    daos_prop_free(prop);
+out:
+    return rc;
+}
+
+int daos_cont_deserialize_hdlr(int rank, daos_args_t *da, const char *h5filename)
+{
+    int                     rc = 0;
+    int                     i = 0;
+    daos_cont_info_t        cont_info;
+    struct                  hdf5_args hdf5;
+    daos_obj_id_t           oid;
+    daos_handle_t           oh;
+    uint64_t                dk_off = 0;
+    uint64_t                dk_next = 0;
+    uint64_t                total_dkeys_this_oid = 0;
+    hid_t                   status = 0;
+    float                   version;
+    daos_cont_layout_t      cont_type;
+    daos_prop_t*            prop;
+    struct daos_prop_entry  *entry;
+
+    /* init HDF5 args */
+    init_hdf5_args(&hdf5);
+
+    printf("\tDeserializing filename: %s\n", h5filename);
+
+    /* open passed in HDF5 file */
+    hdf5.file = H5Fopen(h5filename, H5F_ACC_RDONLY, H5P_DEFAULT);
+    if (hdf5.file < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open hdf5 file");
+        rc = 1;
+        goto out;
+    }
+
+    /* deserialize version -- serialization version/format should
+     * be compatible with deserialization version
+     */
+    hdf5.version_attr = H5Aopen(hdf5.file, "Version", H5P_DEFAULT);
+    if (hdf5.version_attr < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to open version attr");
+        rc = 1;
+        goto out;
+    }
+    hdf5.attr_dtype = H5Aget_type(hdf5.version_attr);
+    if (hdf5.attr_dtype < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to get attr type");
+        rc = 1;
+        goto out;
+    }
+    status = H5Aread(hdf5.version_attr, hdf5.attr_dtype, &version); 
+    if (status < 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read version");
+        rc = 1;
+        goto out;
+    }
+    if (version > 0.0) {
+        MFU_LOG(MFU_LOG_ERR, "serialization format is not compatible with "
+                "deserialization version\n");
+        rc = 1;
+        goto out;
+    }
+
+    /* deserialize and set the user attributes if they exist */
+    htri_t usr_attrs_exist = H5Lexists(hdf5.file, "User Attributes", H5P_DEFAULT);
+    if (usr_attrs_exist > 0) {
+        rc = cont_deserialize_usr_attrs(&hdf5, da->src_coh);
+        if (rc != 0) {
+            rc = 1;
+            goto out;
+        }
+    }
+
+    rc = hdf5_read_key_data(&hdf5);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "failed to read hdf5 key data");
+        rc = 1;
+        goto out;
+    }
+    
+    for (i = 0; i < (int)hdf5.oid_dims[0]; i++) {
+        oid.lo = hdf5.oid_data[i].oid_low;
+        oid.hi = hdf5.oid_data[i].oid_hi;
+        rc = daos_obj_open(da->src_coh, oid, 0, &oh, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to open object: %d", rc);
+            goto out;
+        }
+        dk_off = hdf5.oid_data[i].dkey_offset;
+        dk_next = 0;
+        total_dkeys_this_oid = 0;
+        if (i + 1 < (int)hdf5.oid_dims[0]) {
+            dk_next = hdf5.oid_data[i + 1].dkey_offset;
+            total_dkeys_this_oid = dk_next - dk_off;
+        } else if (i == ((int)hdf5.oid_dims[0] - 1)){
+            total_dkeys_this_oid = (int)hdf5.dkey_dims[0] - (dk_off);
+        } 
+        rc = cont_deserialize_keys(&hdf5, &total_dkeys_this_oid, &dk_off, &oh);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to deserialize keys: %d", rc);
+            goto out;
+        }
+        rc = daos_obj_close(oh, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to close object: %d", rc);
+            goto out;
+        }
+    }
+out:
+    if (hdf5.oid_dset > 0) {
+        H5Dclose(hdf5.oid_dset);
+    }
+    if (hdf5.dkey_dset > 0) {
+        H5Dclose(hdf5.dkey_dset);
+    }
+    if (hdf5.akey_dset > 0) {
+        H5Dclose(hdf5.akey_dset);
+    }
+    if (hdf5.oid_dspace > 0) {
+        H5Sclose(hdf5.oid_dspace);
+    }
+    if (hdf5.dkey_dspace > 0) {
+        H5Sclose(hdf5.dkey_dspace);
+    }
+    if (hdf5.akey_dspace > 0) {
+        H5Sclose(hdf5.akey_dspace);
+    }
+    if (hdf5.oid_dtype > 0) {
+        H5Tclose(hdf5.oid_dtype);
+    }
+    if (hdf5.dkey_vtype > 0) {
+        H5Tclose(hdf5.dkey_vtype);
+    }
+    if (hdf5.akey_vtype > 0) {
+        H5Tclose(hdf5.akey_vtype);
+    }
+    if (hdf5.file > 0) {
+        H5Fclose(hdf5.file);
+    }
+    return rc;
+}
+#endif
diff --git a/src/common/mfu_daos.h b/src/common/mfu_daos.h
index 454ee04..72a2093 100644
--- a/src/common/mfu_daos.h
+++ b/src/common/mfu_daos.h
@@ -1,12 +1,18 @@
 #include "mfu.h"
 
 #include <daos.h>
+#ifdef HDF5_SUPPORT
+#include <hdf5.h>
+#endif
 #include "mfu_flist_internal.h"
 
-#define ENUM_KEY_BUF		32 /* size of each dkey/akey */
+#define ENUM_KEY_BUF		128 /* size of each dkey/akey */
 #define ENUM_LARGE_KEY_BUF	(512 * 1024) /* 512k large key */
 #define ENUM_DESC_NR		5 /* number of keys/records returned by enum */
 #define ENUM_DESC_BUF		512 /* all keys/records returned by enum */
+#define OID_ARR_SIZE        50
+#define ATTR_NAME_LEN       64
+#define FILENAME_LEN        1024 
 
 enum handleType {
     POOL_HANDLE,
@@ -22,21 +28,113 @@ typedef enum {
 
 /* struct for holding DAOS arguments */
 typedef struct {
-    daos_handle_t src_poh; /* source pool handle */
-    daos_handle_t dst_poh; /* destination pool handle */
-    daos_handle_t src_coh; /* source container handle */
-    daos_handle_t dst_coh; /* destination container handle */
-    uuid_t src_pool_uuid;  /* source pool UUID */
-    uuid_t dst_pool_uuid;  /* destination pool UUID */
-    uuid_t src_cont_uuid;  /* source container UUID */
-    uuid_t dst_cont_uuid;  /* destination container UUID */
-    char* dfs_prefix;      /* prefix for UNS */
-    char* src_path;        /* allocated src path */
-    char* dst_path;        /* allocated dst path */
-    daos_api_t api;        /* API to use */
-    daos_epoch_t epc;      /* src container epoch */
+    daos_handle_t src_poh;  /* source pool handle */
+    daos_handle_t dst_poh;  /* destination pool handle */
+    daos_handle_t src_coh;  /* source container handle */
+    daos_handle_t dst_coh;  /* destination container handle */
+    uuid_t src_pool_uuid;   /* source pool UUID */
+    uuid_t dst_pool_uuid;   /* destination pool UUID */
+    uuid_t src_cont_uuid;   /* source container UUID */
+    uuid_t dst_cont_uuid;   /* destination container UUID */
+    char* dfs_prefix;       /* prefix for UNS */
+    char* src_path;         /* allocated src path */
+    char* dst_path;         /* allocated dst path */
+    daos_api_t api;         /* API to use */
+    daos_epoch_t src_epc;   /* src container epoch */
+    daos_epoch_t dst_epc;   /* dst container epoch */
+    bool allow_exist_dst_cont;          /* whether to allow the dst container to exist for DAOS API */
+    enum daos_cont_props src_cont_type; /* type of the source container */
+    enum daos_cont_props dst_cont_type; /* type of the destination container */
 } daos_args_t;
 
+#ifdef HDF5_SUPPORT
+/* for user attr dataset */
+typedef struct {
+    char* attr_name;
+    hvl_t attr_val;
+} usr_attr_t;
+
+/* for oid dataset */
+typedef struct {
+	uint64_t oid_hi;
+	uint64_t oid_low;
+	uint64_t dkey_offset;
+} oid_t;
+
+/* for dkey dataset */
+typedef struct {
+	/* array of vlen structure */
+	hvl_t dkey_val;
+	uint64_t akey_offset;
+} dkey_t;
+
+/* for akey dataset */
+typedef struct {
+	/* array of vlen structure */
+	hvl_t akey_val;
+	uint64_t rec_dset_id;
+} akey_t;
+
+struct hdf5_args {
+    hid_t status;
+    hid_t file;
+    /* User attribute data */
+    hid_t usr_attr_memtype;
+    hid_t usr_attr_name_vtype;
+    hid_t usr_attr_val_vtype;
+    /* OID Data */
+    hid_t oid_memtype;
+    hid_t oid_dspace;
+    hid_t oid_dset;
+    hid_t oid_dtype;
+    /* DKEY Data */
+    hid_t dkey_memtype;
+    hid_t dkey_vtype;
+    hid_t dkey_dspace;
+    hid_t dkey_dset;
+    /* AKEY Data */
+    hid_t akey_memtype;
+    hid_t akey_vtype;
+    hid_t akey_dspace;
+    hid_t akey_dset;
+    /* recx Data */
+    hid_t plist;
+    hid_t rx_dspace;
+    hid_t rx_memspace;
+    hid_t attr_dspace;
+    hid_t attr_dtype;
+    hid_t rx_dset;
+    hid_t single_dspace;
+    hid_t single_dset;
+    hid_t rx_dtype;
+    hid_t usr_attr;
+    hid_t cont_attr;
+    hid_t selection_attr;
+    hid_t version_attr;
+    hid_t single_dtype;
+    hid_t version_attr_dspace;
+    hid_t version_attr_type;
+    /* dims for dsets */
+    hsize_t oid_dims[1];
+    hsize_t dkey_dims[1];     
+    hsize_t akey_dims[1];     
+    hsize_t rx_dims[1];
+    hsize_t mem_dims[1];
+    hsize_t attr_dims[1];
+    hsize_t rx_chunk_dims[1];
+    hsize_t rx_max_dims[1];
+    hsize_t single_dims[1];
+    hsize_t version_attr_dims[1];
+    /* data for keys */
+    oid_t *oid_data;
+    dkey_t *dkey_data;
+    akey_t *akey_data;
+    oid_t  **oid;
+    dkey_t **dk;
+    akey_t **ak;
+};
+#endif
+
 /* Return a newly allocated daos_args_t structure.
  * Set default values on its fields. */
 daos_args_t* daos_args_new(void);
@@ -67,6 +165,79 @@ int daos_setup(
   mfu_file_t* mfu_dst_file
 );
 
+/* parse a daos path of the form
+ * daos://pool/cont, /pool/cont/,
+ * or UNS path */
+int daos_parse_path(
+    char *path,
+    size_t path_len,
+    uuid_t *p_uuid,
+    uuid_t *c_uuid,
+    bool daos_no_prefix
+);
+
+/* connect to DAOS pool,
+ * and then open container */
+int daos_connect(
+  int rank,
+  daos_args_t* da,
+  uuid_t pool_uuid,
+  uuid_t cont_uuid,
+  daos_handle_t* poh,
+  daos_handle_t* coh,
+  bool connect_pool,
+  bool create_cont,
+  bool require_new_cont
+);
+
+/* broadcast a pool or cont handle
+ * from rank 0 */
+void daos_bcast_handle(
+    int rank,
+    daos_handle_t* handle,
+    daos_handle_t* poh,
+    enum handleType type
+);
+
+/* serialize a container to
+ * an HDF5 file */
+int daos_cont_serialize_hdlr(
+    int rank,
+    struct hdf5_args *hdf5,
+    char *output_dir,
+    uint64_t *files_written,
+    daos_args_t *da,
+    mfu_flist flist,
+    uint64_t num_oids
+);
+
+/* serialize a container to
+ * an HDF5 file */
+int daos_cont_deserialize_hdlr(
+    int rank,
+    daos_args_t *da,
+    const char *h5filename
+);
+
+/* connect to pool, read cont properties because
+ * MAX_OID can only works if set on container creation,
+ * and then broadcast handles to all ranks */
+int daos_cont_deserialize_connect(
+    daos_args_t *daos_args,
+    struct hdf5_args *hdf5,
+    daos_prop_t *prop,
+    daos_cont_layout_t *cont_type,
+    struct daos_prop_entry *entry
+);
+
+/* serialize the number of hdf5 files generated by
+ * daos_cont_serialize_hdlr, this allows deserialization
+ * to check if all data is present */
+int daos_cont_serialize_files_generated(
+    struct hdf5_args *hdf5,
+    uint64_t *files_generated
+);
+
 /* Unmount DFS.
  * Disconnect from pool/cont.
  * Cleanup DAOS-related vars, handles. 
@@ -77,15 +248,20 @@ int daos_cleanup(
   mfu_file_t* mfu_dst_file
 );
 
-/* walk objects in daos and insert to given flist */
-int mfu_flist_walk_daos(
+/* Walk objects in daos and insert to given flist.
+ * Returns -1 on failure, 0 on success. */
+int mfu_daos_flist_walk(
     daos_args_t* da,
+    daos_handle_t coh,
+    daos_epoch_t* epoch,
     mfu_flist flist
 );
 
-/* copy objects in flist to destination listed in daos args,
+/* copy/sync objects in flist to destination listed in daos args,
  * copies DAOS data at object level (non-posix) */
-int mfu_flist_copy_daos(
-    daos_args_t* da,
-    mfu_flist flist
+int mfu_daos_flist_sync(
+    daos_args_t* da,    /* DAOS args */
+    mfu_flist flist,    /* flist containing oids */
+    bool compare_dst,   /* whether to compare the dst before writing */
+    bool write_dst      /* whether to actually write to the dst */
 );
diff --git a/src/common/mfu_flist.c b/src/common/mfu_flist.c
index 772fdc2..5b2c104 100644
--- a/src/common/mfu_flist.c
+++ b/src/common/mfu_flist.c
@@ -771,6 +771,28 @@ void mfu_flist_set_detail (mfu_flist bflist, int detail)
     return;
 }
 
+uint64_t mfu_flist_file_get_oid_low(mfu_flist bflist, uint64_t idx)
+{
+    uint64_t oid_low;
+    flist_t* flist = (flist_t*) bflist;
+    elem_t* elem = list_get_elem(flist, idx);
+    if (elem != NULL) {
+        oid_low = elem->obj_id_lo;
+    }
+    return oid_low;
+}
+
+uint64_t mfu_flist_file_get_oid_high(mfu_flist bflist, uint64_t idx)
+{
+    uint64_t oid_high;
+    flist_t* flist = (flist_t*) bflist;
+    elem_t* elem = list_get_elem(flist, idx);
+    if (elem != NULL) {
+        oid_high = elem->obj_id_hi;
+    }
+    return oid_high;
+}
+
 const char* mfu_flist_file_get_name(mfu_flist bflist, uint64_t idx)
 {
     const char* name = NULL;
@@ -1011,6 +1033,20 @@ void mfu_flist_file_set_oid(mfu_flist bflist, uint64_t idx, daos_obj_id_t oid)
     }
     return;
 }
+
+void mfu_flist_file_set_cont(mfu_flist bflist, uint64_t idx, const char* name)
+{
+    flist_t* flist = (flist_t*) bflist;
+    elem_t* elem = list_get_elem(flist, idx);
+    if (elem != NULL) {
+        /* free existing name if there is one */
+        mfu_free(&elem->file);
+
+        /* set new name */
+        elem->file = MFU_STRDUP(name);
+    }
+    return;
+}
 #endif 
 
 void mfu_flist_file_set_type(mfu_flist bflist, uint64_t idx, mfu_filetype type)
diff --git a/src/common/mfu_flist.h b/src/common/mfu_flist.h
index 0cebf3f..dd02888 100644
--- a/src/common/mfu_flist.h
+++ b/src/common/mfu_flist.h
@@ -378,6 +378,8 @@ mfu_filetype mfu_flist_mode_to_filetype(mode_t mode);
 
 /* read properties on specified item in local flist */
 /* always set */
+uint64_t mfu_flist_file_get_oid_low(mfu_flist flist, uint64_t index);
+uint64_t mfu_flist_file_get_oid_high(mfu_flist flist, uint64_t index);
 const char* mfu_flist_file_get_name(mfu_flist flist, uint64_t index);
 int mfu_flist_file_get_depth(mfu_flist flist, uint64_t index);
 mfu_filetype mfu_flist_file_get_type(mfu_flist flist, uint64_t index);
@@ -403,6 +405,7 @@ const char* mfu_flist_file_get_groupname(mfu_flist flist, uint64_t index);
 /* set properties on specified item in local flist */
 #ifdef DAOS_SUPPORT
 void mfu_flist_file_set_oid(mfu_flist flist, uint64_t index, daos_obj_id_t oid);
+void mfu_flist_file_set_cont(mfu_flist flist, uint64_t index, const char* name);
 #endif
 void mfu_flist_file_set_name(mfu_flist flist, uint64_t index, const char* name);
 void mfu_flist_file_set_type(mfu_flist flist, uint64_t index, mfu_filetype type);
diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index 8a36bc9..0cca5d1 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -1036,7 +1036,7 @@ static int mfu_create_directories(
 
     /* count total number of directories to be created */
     int level;
-    uint64_t count = 0;
+    uint64_t mkdir_local_count = 0;
     for (level = 0; level < levels; level++) {
         /* get list of items for this level */
         mfu_flist list = lists[level];
@@ -1047,14 +1047,14 @@ static int mfu_create_directories(
            /* check whether we have a directory */
            mfu_filetype type = mfu_flist_file_get_type(list, idx);
            if (type == MFU_TYPE_DIR) {
-               count++;
+               mkdir_local_count++;
            }
         }
     }
 
     /* get total for print percent progress while creating */
     mkdir_total_count = 0;
-    MPI_Allreduce(&count, &mkdir_total_count, 1, MPI_UINT64_T, MPI_SUM, MPI_COMM_WORLD);
+    MPI_Allreduce(&mkdir_local_count, &mkdir_total_count, 1, MPI_UINT64_T, MPI_SUM, MPI_COMM_WORLD);
 
     /* bail early if there is no work to do */
     if (mkdir_total_count == 0) {
@@ -1489,7 +1489,7 @@ static int mfu_create_hardlinks(
 
     /* first, count number of items to create in the list of the current process */
     int level;
-    uint64_t count = 0;
+    uint64_t mknod_local_count = 0;
     for (level = 0; level < levels; level++) {
         /* get list of items for this level */
         mfu_flist list = lists[level];
@@ -1500,14 +1500,14 @@ static int mfu_create_hardlinks(
             /* count regular files */
             mfu_filetype type = mfu_flist_file_get_type(list, idx);
             if (type == MFU_TYPE_FILE) {
-                count++;
+                mknod_local_count++;
             }
         }
     }
 
     /* get total for print percent progress while creating */
     mknod_total_count = 0;
-    MPI_Allreduce(&count, &mknod_total_count, 1, MPI_UINT64_T, MPI_SUM, MPI_COMM_WORLD);
+    MPI_Allreduce(&mknod_local_count, &mknod_total_count, 1, MPI_UINT64_T, MPI_SUM, MPI_COMM_WORLD);
 
     /* bail early if there is no work to do */
     if (mknod_total_count == 0) {
diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 44f59f0..0be0fa7 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -100,6 +100,28 @@ void* mfu_malloc(size_t size, const char* file, int line)
     return NULL;
 }
 
+/* if size > 0 allocates size bytes and returns pointer,
+ * calls mfu_abort if calloc fails, returns NULL if size == 0 */
+void* mfu_calloc(size_t nelem, size_t elsize, const char* file, int line)
+{
+    /* only bother if size > 0 */
+    if (nelem > 0 && elsize > 0) {
+        /* try to allocate memory and check whether we succeeded */
+        void* ptr = calloc(nelem, elsize);
+        if (ptr == NULL) {
+            /* allocate failed, abort */
+            mfu_abort(file, line, 1, "Failed to allocate %llu * %llu bytes. Try using more nodes.",
+                        (unsigned long long) nelem, (unsigned long long) elsize
+                       );
+        }
+
+        /* return the pointer */
+        return ptr;
+    }
+
+    return NULL;
+}
+
 /* if size > 0, allocates size bytes aligned with specified alignment
  * and returns pointer, calls mfu_abort on failure,
  * returns NULL if size == 0 */
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index d6f94dd..dcc32e5 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -131,6 +131,16 @@ void* mfu_malloc(
   int line
 );
 
+/* if size > 0 allocates size bytes and returns pointer,
+ * calls mfu_abort if calloc fails, returns NULL if size == 0 */
+#define MFU_CALLOC(X, Y) mfu_calloc(X, Y, __FILE__, __LINE__)
+void* mfu_calloc(
+  size_t nelem,
+  size_t elsize,
+  const char* file,
+  int line
+);
+
 /* if size > 0, allocates size bytes aligned with specified alignment
  * and returns pointer, calls mfu_abort on failure,
  * returns NULL if size == 0 */
diff --git a/src/daos-deserialize/CMakeLists.txt b/src/daos-deserialize/CMakeLists.txt
new file mode 100644
index 0000000..84e5cf1
--- /dev/null
+++ b/src/daos-deserialize/CMakeLists.txt
@@ -0,0 +1 @@
+MFU_ADD_TOOL(daos-deserialize)
diff --git a/src/daos-deserialize/daos-deserialize.c b/src/daos-deserialize/daos-deserialize.c
new file mode 100644
index 0000000..9cba335
--- /dev/null
+++ b/src/daos-deserialize/daos-deserialize.c
@@ -0,0 +1,408 @@
+#include <stdio.h>
+#include <getopt.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdbool.h>
+
+/* for daos */
+#include "mfu_daos.h"
+#include "mpi.h"
+#include "mfu.h"
+
+#include "mfu_errors.h"
+
+/** Print a usage message. */
+void print_usage(void)
+{
+    printf("\n");
+    printf("Usage: daos-deserialize [options] [<h5file> <h5file> ...] || [</path/to/dir>]\n");
+    printf("\n");
+    printf("Options:\n");
+    printf("  -p, --pool               - pool uuid for containers\n");
+    printf("  -v, --verbose            - verbose output\n");
+    printf("  -q, --quiet              - quiet output\n");
+    printf("  -h, --help               - print usage\n");
+    printf("For more information see https://mpifileutils.readthedocs.io.\n");
+    printf("\n");
+    fflush(stdout);
+}
+
+/* if a directory is passed in we need to count the files in it,
+ * and read them into the paths array */
+static int count_files(char **argpaths, char ***paths, int *numpaths) {
+    int         rc = 0;
+    int         i;
+    struct stat statbuf;
+    int         num_files = 0;
+
+    rc = stat(argpaths[0], &statbuf);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to stat input file"
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
+        rc = 1;
+        goto out;
+    }
+
+    if (S_ISDIR(statbuf.st_mode)) {
+        DIR *dir;
+        struct dirent *entry;
+
+        /* set a max paths so that we do not 
+         * have to read directory twice,
+         * once to get number of files, and
+         * once to copy/save strings to paths array */
+        int max_paths = 1024;
+
+        /* use paths instead of argpaths in case directory is used */
+        *paths = MFU_MALLOC(max_paths * sizeof(char*));
+        if (*paths == NULL) {
+            rc = ENOMEM;
+            goto out;
+        }
+
+        dir = opendir(argpaths[0]);
+        if (dir == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to open directory"
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
+            rc = 1;
+            goto out;
+        }
+
+        while((entry = readdir(dir)) != NULL) {
+            /* don't count or copy into paths array if this
+             * is not a regular file */
+            struct stat stbuf;
+            int len;
+            char name[FILENAME_LEN];
+            len = snprintf(name, FILENAME_LEN, "%s/%s", argpaths[0],
+                           entry->d_name);
+            if (len >= FILENAME_LEN) {
+                MFU_LOG(MFU_LOG_ERR, "filename is too long");
+                rc = 1;
+                goto out;
+            }
+            rc = stat(name, &stbuf);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "failed to stat path: %s", name);
+                rc = 1;
+                goto out;
+            }
+            if (S_ISREG(stbuf.st_mode)) {   
+                char *path = MFU_STRDUP(name);
+                if (path == NULL) {
+                    rc = ENOMEM;
+                    goto out;
+                }
+                (*paths)[num_files] = strdup(name);
+                mfu_free(&path);
+                num_files++;
+                if (num_files > max_paths) {
+                    /* TODO: maybe there is a better way to handle this..
+                     * possibly moving over to libcircle might avoid
+                     * having to set a maximum for the number of files
+                     * deserialized from one directory */
+                    MFU_LOG(MFU_LOG_ERR, "number of files exceeds max number "
+                            "allowed, aborting");
+                    rc = 1;
+                    goto out;
+                }
+            } else {
+                continue;
+            }
+        }
+        *numpaths = num_files;
+        closedir(dir);
+    } else {
+        /* use paths instead of argpaths in case directory is used */
+        *paths = MFU_MALLOC(*numpaths * sizeof(char*));
+        if (*paths == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to allocate paths.");
+            rc = 1;
+            goto out;
+        }
+
+        num_files = *numpaths;
+        for (i = 0; i < *numpaths; i++) {
+            (*paths)[i] = MFU_STRDUP(argpaths[i]);
+            if ((*paths)[i] == NULL) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to allocate paths.");
+                rc = 1;
+                goto out;
+            }
+        }
+    }
+out:
+    if (rc != 0) {
+        if (*paths != NULL) {
+            for (i = 0; i < num_files; i++) {
+                mfu_free(&(*paths)[i]); // TODO check this pointer handling
+            }
+            mfu_free(paths);
+        }
+    }
+    return rc;
+}
+
+int main(int argc, char** argv)
+{
+    /* assume we'll exit with success */
+    int rc = 0;
+
+    /* initialize MPI */
+    MPI_Init(&argc, &argv);
+    mfu_init();
+
+    /* get our rank */
+    int rank;
+    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
+
+    /* verbose by default */
+    mfu_debug_level = MFU_LOG_VERBOSE;
+
+    int option_index = 0;
+    static struct option long_options[] = {
+        {"pool"                 , required_argument , 0, 'p'},
+        {"verbose"              , no_argument       , 0, 'v'},
+        {"quiet"                , no_argument       , 0, 'q'},
+        {"help"                 , no_argument       , 0, 'h'},
+        {0                      , 0                 , 0,  0 }
+    };
+
+    /* Parse options */
+    unsigned long long bytes = 0;
+
+    /* DAOS vars */ 
+    daos_args_t* daos_args = daos_args_new();    
+
+    int usage = 0;
+    while(1) {
+        int c = getopt_long(
+                    argc, argv, "p:vqh",
+                    long_options, &option_index
+                );
+
+        if (c == -1) {
+            break;
+        }
+
+        switch(c) {
+            case 'p':
+                uuid_parse(optarg, daos_args->src_pool_uuid);
+                break;
+            case 'v':
+                mfu_debug_level = MFU_LOG_VERBOSE;
+                break;
+            case 'q':
+                mfu_debug_level = MFU_LOG_NONE;
+                break;
+            case 'h':
+                usage = 1;
+                break;
+            case '?':
+                usage = 1;
+                break;
+            default:
+                if(rank == 0) {
+                    printf("?? getopt returned character code 0%o ??\n", c);
+                }
+        }
+    }
+
+    /* If we need to print the usage
+     * then do so before internal processing */
+    if (usage) {
+        if (rank == 0) {
+            print_usage();
+        }
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    int tmp_rc;
+    char** argpaths = (&argv[optind]);
+
+    /* The remaining arguments are treated as src/dst paths */
+    int numpaths = argc - optind;
+
+    /* advance to next set of options */
+    optind += numpaths;
+
+    if (numpaths < 1 || uuid_is_null(daos_args->src_pool_uuid)) {
+        MFU_LOG(MFU_LOG_ERR, "At least one file or directory and "
+                "a pool UUID is required:"
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    /* create an empty file list */
+    mfu_flist tmplist = mfu_flist_new();
+
+    rc = daos_init();
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to initialize daos");
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    /* TODO: I think maybe this can be adjusted to use
+     * libcircle in the case that a user specifies
+     * a directory, it could only add regular files
+     * though, so i am not sure how easy/hard this
+     * would be. I am concerned about the case where
+     * there are thousands of larger files in one directory.
+     * It would be nice if multiple ranks were counting/adding
+     * to the flist. We may also be able to avoid the 
+     * mfu_flist_spread since if we can use libcircle then
+     * each rank can process a file as it receives work,
+     * instead of gathering the work on rank 0 first */
+    if (rank == 0) {
+        uint64_t                files_generated = 0;
+        hid_t                   status;
+        struct                  hdf5_args hdf5;
+        daos_prop_t             *prop = NULL;
+        daos_cont_layout_t      cont_type;
+        struct daos_prop_entry  *entry = NULL;
+
+        char **paths = NULL;
+
+        /* if a directory is given then count and store paths */
+        rc = count_files(argpaths, &paths, &numpaths);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to count files");
+            daos_fini();
+            mfu_finalize();
+            MPI_Finalize();
+            return 1;
+        }
+        
+        /* make sure the number of files generated on serialization
+         * matches the number of files passed into the deserialization
+         * grab the first file, since each file stores this attribute */
+        hdf5.file = H5Fopen(paths[0], H5F_ACC_RDONLY, H5P_DEFAULT);
+        if (hdf5.file < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to open file");
+            rc = 1;
+        }
+
+        hid_t files_gen_attr = H5Aopen(hdf5.file, "Files Generated", H5P_DEFAULT);
+        if (files_gen_attr < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to open files generated attr");
+            rc = 1;
+        }
+
+        hid_t attr_dtype = H5Aget_type(files_gen_attr);
+        if (attr_dtype < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get attr type");
+            rc = 1;
+        }
+
+        status = H5Aread(files_gen_attr, attr_dtype, &files_generated); 
+        if (status < 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to read files generated");
+            rc = 1;
+        }
+
+        if (files_generated != numpaths) {
+            MFU_LOG(MFU_LOG_ERR, "number of files for deserialization does "
+                                 "not match number of files generated during "
+                                 "serialization, contianer data is missing\n");
+            rc = 1;
+        }
+
+        int i;
+        for (i = 0; i < numpaths; i++) {
+            uint64_t idx = mfu_flist_file_create(tmplist);
+            mfu_flist_file_set_cont(tmplist, idx, paths[i]);
+        }
+
+        tmp_rc = daos_cont_deserialize_connect(daos_args, &hdf5, prop,
+                                               &cont_type, entry);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to connect to container\n");
+            rc = 1;
+        }
+
+        for (i = 0; i < numpaths; i++) {
+            mfu_free(&paths[i]);
+        }
+        mfu_free(&paths);
+
+        /* close hdf5 */
+        H5Fclose(hdf5.file);
+        H5Aclose(files_gen_attr);
+        H5Tclose(attr_dtype);
+    }
+
+    /* use rank 0's paths, and spread them evenly among ranks
+     * Each "path" is an HDF5 file */
+    mfu_flist_summarize(tmplist);
+    mfu_flist newflist = mfu_flist_spread(tmplist);
+
+    /* get size of local list for each rank */
+    uint64_t size = mfu_flist_size(newflist);
+
+    /* broadcast rank 0's pool and cont handle to everyone else */
+    daos_bcast_handle(rank, &daos_args->src_poh, &daos_args->src_poh, POOL_HANDLE); 
+    daos_bcast_handle(rank, &daos_args->src_coh, &daos_args->src_poh, CONT_HANDLE); 
+
+    /* connect to each pool/cont in local list, then serialize */
+    int i;
+    for (i = 0; i < size; i++) {
+        const char *path = mfu_flist_file_get_name(newflist, i);
+
+        /* deserialize this hdf5 file to a DAOS container */
+        tmp_rc = daos_cont_deserialize_hdlr(rank, daos_args, path);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to deserialize container (%d)", rc);
+            rc = 1;
+        }
+    }
+
+    mfu_flist_free(&newflist);
+
+    /* don't close anything until all ranks are done using handles */
+    MPI_Barrier(MPI_COMM_WORLD);
+
+    tmp_rc = daos_cont_close(daos_args->src_coh, NULL);
+    MPI_Barrier(MPI_COMM_WORLD);
+    if (tmp_rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+        rc = 1;
+    }
+    
+    tmp_rc = daos_pool_disconnect(daos_args->src_poh, NULL);
+    MPI_Barrier(MPI_COMM_WORLD);
+    if (tmp_rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to disconnect pool (%d)", rc);
+        rc = 1;
+    }
+
+    /* Alert the user if there were copy errors */
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "One or more errors were detected while "
+                "serializing: " MFU_ERRF, MFU_ERRP(MFU_ERR_DAOS));
+    }
+
+    rc = daos_fini();
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to finalize DAOS "DF_RC, DP_RC(rc));
+    }
+
+    mfu_finalize();
+
+    /* shut down MPI */
+    MPI_Finalize();
+
+    if (rc != 0) {
+        return 1;
+    }
+    return 0;
+}
diff --git a/src/daos-serialize/CMakeLists.txt b/src/daos-serialize/CMakeLists.txt
new file mode 100644
index 0000000..3f9c9f9
--- /dev/null
+++ b/src/daos-serialize/CMakeLists.txt
@@ -0,0 +1 @@
+MFU_ADD_TOOL(daos-serialize)
diff --git a/src/daos-serialize/daos-serialize.c b/src/daos-serialize/daos-serialize.c
new file mode 100644
index 0000000..48d33d1
--- /dev/null
+++ b/src/daos-serialize/daos-serialize.c
@@ -0,0 +1,281 @@
+#include <stdio.h>
+#include <getopt.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdbool.h>
+
+/* for daos */
+#include "mfu_daos.h"
+#include "mpi.h"
+#include "mfu.h"
+
+#include "mfu_errors.h"
+
+/** Print a usage message. */
+void print_usage(void)
+{
+    printf("\n");
+    printf("Usage: daos-serialize [options] /<pool>/<cont>\n");
+    printf("\n");
+    printf("DAOS paths can be specified as:\n");
+    printf("       /<pool>/<cont> | <UNS path>\n");
+    printf("\n");
+    printf("Options:\n");
+    printf("  -o  --output-path        - path to output serialized hdf5 files\n");
+    printf("  -v, --verbose            - verbose output\n");
+    printf("  -q, --quiet              - quiet output\n");
+    printf("  -h, --help               - print usage\n");
+    printf("For more information see https://mpifileutils.readthedocs.io.\n");
+    printf("\n");
+    fflush(stdout);
+}
+
+int main(int argc, char** argv)
+{
+    /* assume we'll exit with success */
+    int rc = 0;
+
+    /* initialize MPI */
+    MPI_Init(&argc, &argv);
+    mfu_init();
+
+    /* get our rank */
+    int rank;
+    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
+
+    /* verbose by default */
+    mfu_debug_level = MFU_LOG_VERBOSE;
+
+    int option_index = 0;
+    static struct option long_options[] = {
+        {"output-path"          , required_argument, 0, 'o'},
+        {"verbose"              , no_argument      , 0, 'v'},
+        {"quiet"                , no_argument      , 0, 'q'},
+        {"help"                 , no_argument      , 0, 'h'},
+        {0                      , 0                , 0, 0  }
+    };
+
+    /* Parse options */
+    unsigned long long bytes = 0;
+    int usage = 0;
+    char *output_path = NULL;
+    while (1) {
+        int c = getopt_long(
+                    argc, argv, "o:vqh",
+                    long_options, &option_index
+                );
+
+        if (c == -1) {
+            break;
+        }
+
+        switch(c) {
+            case 'o':
+                output_path = MFU_STRDUP(optarg);
+                break;
+            case 'v':
+                mfu_debug_level = MFU_LOG_VERBOSE;
+                break;
+            case 'q':
+                mfu_debug_level = MFU_LOG_NONE;
+                break;
+            case 'h':
+                usage = 1;
+                break;
+            case '?':
+                usage = 1;
+                break;
+            default:
+                if(rank == 0) {
+                    printf("?? getopt returned character code 0%o ??\n", c);
+                }
+        }
+    }
+
+    /* If we need to print the usage
+     * then do so before internal processing */
+    if (usage) {
+        if (rank == 0) {
+            print_usage();
+        }
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    char** argpaths = (&argv[optind]);
+    
+    /* The remaining arguments are treated as src/dst paths */
+    int numpaths = argc - optind;
+
+    /* advance to next set of options */
+    optind += numpaths;
+
+    /* Before processing, make sure we have at least one path */
+    if (numpaths < 1) {
+        MFU_LOG(MFU_LOG_ERR, "At least one pool and container is required:"
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    /* create an empty file list */
+    mfu_flist flist = mfu_flist_new();
+
+    rc = daos_init();
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to initialize daos");
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    /* DAOS vars */ 
+    daos_args_t* daos_args = daos_args_new();    
+
+    int len = strlen(argpaths[0]); 
+
+    /* default to no daos prefix, but allow someone to use one */
+    bool daos_no_prefix = true;
+    if (strncmp(argpaths[0], "daos://", 7) == 0) {
+        daos_no_prefix = false; 
+    }
+
+    int tmp_rc;
+    tmp_rc = daos_parse_path(argpaths[0], len, &daos_args->src_pool_uuid,
+                         &daos_args->src_cont_uuid, daos_no_prefix);
+    if (tmp_rc != 0 || daos_args->src_pool_uuid == NULL || daos_args->src_cont_uuid == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS path");
+         rc = 1;
+    }
+    
+    tmp_rc = daos_connect(rank, daos_args, daos_args->src_pool_uuid,
+                          daos_args->src_cont_uuid, &daos_args->src_poh,
+                          &daos_args->src_coh, true, false, false);
+    if (tmp_rc != 0) {
+        rc = 1;
+    }
+
+    /* take a snapshot and walk container to get list of objects,
+     * returns epoch number of snapshot */
+    tmp_rc = mfu_daos_flist_walk(daos_args, daos_args->src_coh, &daos_args->src_epc, flist);
+    if (tmp_rc != 0) {
+        rc = 1;
+    }
+
+    /* all objects are on rank 0 at this point,
+     * evenly spread them among the ranks */
+    mfu_flist newflist = mfu_flist_spread(flist);
+
+    /* get size of local list for each rank */
+    uint64_t size = mfu_flist_size(newflist);
+
+    /* serialize pool/cont to an hdf5 file */
+    uint64_t files_written = 0;
+    struct hdf5_args hdf5;
+
+    /* only create a directory if one is passed in with output_path
+     * option, otherwise use current working dir */
+    if (output_path == NULL) {
+        char cwd[FILENAME_LEN];
+        getcwd(cwd, FILENAME_LEN);
+        if (cwd == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "failed to get current working directory");
+            rc = 1;
+        }
+        output_path = MFU_STRDUP(cwd);
+    } else {
+        tmp_rc = mkdir(output_path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+        if (tmp_rc != 0 && errno != EEXIST) {
+            MFU_LOG(MFU_LOG_ERR, "failed to create output directory");
+            rc = 1;
+        }
+    }
+
+    /* don't bother running if this rank doesn't have any oids */
+    if (size > 0) {
+        tmp_rc = daos_cont_serialize_hdlr(rank, &hdf5, output_path, &files_written,
+                                          daos_args, newflist, size);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to serialize container (%d)", rc);
+            rc = 1;
+        }
+    }
+
+    /* sum files_written across all ranks to get total */
+    uint64_t total_files_written = 0;
+    MPI_Allreduce(&files_written, &total_files_written, 1, MPI_UNSIGNED,
+                  MPI_SUM, MPI_COMM_WORLD);
+
+    /* no file created if this rank received no oids */
+    if (size > 0) {
+        tmp_rc = daos_cont_serialize_files_generated(&hdf5, &total_files_written);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "failed to serialize files generated");
+            rc = 1;
+        }
+    }
+
+    /* destroy snapshot after copy */
+    /* TODO consider moving this into mfu_flist_copy_daos */
+    if (rank == 0) {
+        daos_epoch_range_t epr;
+        epr.epr_lo = daos_args->src_epc;
+        epr.epr_hi = daos_args->src_epc;
+        tmp_rc = daos_cont_destroy_snap(daos_args->src_coh, epr, NULL);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "DAOS destroy snapshot failed: ", MFU_ERRF,
+                    MFU_ERRP(-MFU_ERR_DAOS));
+            rc = 1;
+        }
+    }
+    MPI_Bcast(&rc, 1, MPI_INT, 0, MPI_COMM_WORLD);
+
+    /* free newflist that was created for non-posix copy */
+    mfu_flist_free(&newflist);
+
+    /* free output path for hdf5 files */
+    mfu_free(&output_path);
+
+    MPI_Barrier(MPI_COMM_WORLD);
+
+    tmp_rc = daos_cont_close(daos_args->src_coh, NULL);
+    MPI_Barrier(MPI_COMM_WORLD);
+    if (tmp_rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+        rc = 1;
+    }
+
+    tmp_rc = daos_pool_disconnect(daos_args->src_poh, NULL);
+    MPI_Barrier(MPI_COMM_WORLD);
+    if (tmp_rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to disconnect pool (%d)", rc);
+        rc = 1;
+    }
+    
+    /* Alert the user if there were copy errors */
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "One or more errors were detected while "
+                "serializing: " MFU_ERRF, MFU_ERRP(MFU_ERR_DAOS));
+    }
+
+    rc = daos_fini();
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to finalize DAOS "DF_RC, DP_RC(rc));
+    }
+
+    mfu_finalize();
+
+    /* shut down MPI */
+    MPI_Finalize();
+
+    if (rc != 0) {
+        return 1;
+    }
+    return 0;
+}
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 813a667..cba5b14 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -360,6 +360,7 @@ int main(int argc, char** argv)
     /* Set up DAOS arguments, containers, dfs, etc. */
     rc = daos_setup(rank, argpaths, daos_args, mfu_src_file, mfu_dst_file);
     if (rc != 0) {
+        daos_cleanup(daos_args, mfu_src_file, mfu_dst_file);
         mfu_finalize();
         MPI_Finalize();
         return 1;
@@ -376,16 +377,13 @@ int main(int argc, char** argv)
     }
 #endif
 
-    /* paths to walk come after the options */
-    mfu_param_path* paths = NULL;
-
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
     /* Perform a POSIX copy for non-DAOS types */
     if (mfu_src_file->type != DAOS && mfu_dst_file->type != DAOS) {
         /* allocate space for each path */
-        paths = (mfu_param_path*) MFU_MALLOC((size_t)numpaths * sizeof(mfu_param_path));
+        mfu_param_path* paths = (mfu_param_path*) MFU_MALLOC((size_t)numpaths * sizeof(mfu_param_path));
 
         /* last item in the list is the destination path */
         mfu_param_path* destpath = &paths[numpaths - 1];
@@ -451,36 +449,25 @@ int main(int argc, char** argv)
             rc = 1;
         }
 
-        /* free the file list */
-        mfu_flist_free(&flist);
-
         /* free the path parameters */
         mfu_param_path_free_all(numpaths, paths);
 
         /* free memory allocated to hold params */
         mfu_free(&paths);
-
-        /* free the input file name */
-        mfu_free(&inputname);
     } 
 #ifdef DAOS_SUPPORT
     /* Perform an object-level copy for DAOS types */
-    /* TODO consider moving most of this into mfu_daos as a single call.
-     * The benefit would be that we could reuse it for dsync. */
     else {
         /* take a snapshot and walk container to get list of objects,
          * returns epoch number of snapshot */
-        int tmp_rc = mfu_flist_walk_daos(daos_args, flist);
+        int tmp_rc = mfu_daos_flist_walk(daos_args, daos_args->src_coh,
+                                         &daos_args->src_epc, flist);
         if (tmp_rc != 0) {
             rc = 1;
         }
 
-        /* all objects are on rank 0 at this point,
-         * evenly spread them among the ranks */
-        mfu_flist newflist = mfu_flist_spread(flist);
-
-        /* perform copy after oids are spread evenly across all ranks */
-        tmp_rc = mfu_flist_copy_daos(daos_args, newflist);
+        /* Collectively copy all objects */
+        tmp_rc = mfu_daos_flist_sync(daos_args, flist, false, true);
         if (tmp_rc != 0) {
             rc = 1;
         }
@@ -489,30 +476,18 @@ int main(int argc, char** argv)
         if (rc == 0 && rank == 0) {
             MFU_LOG(MFU_LOG_INFO, "Successfully copied to DAOS Destination Container.");
         }
-
-        /* destroy snapshot after copy */
-        /* TODO consider moving this into mfu_flist_copy_daos */
-        if (rank == 0) {
-            daos_epoch_range_t epr;
-            epr.epr_lo = daos_args->epc;
-            epr.epr_hi = daos_args->epc;
-            rc = daos_cont_destroy_snap(daos_args->src_coh, epr, NULL);
-            if (rc != 0) {
-                MFU_LOG(MFU_LOG_ERR, "DAOS destroy snapshot failed: ", MFU_ERRF,
-                        MFU_ERRP(-MFU_ERR_DAOS));
-                rc = 1;
-            }
-        }
-        MPI_Bcast(&rc, 1, MPI_INT, 0, MPI_COMM_WORLD);
-
-	    /* free newflist that was created for non-posix copy */
-	    mfu_flist_free(&newflist);
     }
 
     /* Cleanup DAOS-related variables, etc. */
     daos_cleanup(daos_args, mfu_src_file, mfu_dst_file);
 #endif
 
+    /* free the file list */
+    mfu_flist_free(&flist);
+
+    /* free the input file name */
+    mfu_free(&inputname);
+
     /* free the copy options */
     mfu_copy_opts_delete(&mfu_copy_opts);
 
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index e14c9f5..dd2998f 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -41,6 +41,8 @@
 #include "strmap.h"
 #include "list.h"
 
+#include "mfu_errors.h"
+
 /* for daos */
 #ifdef DAOS_SUPPORT
 #include "mfu_daos.h"
@@ -101,7 +103,7 @@ typedef enum _dsync_state {
       * This file only exist in dest directory.
       * Only valid for DCMPF_EXIST.
       * Not used yet,
-      * becuase we don't want to waste a loop in dsync_strmap_compare()
+      * because we don't want to waste a loop in dsync_strmap_compare()
       */
     DCMPS_ONLY_DEST,
 
@@ -2869,6 +2871,94 @@ static int dsync_validate_link_dest(const char *link_dest, const char *dest, mfu
     }
 }
 
+#ifdef DAOS_SUPPORT
+/* Setup DAOS for dsync */
+static int dsync_daos_setup(
+    int rank,
+    daos_args_t* daos_args,
+    char** argpaths,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
+{
+    /* For error handling */
+    bool daos_do_cleanup = false;
+    bool daos_do_exit = false;
+
+    /* Always allow the destination to exist. */
+    daos_args->allow_exist_dst_cont = true;
+
+    /* Set up DAOS arguments, containers, dfs, etc. */
+    int daos_rc = daos_setup(rank, argpaths, daos_args, mfu_src_file, mfu_dst_file);
+    if (daos_rc != 0) {
+        return 1;
+    }
+
+    /* DAOS does not support hard links */
+    if (options.link_dest != NULL &&
+            (mfu_src_file->type == DAOS || mfu_src_file->type == DFS ||
+             mfu_dst_file->type == DAOS || mfu_dst_file->type == DFS)) {
+        MFU_LOG(MFU_LOG_ERR, "DAOS does not support --link-dest.");
+        return 1;
+    }
+
+    /* Not yet supported */
+    if (options.delete && (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS)) {
+        MFU_LOG(MFU_LOG_ERR, "DAOS API does not support --delete.");
+        return 1;
+    }
+
+    return 0;
+}
+
+/* Perform a DAOS object sync */
+static int dsync_daos(
+    int rank,
+    daos_args_t* daos_args,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
+{
+    /* always compare contents */
+    /* TODO DAOS figure out a reliable "lite" comparison */
+    options.contents = 1;
+
+    mfu_flist flist = mfu_flist_new();
+
+    if (rank == 0) {
+        MFU_LOG(MFU_LOG_INFO, "Gathering source objects");
+    }
+    int rc = mfu_daos_flist_walk(daos_args, daos_args->src_coh,
+                                 &daos_args->src_epc, flist);
+    if (rc != 0) {
+        rc = 1;
+        goto dsync_daos_out;
+    }
+
+    if (mfu_flist_global_size(flist) == 0) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "ERROR: No objects found in source container.");
+        }
+        rc = 1;
+        goto dsync_daos_out;
+    }
+
+    /* Collectively copy all objects */
+    if (rank == 0) {
+        MFU_LOG(MFU_LOG_INFO, "Copying source objects");
+    }
+    bool compare_dst = options.contents;
+    bool write_dst = !options.dry_run;
+    int tmp_rc = mfu_daos_flist_sync(daos_args, flist, compare_dst, write_dst);
+    if (tmp_rc != 0) {
+        rc = 1;
+    }
+
+dsync_daos_out:
+    mfu_flist_free(&flist);
+    return rc;
+}
+#endif
+
 int main(int argc, char **argv)
 {
     int rc = 0;
@@ -3108,56 +3198,35 @@ int main(int argc, char **argv)
         if (rank == 0) {
             print_usage();
         }
-        dsync_option_fini();
-        mfu_finalize();
-        MPI_Finalize();
-        return 1;
+        rc = 1;
+        goto dsync_common_cleanup;
     }
 
-    /* allocate space for each path */
-    mfu_param_path* paths = (mfu_param_path*) MFU_MALLOC((size_t)numargs * sizeof(mfu_param_path));
-
     /* pointer to path arguments */
     char** argpaths = &argv[optind];
 
 #ifdef DAOS_SUPPORT
-    /* For error handling */
-    bool daos_do_cleanup = false;
-    bool daos_do_exit = false;
-
-    /* Set up DAOS arguments, containers, dfs, etc. */
-    int daos_rc = daos_setup(rank, argpaths, daos_args, mfu_src_file, mfu_dst_file);
+    int daos_rc = dsync_daos_setup(rank, daos_args, argpaths, mfu_src_file, mfu_dst_file);
     if (daos_rc != 0) {
-        daos_do_exit = true;
-    }
-
-    /* DAOS does not support hard links */
-    if (options.link_dest != NULL &&
-            (mfu_src_file->type == DAOS || mfu_src_file->type == DFS) &&
-            (mfu_dst_file->type == DAOS || mfu_dst_file->type == DFS)) {
-        MFU_LOG(MFU_LOG_ERR, "DAOS does not support hard links.");
-        daos_do_cleanup = true;
-        daos_do_exit = true;
+        MFU_LOG(MFU_LOG_ERR, "Detected one or more DAOS errors: "MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+        rc = 1;
+        goto dsync_common_cleanup;
     }
 
-    /* Not yet supported */
+    /* Handle the DAOS API case */
     if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
-        MFU_LOG(MFU_LOG_ERR, "dysnc only supports DAOS POSIX containers with the DFS API.");
-        daos_do_cleanup = true;
-        daos_do_exit = true;
-    }
-
-    if (daos_do_cleanup) {
-        daos_cleanup(daos_args, mfu_src_file, mfu_dst_file);
-    }
-    if (daos_do_exit) {
-        dsync_option_fini();
-        mfu_finalize();
-        MPI_Finalize();
-        return 1;
+        daos_rc = dsync_daos(rank, daos_args, copy_opts, mfu_src_file, mfu_dst_file);
+        if (daos_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Detected one or more DAOS errors: "MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+            rc = 1;
+        }
+        goto dsync_common_cleanup;
     }
 #endif
 
+    /* allocate space for each path */
+    mfu_param_path* paths = (mfu_param_path*) MFU_MALLOC((size_t)numargs * sizeof(mfu_param_path));
+
     /* first item is source and second is dest */
     mfu_param_path* srcpath  = &paths[0];
     mfu_param_path* destpath = &paths[1];
@@ -3219,15 +3288,8 @@ int main(int argc, char **argv)
             mfu_param_path_free(linkpath);
             mfu_free(&linkpath);
         }
-        mfu_param_path_free_all(numargs, paths);
-        mfu_free(&paths);
-#ifdef DAOS_SUPPORT
-        daos_cleanup(daos_args, mfu_src_file, mfu_dst_file);
-#endif
-        dsync_option_fini();
-        mfu_finalize();
-        MPI_Finalize();
-        return 1;
+        rc = 1;
+        goto dsync_common_cleanup;
     }
 
     /* walk destinaton path.
@@ -3304,18 +3366,20 @@ int main(int argc, char **argv)
         mfu_flist_free(&flist_link);
     }
 
-    /* free all param paths */
-    mfu_param_path_free_all(numargs, paths);
-
-    /* free memory allocated to hold params */
-    mfu_free(&paths);
-
     /* free param path for link-dest if we have one */
     if (options.link_dest != NULL) {
         mfu_param_path_free(linkpath);
         mfu_free(&linkpath);
     }
 
+    /* free all param paths */
+    mfu_param_path_free_all(numargs, paths);
+
+    /* free memory allocated to hold params */
+    mfu_free(&paths);
+
+    /* Common cleanup for all APIs and early exit conditions */
+dsync_common_cleanup:
     dsync_option_fini();
 
     /* free the copy options structure */
