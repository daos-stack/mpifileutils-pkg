diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7c6e085..4bd03b8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -85,6 +85,23 @@ FIND_PACKAGE(LibArchive REQUIRED)
 INCLUDE_DIRECTORIES(${LibArchive_INCLUDE_DIRS})
 LIST(APPEND MFU_EXTERNAL_LIBS ${LibArchive_LIBRARIES})
 
+OPTION(ENABLE_DAOS "Enable DAOS support")
+IF(ENABLE_DAOS)
+  SET(CMAKE_EXE_LINKER_FLAGS -luuid)
+  FIND_PACKAGE(CART REQUIRED)
+  INCLUDE_DIRECTORIES(${CART_INCLUDE_DIRS})
+  message(${CART_INCLUDE_DIRS})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${CART_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${GURT_LIBRARIES})
+  FIND_PACKAGE(DAOS REQUIRED)
+  INCLUDE_DIRECTORIES(${DAOS_INCLUDE_DIRS})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DAOS_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DUNS_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DFS_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DAOS_COMMON_LIBRARIES})
+  ADD_DEFINITIONS(-DDAOS_SUPPORT)
+ENDIF(ENABLE_DAOS)
+
 ## LIBCIRCLE
 FIND_PACKAGE(LibCircle REQUIRED)
 INCLUDE_DIRECTORIES(${LibCircle_INCLUDE_DIRS})
diff --git a/DAOS-Support.md b/DAOS-Support.md
new file mode 100644
index 0000000..456fa6b
--- /dev/null
+++ b/DAOS-Support.md
@@ -0,0 +1,98 @@
+# DAOS Support
+
+[DAOS](https://github.com/daos-stack/daos) is supported as a backend storage system in dcp. The build instructions for
+enabling DAOS support can be found here:
+[Enable DAOS](https://mpifileutils.readthedocs.io/en/latest/build.html#build-everything-directly).
+The following are ways that DAOS can be used to move data both across DAOS as well as POSIX
+filesystems:
+
+1. DAOS  -> POSIX
+2. POSIX -> DAOS
+3. DAOS  -> DAOS
+
+## DAOS Data Movement Use Cases
+
+In each use case, it is assumed the the pools used already exist. Also,
+only one DAOS source is supported.
+
+1. **DAOS Destination**
+    * POSIX container may or may not exist already
+
+2. **DAOS Source**
+    * POSIX source container exists
+
+3. **DAOS Source and Destination**
+    * Copy across two different pools
+    * Copy across containers in the same pool
+
+## DAOS Data Movement Examples
+
+#### Example One
+
+Show a copy from a regular /tmp source path to a DAOS container. 
+A DAOS Unified Namespace path is used as the destination, which allows you to lookup
+the pool and container UUID from the path. This feature can only be used if the 
+container is created with a path.
+
+```shell
+$ mpirun -np 3 -v /tmp/$USER/s /tmp/$USER/conts/p1cont1
+[2020-04-23T17:04:15]   Items: 6
+[2020-04-23T17:04:15]   Directories: 3
+[2020-04-23T17:04:15]   Files: 3
+[2020-04-23T17:04:15]   Links: 0
+```
+
+#### Example Two
+
+Show a copy where the pool and container UUID are passed in directly. This option
+can be used if the type of container is POSIX, but the container was not created
+with a path. The destination is the relative path within the DAOS container, which 
+in this example is the root of the container. 
+
+```shell
+$ mpirun -np 3 dcp -v --daos-dst-pool $pool --daos-dst-cont $p1cont1 /tmp/$USER/s /
+[2020-04-23T17:17:51] Items: 6
+[2020-04-23T17:17:51]   Directories: 3
+[2020-04-23T17:17:51]   Files: 3
+[2020-04-23T17:17:51]   Links: 0
+```
+#### Example Three
+
+Show a copy from one DAOS container to another container that exists in the same
+pool. A DAOS Unified Namespace path is used as the source and the destination.
+
+```shell
+$ mpirun -np 3 dcp -v /tmp/$USER/conts/p1cont1 /tmp/$USER/conts/p1cont2
+[2020-04-23T17:04:15] Items: 6
+[2020-04-23T17:04:15]   Directories: 3
+[2020-04-23T17:04:15]   Files: 3
+[2020-04-23T17:04:15]   Links: 0
+```
+
+#### Example Four
+
+This example passes in the pool and container UUID directly. The destination path
+is the relative path within the DAOS container, which in this case is a subset of 
+the DAOS container. 
+
+```shell
+$ mpirun -np 3 dcp -v --daos-src-pool $pool --daos-src-cont $p1cont1 \
+--daos-dst-pool $pool2 --daos-dst-cont $p2cont2 /s/biggerfile /
+[2020-04-28T00:47:59] Items: 1
+[2020-04-28T00:47:59]   Directories: 0
+[2020-04-28T00:47:59]   Files: 1
+[2020-04-28T00:47:59]   Links: 0
+```
+
+#### Example Five
+
+This example copies data from a DAOS container to /tmp, where a DAOS
+Unified Namespace path is used as the source. 
+
+```shell
+$ mpirun -np 3 dcp -v /tmp/$USER/conts/p1cont1 /tmp/$USER/d
+[2020-04-23T17:17:51] Items: 6
+[2020-04-23T17:17:51]   Directories: 3
+[2020-04-23T17:17:51]   Files: 3
+[2020-04-23T17:17:51]   Links: 0
+```
diff --git a/README.md b/README.md
index aa5f686..a00189d 100644
--- a/README.md
+++ b/README.md
@@ -3,6 +3,10 @@ mpiFileUtils provides both a library called [libmfu](src/common/README.md) and a
 
 Documentation is available on [ReadTheDocs](http://mpifileutils.readthedocs.io).
 
+## DAOS Support
+
+mpiFileUtils supports a DAOS backend for dcp. Details and usage examples are provided in [DAOS Support](DAOS-Support.md).
+ 
 ## Contributors
 We welcome contributions to the project.  For details on how to help, see our [Contributor Guide](.github/CONTRIBUTING.md)
 
diff --git a/cmake/FindCART.cmake b/cmake/FindCART.cmake
new file mode 100755
index 0000000..216c146
--- /dev/null
+++ b/cmake/FindCART.cmake
@@ -0,0 +1,38 @@
+# - Try to find cart libs 
+# Once done this will define
+#  cart_FOUND - System has libcart
+#  cart_INCLUDE_DIRS - cart include directories
+#  cart_LIBRARIES - The libraries needed to use cart
+#  gurt_LIBRARIES - The libraries needed to use gurt (part of cart)
+
+FIND_PATH(WITH_CART_PREFIX
+    NAMES cart/include
+)
+
+FIND_LIBRARY(CART_LIBRARIES
+    NAMES cart
+    HINTS ${WITH_CART_PREFIX}/lib
+)
+
+FIND_LIBRARY(GURT_LIBRARIES
+    NAMES gurt
+    HINTS ${WITH_CART_PREFIX}/lib
+)
+
+FIND_PATH(CART_INCLUDE_DIRS
+    NAMES cart/types.h
+    HINTS ${WITH_CART_PREFIX}/include
+)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(CART DEFAULT_MSG
+    CART_LIBRARIES
+    CART_INCLUDE_DIRS
+)
+
+# Hide these vars from ccmake GUI
+MARK_AS_ADVANCED(
+	CART_LIBRARIES
+	GURT_LIBRARIES
+	CART_INCLUDE_DIRS
+)
diff --git a/cmake/FindDAOS.cmake b/cmake/FindDAOS.cmake
new file mode 100755
index 0000000..c06ba2c
--- /dev/null
+++ b/cmake/FindDAOS.cmake
@@ -0,0 +1,55 @@
+# - Try to find daos libs 
+# Once done this will define
+#  daos_FOUND - System has libdaos
+#  daos_INCLUDE_DIRS - daos.h
+#  daos_LIBRARIES - libdaos
+#  DUNS_LIBRARIES - libduns 
+#  DFS_LIBRARIES - libdfs 
+#  COMMON_LIBRARIES - libdaos_common
+
+FIND_PATH(WITH_DAOS_PREFIX
+    NAMES include/daos.h
+)
+
+FIND_LIBRARY(DAOS_LIBRARIES
+    NAMES daos
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_LIBRARY(DUNS_LIBRARIES
+    NAMES duns
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_LIBRARY(DFS_LIBRARIES
+    NAMES dfs
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_LIBRARY(COMMON_LIBRARIES
+    NAMES daos_common
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_PATH(DAOS_INCLUDE_DIRS
+    NAMES daos.h
+    HINTS ${WITH_DAOS_PREFIX}/include
+)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(DAOS DEFAULT_MSG
+    DAOS_LIBRARIES
+    DUNS_LIBRARIES
+    DFS_LIBRARIES
+    COMMON_LIBRARIES
+    DAOS_INCLUDE_DIRS
+)
+
+# Hide these vars from ccmake GUI
+MARK_AS_ADVANCED(
+        DAOS_LIBRARIES
+        DUNS_LIBRARIES
+        DFS_LIBRARIES
+        COMMON_LIBRARIES
+        DAOS_INCLUDE_DIRS
+)
diff --git a/doc/rst/build.rst b/doc/rst/build.rst
index 99a8ad9..561ec68 100644
--- a/doc/rst/build.rst
+++ b/doc/rst/build.rst
@@ -99,6 +99,27 @@ or to build the latest mpiFileUtils from the master branch:
      -DCMAKE_INSTALL_PREFIX=../install
    make install
 
+build latest mpiFileUtils from the master branch with DAOS Support:
+
+.. code-block:: Bash
+
+   git clone https://github.com/hpc/mpifileutils
+   mkdir build install
+   cd build
+   cmake ../mpifileutils \
+     -DWITH_DTCMP_PREFIX=../install \
+     -DWITH_LibCircle_PREFIX=../install \
+     -DCMAKE_INSTALL_PREFIX=../install
+     -DWITH_CART_PREFIX=</path/to/daos/>
+     -DWITH_DAOS_PREFIX=</path/to/daos/>
+     -DCMAKE_INSTALL_PREFIX=../install
+     -DENABLE_DAOS=ON;
+   make install
+
+The above build with DAOS option also assumes you have already installed DAOS. If
+CART and DAOS are installed under a standard system path then specifying the CART
+and DAOS paths is unnecessary. 
+
 To enable Lustre, GPFS, and experimental tools, add the following flags during CMake:
 
 .. code-block:: Bash
diff --git a/doc/rst/dcmp.1.rst b/doc/rst/dcmp.1.rst
index 0e3067b..6cecb2d 100644
--- a/doc/rst/dcmp.1.rst
+++ b/doc/rst/dcmp.1.rst
@@ -36,6 +36,23 @@ OPTIONS
 
    Enable base checks and normal stdout results when --output is used.
 
+.. option:: --blocksize SIZE
+
+   Set the I/O buffer to be SIZE bytes.  Units like "MB" and "GB" may
+   immediately follow the number without spaces (eg. 8MB). The default
+   blocksize is 1MB.
+
+.. option:: --chunksize SIZE
+
+   Multiple processes copy a large file in parallel by dividing it into chunks.
+   Set chunk to be at minimum SIZE bytes.  Units like "MB" and
+   "GB" can immediately follow the number without spaces (eg. 64MB).
+   The default chunksize is 1MB.
+
+.. option:: -s, --direct
+
+   Use O_DIRECT to avoid caching file data.
+
 .. option:: --progress N
 
    Print progress message to stdout approximately every N seconds.
diff --git a/doc/rst/dcp.1.rst b/doc/rst/dcp.1.rst
index 3a26356..95d9b2c 100644
--- a/doc/rst/dcp.1.rst
+++ b/doc/rst/dcp.1.rst
@@ -19,33 +19,64 @@ file system, and it splits large file copies across multiple processes.
 
 OPTIONS
 -------
-
-.. option:: -b, --blocksize SIZE
+.. option:: --blocksize SIZE
 
    Set the I/O buffer to be SIZE bytes.  Units like "MB" and "GB" may
    immediately follow the number without spaces (eg. 8MB). The default
    blocksize is 1MB.
 
+.. option:: --chunksize SIZE
+
+   Multiple processes copy a large file in parallel by dividing it into chunks.
+   Set chunk to be at minimum SIZE bytes.  Units like "MB" and
+   "GB" can immediately follow the number without spaces (eg. 64MB).
+   The default chunksize is 1MB.
+
+.. option:: --daos-src-pool POOL
+
+   Specify the DAOS source pool to be used.
+
+.. option:: --daos-dst-pool POOL
+
+   Specify the DAOS destination pool to be used.
+
+.. option:: --daos-src-cont CONTAINER
+
+   Specify the DAOS source container to be used.
+
+.. option:: --daos-dst-cont CONTAINER
+
+   Specify the DAOS destination container to be used.
+
+.. option:: --daos-prefix PREFIX
+
+   Specify the DAOS prefix to be used. This is only necessary
+   if copying a subset of a POSIX container in DAOS using a
+   Unified Namespace path.
+
 .. option:: -i, --input FILE
 
    Read source list from FILE. FILE must be generated by another tool
    from the mpiFileUtils suite.
 
-.. option:: -k, --chunksize SIZE
+.. option:: -L, --dereference
 
-   Split large files into chunks of SIZE bytes to be processed.  Multiple
-   process ranks may copy a large file in parallel.  Units like "MB" and
-   "GB" can immediately follow the number without spaces (eg. 64MB).
-   The default chunksize is 1MB.
+   Dereference symbolic links and copy the target file or directory
+   that each symbolic link refers to.
+
+.. option:: -P, --no-dereference
+
+   Do not follow symbolic links in source paths. Effectviely allows
+   symbolic links to be copied when the link target is not valid
+   or there is not permission to read the link's target.
 
 .. option:: -p, --preserve
 
    Preserve permissions, group, timestamps, and extended attributes.
 
-.. option:: -s, --synchronous
+.. option:: -s, --direct
 
-   Use synchronous read/write calls (open files with O_DIRECT).
-   This also avoids caching the file data on the client nodes.
+   Use O_DIRECT to avoid caching file data.
 
 .. option:: -S, --sparse
 
diff --git a/doc/rst/dsync.1.rst b/doc/rst/dsync.1.rst
index c3dfa24..96b4ef5 100644
--- a/doc/rst/dsync.1.rst
+++ b/doc/rst/dsync.1.rst
@@ -26,6 +26,19 @@ OPTIONS
 
    Batch files into groups of up to size N during copy operation.
 
+.. option:: --blocksize SIZE
+
+   Set the I/O buffer to be SIZE bytes.  Units like "MB" and "GB" may
+   immediately follow the number without spaces (eg. 8MB). The default
+   blocksize is 1MB.
+
+.. option:: --chunksize SIZE
+
+   Multiple processes copy a large file in parallel by dividing it into chunks.
+   Set chunk to be at minimum SIZE bytes.  Units like "MB" and
+   "GB" can immediately follow the number without spaces (eg. 64MB).
+   The default chunksize is 1MB.
+
 .. option:: -c, --contents
 
    Compare files byte-by-byte rather than checking size and mtime
@@ -35,6 +48,21 @@ OPTIONS
 
    Delete extraneous files from destination.
 
+.. option:: -L, --dereference
+
+   Dereference symbolic links and copy the target file or directory
+   that each symbolic link refers to.
+
+.. option:: -P, --no-dereference
+
+   Do not follow symbolic links in source paths. Effectviely allows
+   symbolic links to be copied when the link target is not valid
+   or there is not permission to read the link's target.
+
+.. option:: -s, --direct
+
+   Use O_DIRECT to avoid caching file data.
+
 .. option:: --link-dest DIR
 
    Create hardlink in DEST to files in DIR when file is unchanged
diff --git a/doc/rst/dwalk.1.rst b/doc/rst/dwalk.1.rst
index 7b9ee41..0e54f93 100644
--- a/doc/rst/dwalk.1.rst
+++ b/doc/rst/dwalk.1.rst
@@ -70,6 +70,11 @@ OPTIONS
 
    Print files to the screen.
 
+.. option:: -L, --dereference
+
+   Dereference symbolic links and walk the target file or directory
+   that each symbolic link refers to.
+
 .. option:: --progress N
 
    Print progress message to stdout approximately every N seconds.
diff --git a/doc/rst/index.rst b/doc/rst/index.rst
index a7d7729..4cb02f4 100644
--- a/doc/rst/index.rst
+++ b/doc/rst/index.rst
@@ -20,6 +20,8 @@ jobs like copy, remove, and compare for such datasets, providing speedups of up
 to 50x. The libmfu library simplifies the creation of new tools
 and it can be called directly from within HPC applications.
 
+Video Overview: `"Scalable Management of HPC Datasets with mpiFileUtils" <https://youtu.be/cxjPOUS-ZBY>`_, HPCKP'20.
+
 User Guide
 ***************************
 
diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt
index f04e38a..1eb4d09 100644
--- a/src/common/CMakeLists.txt
+++ b/src/common/CMakeLists.txt
@@ -1,6 +1,13 @@
+# Version for the shared mfu library
+set(MFU_VERSION_MAJOR 1) # Incompatible API changes
+set(MFU_VERSION_MINOR 0) # Backwards-compatible functionality
+set(MFU_VERSION_PATCH 0) # Backwards-compatible fixes
+set(MFU_VERSION ${MFU_VERSION_MAJOR}.${MFU_VERSION_MINOR}.${MFU_VERSION_PATCH})
+
 # todo re-asses if all of these must be *installed*
 LIST(APPEND libmfu_install_headers
   mfu.h
+  mfu_errors.h
   mfu_bz2.h
   mfu_flist.h
   mfu_flist_internal.h
@@ -43,7 +50,7 @@ SET_TARGET_PROPERTIES(mfu_o PROPERTIES C_STANDARD 99)
 
 ADD_LIBRARY(mfu SHARED $<TARGET_OBJECTS:mfu_o>)
 TARGET_LINK_LIBRARIES(mfu LINK_PUBLIC ${MFU_EXTERNAL_LIBS})
-SET_TARGET_PROPERTIES(mfu PROPERTIES OUTPUT_NAME mfu CLEAN_DIRECT_OUTPUT 1)
+SET_TARGET_PROPERTIES(mfu PROPERTIES VERSION ${MFU_VERSION} OUTPUT_NAME mfu CLEAN_DIRECT_OUTPUT 1)
 INSTALL(TARGETS mfu DESTINATION ${CMAKE_INSTALL_LIBDIR})
 
 ADD_LIBRARY(mfu-static STATIC $<TARGET_OBJECTS:mfu_o>)
diff --git a/src/common/mfu_errors.h b/src/common/mfu_errors.h
new file mode 100644
index 0000000..ae80453
--- /dev/null
+++ b/src/common/mfu_errors.h
@@ -0,0 +1,32 @@
+/* Defines common error codes */
+
+/* enable C++ codes to include this header directly */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef MFU_ERRORS_H
+#define MFU_ERRORS_H
+
+/* Generic error codes */
+#define MFU_ERR           1000
+#define MFU_ERR_INVAL_ARG 1001
+
+/* DCP-specific error codes */
+#define MFU_ERR_DCP      1100
+#define MFU_ERR_DCP_COPY 1101
+
+/* DAOS-specific error codes*/
+#define MFU_ERR_DAOS            4000
+#define MFU_ERR_DAOS_INVAL_ARG  4001
+
+/* Error macros */
+#define MFU_ERRF "%s(%d)"
+#define MFU_ERRP(rc) "MFU_ERR", rc
+
+#endif /* MFU_ERRORS_H */
+
+/* enable C++ codes to include this header directly */
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
diff --git a/src/common/mfu_flist.c b/src/common/mfu_flist.c
index 622d1b4..b906eb3 100644
--- a/src/common/mfu_flist.c
+++ b/src/common/mfu_flist.c
@@ -61,9 +61,12 @@ mfu_walk_opts_t* mfu_walk_opts_new(void)
     /* Remove files in walk by default */
     opts->remove = 0;
 
-    /* Don't stat files in walk by default */
+    /* Do stat files in walk by default */
     opts->use_stat = 1;
 
+    /* Don't dereference symbolic links by default */
+    opts->dereference = 0;
+
     return opts;
 }
 
diff --git a/src/common/mfu_flist.h b/src/common/mfu_flist.h
index 53dc2d5..9e1a9f6 100644
--- a/src/common/mfu_flist.h
+++ b/src/common/mfu_flist.h
@@ -60,10 +60,12 @@ extern "C" {
 #define DCOPY_DEF_PERMS_DIR  (S_IRWXU)
 
 /* default chunk size to split files into work units */
-#define FD_CHUNK_SIZE (1*1024*1024)
+#define MFU_CHUNK_SIZE_STR "64MB"
+#define MFU_CHUNK_SIZE (64*1024*1024)
 
 /* default buffer size to read/write data to file system */
-#define FD_BLOCK_SIZE (1*1024*1024)
+#define MFU_BLOCK_SIZE_STR "64MB"
+#define MFU_BLOCK_SIZE (64*1024*1024)
 
 /*
  * FIXME: Is this description correct?
@@ -181,7 +183,8 @@ void mfu_flist_free(mfu_flist* flist);
 void mfu_flist_walk_path(
     const char* path,           /* IN  - path to be walked */
     mfu_walk_opts_t* walk_opts, /* IN  - functions to perform during the walk */
-    mfu_flist flist             /* OUT - flist to insert walked items into */
+    mfu_flist flist,            /* OUT - flist to insert walked items into */
+    mfu_file_t* mfu_file        /* IN  - I/O filesystem functions to use during the walk */
 );
 
 /* create file list by walking list of directories */
@@ -189,7 +192,8 @@ void mfu_flist_walk_paths(
     uint64_t num_paths,         /* IN  - number of paths in array */
     const char** paths,         /* IN  - array of paths to be walkted */
     mfu_walk_opts_t* walk_opts, /* IN  - functions to perform during the walk */
-    mfu_flist flist             /* OUT - flist to insert walked items into */
+    mfu_flist flist,            /* OUT - flist to insert walked items into */
+    mfu_file_t* mfu_file        /* IN  - I/O filesystem functions to use during the walk */
 );
 
 /* given a list of param_paths, walk each one and add to flist */
@@ -197,7 +201,8 @@ void mfu_flist_walk_param_paths(
     uint64_t num,                 /* IN  - number of paths in array */
     const mfu_param_path* params, /* IN  - array of paths to be walkted */
     mfu_walk_opts_t* walk_opts,   /* IN  - functions to perform during the walk */
-    mfu_flist flist               /* OUT - flist to insert walked items into */
+    mfu_flist flist,              /* OUT - flist to insert walked items into */
+    mfu_file_t* mfu_file          /* IN  - I/O filesystem functions to use during the walk */
 );
 
 /* skip function pointer: given a path input, along with user-provided
@@ -218,7 +223,9 @@ void mfu_flist_stat(
     mfu_flist input_flist,     /* IN  - input flist to source items */
     mfu_flist flist,           /* OUT - output flist to copy items into */
     mfu_flist_skip_fn skip_fn, /* IN  - pointer to skip function */
-    void *skip_args            /* IN  - arguments to be passed to skip function */
+    void *skip_args,           /* IN  - arguments to be passed to skip function */
+    int dereference,           /* IN  - whether to dereference symbolic links */
+    mfu_file_t* mfu_file       /* IN  - I/O filesystem functions to use */
 );
 
 /****************************************
@@ -433,6 +440,13 @@ int mfu_flist_sort(const char* fields, mfu_flist* flist);
  * Functions to create / remove data on file system based on input list
  ****************************************/
 
+/* allocate a new mfu_file_t structure,
+ * and set its fields with default values */
+mfu_file_t* mfu_file_new(void);
+
+/* free object allocated in mfu_file_new */
+void mfu_file_delete(mfu_file_t** mfile);
+
 /* allocate a new mfu_copy_opts structure,
  * and set its fields with default values */
 mfu_copy_opts_t* mfu_copy_opts_new(void);
@@ -448,7 +462,9 @@ int mfu_flist_copy(
     int numpaths,                   /* IN - number of source paths */
     const mfu_param_path* paths,    /* IN - array of source pathts */
     const mfu_param_path* destpath, /* IN - destination path */
-    mfu_copy_opts_t* mfu_copy_opts  /* IN - options to be used during copy */
+    mfu_copy_opts_t* mfu_copy_opts, /* IN - options to be used during copy */
+    mfu_file_t* mfu_src_file,       /* IN - I/O filesystem functions to use for copy of src */
+    mfu_file_t* mfu_dst_file        /* IN - I/O filesystem functions to use for copy of dst */
 );
 
 /* link items in list from source paths to destination,
@@ -458,14 +474,17 @@ int mfu_flist_hardlink(
     mfu_flist src_link_list,         /* IN - flist providing source items */
     const mfu_param_path* srcpath,   /* IN - the source patht */
     const mfu_param_path* destpath,  /* IN - destination path */
-    mfu_copy_opts_t* mfu_copy_opts   /* IN - options to be used during copy */
+    mfu_copy_opts_t* mfu_copy_opts,  /* IN - options to be used during copy */
+    mfu_file_t* mfu_src_file,        /* IN - I/O filesystem functions for src */
+    mfu_file_t* mfu_dst_file         /* IN - I/O filesystem functions for dst */
 );
 
 /* fill files in list with data
  * returns 0 on success -1 on error */
 int mfu_flist_fill(
     mfu_flist list,                 /* IN - flist providing items */
-    mfu_copy_opts_t* mfu_copy_opts  /* IN - options to be used during fill */
+    mfu_copy_opts_t* mfu_copy_opts, /* IN - options to be used during fill */
+    mfu_file_t* mfu_file            /* IN - I/O filesystem functions */
 );
 
 /* allocate a new mfu_walk_opts structure,
@@ -517,7 +536,9 @@ void mfu_flist_chmod(
 
 /* given a source and destination file, update destination metadata
  * to match source if needed, returns 0 on success -1 on error */
-int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist dst_list, uint64_t dst_index);
+int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index,
+                             mfu_flist dst_list, uint64_t dst_index,
+                             mfu_file_t* mfu_file);
 
 /* TODO: integrate this into the file list proper, or otherwise move it to another file */
 /* element structure in linked list returned by mfu_file_chunk_list_alloc */
diff --git a/src/common/mfu_flist_chunk.c b/src/common/mfu_flist_chunk.c
index 74e2ab8..50e547d 100644
--- a/src/common/mfu_flist_chunk.c
+++ b/src/common/mfu_flist_chunk.c
@@ -393,6 +393,44 @@ mfu_file_chunk* mfu_file_chunk_list_alloc(mfu_flist list, uint64_t chunk_size)
         tail = p;
     }
 
+    /* free the send and receive flag arrays */
+    mfu_free(&sendlist);
+    mfu_free(&recvlist);
+
+    /* free the linked lists, packed send buffers, and related arrays */
+    for (int i = 0; i < send_ranks; i++) {
+        mfu_free(&sendbufs[i]);
+
+        /* free the element linked list for each rank.
+         * Do not free elem->name because it is needed by the mfu_flist entry. */
+        mfu_file_chunk* elem = heads[i];
+        mfu_file_chunk* tmp;
+        while (elem != NULL) {
+            tmp = elem;
+            elem = elem->next;
+            mfu_free(&tmp);
+        }
+    }
+    mfu_free(&heads);
+    mfu_free(&tails);
+    mfu_free(&counts);
+    mfu_free(&bytes);
+    mfu_free(&sendbufs);
+
+    /* free the array for ranks recevied from */
+    mfu_free(&recvranklist);
+
+    /* free the request and status messages */
+    mfu_free(&request);
+    mfu_free(&status);
+    
+    /* free the bytes counts arrays */
+    mfu_free(&send_counts);
+    mfu_free(&recv_counts);
+
+    /* free the receive buffer */
+    mfu_free(&recvbuf);
+
     return head;
 }
 
diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index 8024cba..709b826 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -42,8 +42,15 @@
 #include <inttypes.h>
 
 #include <libgen.h> /* dirname */
+#include <stdbool.h>
 #include "libcircle.h"
 #include "dtcmp.h"
+
+#ifdef DAOS_SUPPORT
+#include <gurt/common.h>
+#include <gurt/hash.h>
+#endif
+
 #include "mfu.h"
 #include "mfu_flist_internal.h"
 #include "strmap.h"
@@ -76,9 +83,12 @@ typedef struct {
 /* cache open file descriptor to avoid
  * opening / closing the same file */
 typedef struct {
-    char* name; /* name of open file (NULL if none) */
-    int   read; /* whether file is open for read-only (1) or write (0) */
-    int   fd;   /* file descriptor */
+    char* name;    /* name of open file (NULL if none) */
+    int   read;    /* whether file is open for read-only (1) or write (0) */
+    int   fd;      /* file descriptor */
+#ifdef DAOS_SUPPORT
+    dfs_obj_t* obj; /* open object */
+#endif
 } mfu_copy_file_cache_t;
 
 /****************************************
@@ -92,67 +102,119 @@ static mfu_copy_stats_t mfu_copy_stats;
 static mfu_copy_file_cache_t mfu_copy_src_cache;
 static mfu_copy_file_cache_t mfu_copy_dst_cache;
 
-static int mfu_copy_open_file(const char* file, int read_flag,
-        mfu_copy_file_cache_t* cache, mfu_copy_opts_t* mfu_copy_opts)
+/* open and cache a file.
+ * Returns 0 on success; -1 otherwise */
+static int mfu_copy_open_file(
+    const char* file,             /* path to file to be opened */
+    int read_flag,                /* set to 1 to open in read only, 0 for write */
+    mfu_copy_file_cache_t* cache, /* cache the open file to avoid repetitive open/close of the same file */
+    mfu_copy_opts_t* copy_opts,   /* options configuring the copy operation */
+    mfu_file_t* mfu_file)         /* whether the file is in POSIX/DAOS */
 {
-    int newfd = -1;
-
     /* see if we have a cached file descriptor */
     char* name = cache->name;
     if (name != NULL) {
         /* we have a cached file descriptor */
         int fd = cache->fd;
+#ifdef DAOS_SUPPORT
+        dfs_obj_t* obj = cache->obj;
+#endif
         if (strcmp(name, file) == 0 && cache->read == read_flag) {
             /* the file we're trying to open matches name and read/write mode,
              * so just return the cached descriptor */
-            return fd;
+            return 0;
         } else {
             /* the file we're trying to open is different,
              * close the old file and delete the name */
-            mfu_close(name, fd);
+            mfu_file_close(name, mfu_file);
             mfu_free(&cache->name);
         }
     }
 
-    /* open the new file */
+    /* open the new file, this sets mfu_file->fd/obj */
     if (read_flag) {
         int flags = O_RDONLY;
-        if (mfu_copy_opts->synchronous) {
+        if (copy_opts->direct) {
             flags |= O_DIRECT;
         }
-        newfd = mfu_open(file, flags);
+        mfu_file_open(file, flags, mfu_file);
     } else {
         int flags = O_WRONLY | O_CREAT;
-        if (mfu_copy_opts->synchronous) {
+        if (copy_opts->direct) {
             flags |= O_DIRECT;
         }
-        newfd = mfu_open(file, flags, DCOPY_DEF_PERMS_FILE);
+        mfu_file_open(file, flags, mfu_file, DCOPY_DEF_PERMS_FILE);
     }
 
     /* cache the file descriptor */
-    if (newfd != -1) {
+    if (mfu_file->type == POSIX) {
+        if (mfu_file->fd < 0) {
+            return -1;
+        }
+
         cache->name = MFU_STRDUP(file);
-        cache->fd   = newfd;
+        cache->fd   = mfu_file->fd;
         cache->read = read_flag;
+
 #ifdef LUSTRE_SUPPORT
         /* Zero is an invalid ID for grouplock. */
-        if (mfu_copy_opts->grouplock_id != 0) {
+        if (copy_opts->grouplock_id != 0) {
             errno = 0;
-            int rc = ioctl(newfd, LL_IOC_GROUP_LOCK, mfu_copy_opts->grouplock_id);
+            int rc = ioctl(mfu_file->fd, LL_IOC_GROUP_LOCK, copy_opts->grouplock_id);
             if (rc) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to obtain grouplock with ID %d "
                     "on file `%s', ignoring this error (errno=%d %s)",
-                    mfu_copy_opts->grouplock_id, file, errno, strerror(errno));
+                    copy_opts->grouplock_id, file, errno, strerror(errno));
             } else {
                 MFU_LOG(MFU_LOG_INFO, "Obtained grouplock with ID %d "
-                    "on file `%s', fd %d", mfu_copy_opts->grouplock_id,
-                    file, newfd);
+                    "on file `%s', fd %d", copy_opts->grouplock_id,
+                    file, mfu_file->fd);
             }
         }
 #endif
     }
 
-    return newfd;
+#ifdef DAOS_SUPPORT
+    if (mfu_file->type == DAOS) {
+        if (mfu_file->obj == NULL) {
+            return -1;
+        }
+        
+        cache->name = MFU_STRDUP(file);
+        cache->read = read_flag;
+        cache->obj  = mfu_file->obj;
+    }
+#endif
+
+    return 0;
+}
+
+/* close a file that opened with mfu_copy_open_file */
+static int mfu_copy_close_file(
+    mfu_copy_file_cache_t* cache,
+    mfu_file_t* mfu_file)
+{
+    int rc = 0;
+
+    /* close file if we have one */
+    char* name = cache->name;
+    if (name != NULL) {
+        int fd = cache->fd;
+#ifdef DAOS_SUPPORT
+        dfs_obj_t* obj = cache->obj;
+#endif
+        /* if open for write, fsync */
+        int read_flag = cache->read;
+        if (! read_flag && mfu_file->type == POSIX) {
+            rc = mfu_fsync(name, fd);
+        }
+
+        /* close the file and delete the name string */
+        rc = mfu_file_close(name, mfu_file);
+        mfu_free(&cache->name);
+    }
+
+    return rc;
 }
 
 /* copy all extended attributes from op->operand to dest_path,
@@ -160,7 +222,10 @@ static int mfu_copy_open_file(const char* file, int read_flag,
 static int mfu_copy_xattrs(
     mfu_flist flist,
     uint64_t idx,
-    const char* dest_path)
+    const char* dest_path,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume that we'll succeed */
     int rc = 0;
@@ -180,7 +245,13 @@ static int mfu_copy_xattrs(
     /* get current estimate for list size */
     while(! got_list) {
         errno = 0;
-        list_size = llistxattr(src_path, list, list_bufsize);
+        if (copy_opts->dereference) {
+            /* listxattr of dereferenced symbolic link */
+            list_size = mfu_file_listxattr(src_path, list, list_bufsize, mfu_src_file);
+        } else {
+            /* llistxattr of the symbolic link itself */
+            list_size = mfu_file_llistxattr(src_path, list, list_bufsize, mfu_src_file);
+        }
 
         if(list_size < 0) {
             if(errno == ERANGE) {
@@ -204,7 +275,7 @@ static int mfu_copy_xattrs(
         }
         else {
             if(list_size > 0 && list_bufsize == 0) {
-                /* called llistxattr with size==0 and got back positive
+                /* called mfu_file_llistxattr with size==0 and got back positive
                  * number indicating size of buffer we need to allocate */
                 list_bufsize = (size_t) list_size;
                 list = (char*) MFU_MALLOC(list_bufsize);
@@ -232,7 +303,13 @@ static int mfu_copy_xattrs(
 
             while(! got_val) {
                 errno = 0;
-                val_size = lgetxattr(src_path, name, val, val_bufsize);
+                if (copy_opts->dereference) {
+                    /* getxattr of dereferenced symbolic links */
+                    val_size = mfu_file_getxattr(src_path, name, val, val_bufsize, mfu_src_file);
+                } else {
+                    /* lgetxattr of symbolic the link itself */
+                    val_size = mfu_file_lgetxattr(src_path, name, val, val_bufsize, mfu_src_file);
+                }
 
                 if(val_size < 0) {
                     if(errno == ERANGE) {
@@ -244,14 +321,14 @@ static int mfu_copy_xattrs(
                     else if(errno == ENOATTR) {
                         /* source object no longer has this attribute,
                          * maybe deleted out from under us, ignore but print warning */
-                        MFU_LOG(MFU_LOG_WARN, "Attribute does not exist for name=%s on `%s' llistxattr() (errno=%d %s)",
+                        MFU_LOG(MFU_LOG_WARN, "Attribute does not exist for name=%s on `%s' lgetxattr() (errno=%d %s)",
                             name, src_path, errno, strerror(errno)
                            );
                         break;
                     }
                     else {
                         /* this is a real error */
-                        MFU_LOG(MFU_LOG_ERR, "Failed to get value for name=%s on `%s' llistxattr() (errno=%d %s)",
+                        MFU_LOG(MFU_LOG_ERR, "Failed to get value for name=%s on `%s' lgetxattr() (errno=%d %s)",
                             name, src_path, errno, strerror(errno)
                            );
                         rc = -1;
@@ -260,7 +337,7 @@ static int mfu_copy_xattrs(
                 }
                 else {
                     if(val_size > 0 && val_bufsize == 0) {
-                        /* called lgetxattr with size==0 and got back positive
+                        /* called mfu_file_lgetxattr with size==0 and got back positive
                          * number indicating size of buffer we need to allocate */
                         val_bufsize = (size_t) val_size;
                         val = (void*) MFU_MALLOC(val_bufsize);
@@ -275,10 +352,11 @@ static int mfu_copy_xattrs(
             /* set attribute on destination object */
             if(got_val) {
                 errno = 0;
-                int setrc = lsetxattr(dest_path, name, val, (size_t) val_size, 0);
+                /* lsetxattr of symbolic link itself. No need to dereference here */
+                int setrc = mfu_file_lsetxattr(dest_path, name, val, (size_t) val_size, 0, mfu_dst_file);
                 if(setrc != 0) {
                     /* failed to set attribute */
-                    MFU_LOG(MFU_LOG_ERR, "Failed to set value for name=%s on `%s' llistxattr() (errno=%d %s)",
+                    MFU_LOG(MFU_LOG_ERR, "Failed to set value for name=%s on `%s' lsetxattr() (errno=%d %s)",
                         name, dest_path, errno, strerror(errno)
                        );
                     rc = -1;
@@ -307,7 +385,8 @@ static int mfu_copy_xattrs(
 static int mfu_copy_ownership(
     mfu_flist flist,
     uint64_t idx,
-    const char* dest_path)
+    const char* dest_path,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -317,7 +396,7 @@ static int mfu_copy_ownership(
     gid_t gid = (gid_t) mfu_flist_file_get_gid(flist, idx);
 
     /* note that we use lchown to change ownership of link itself, it path happens to be a link */
-    if(mfu_lchown(dest_path, uid, gid) != 0) {
+    if(mfu_file_lchown(dest_path, uid, gid, mfu_dst_file) != 0) {
         /* TODO: are there other EPERM conditions we do want to report? */
 
         /* since the user running dcp may not be the owner of the
@@ -339,7 +418,8 @@ static int mfu_copy_ownership(
 static int mfu_copy_permissions(
     mfu_flist flist,
     uint64_t idx,
-    const char* dest_path)
+    const char* dest_path,
+    mfu_file_t* mfu_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -350,14 +430,12 @@ static int mfu_copy_permissions(
 
     /* change mode */
     if(type != MFU_TYPE_LINK) {
-        if(mfu_chmod(dest_path, mode) != 0) {
+        if(mfu_file_chmod(dest_path, mode, mfu_file) != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to change permissions on `%s' chmod() (errno=%d %s)",
-                dest_path, errno, strerror(errno)
-               );
+                dest_path, errno, strerror(errno));
             rc = -1;
         }
     }
-
     return rc;
 }
 
@@ -381,56 +459,57 @@ static int mfu_copy_acls(
           * We use the opaque method as we are not trying to alter the ACL contents.
           * Note that if the source is not a GPFS file-system, then the call will
           * fail with EINVAL and so we never try to apply this to the dest_path */
-     
+
          /* need the file path to read the existing ACL */
          const char* src_path = mfu_flist_file_get_name(flist, idx);
-     
+
          /* acl param mapped with gpfs_opaque_acl_t structure */
          int aclflags = 0;
          unsigned char acltype = GPFS_ACL_TYPE_ACCESS;
-     
+
          /* initial size of the struct for gpfs_opaque_acl, 512 bytes should
           * be large enough for a fairly large ACL anyway */
          size_t bufsize = 512;
-     
+
          /* gpfs_getacl needs a *void for where it will place the data, so we need
           * to allocate some memory and then place a gpfs_opaque_acl into the
           * memory as aclflags is set to 0 to indicate gpfs_opaque_acl_t */
          void* aclbufmem = MFU_MALLOC(bufsize);
          memset(aclbufmem, 0, bufsize);
-     
+
          /* set fields in structure to define acl query */
          struct gpfs_opaque_acl* aclbuffer = (struct gpfs_opaque_acl*) aclbufmem;
          aclbuffer->acl_buffer_len = (int) (bufsize - sizeof(struct gpfs_opaque_acl));
          aclbuffer->acl_type = acltype;
-     
+
          /* try and get the ACL */
          errno = 0;
          int r = gpfs_getacl(src_path, aclflags, aclbufmem);
-     
+
          /* the buffer may not be big enough, if not, we'll get EONSPC and
           * the first 4 bytes (acl_buffer_len) will tell us how much space we need */
+
          if ((r != 0) && (errno == ENOSPC)) {
            /* make a buffer which is exactly the right size */
            unsigned int len = *(unsigned int*) &(aclbuffer->acl_buffer_len);
            bufsize = len + sizeof(struct gpfs_opaque_acl);
            MFU_LOG(MFU_LOG_DBG, "GPFS ACL buffer too small, needs to be %d",
                    (int) bufsize);
-     
+
            /* free the old buffer, then malloc the new size */
            mfu_free(&aclbufmem);
            aclbufmem = MFU_MALLOC(bufsize);
            memset(aclbufmem, 0, bufsize);
-     
+
            /* set fields in structure to define acl query */
            aclbuffer = (struct gpfs_opaque_acl*) aclbufmem;
            aclbuffer->acl_buffer_len = (int) (bufsize - sizeof(struct gpfs_opaque_acl));
            aclbuffer->acl_type = acltype;
-     
+
            /* once again try and get the ACL */
            r = gpfs_getacl(src_path, aclflags, aclbufmem);
          }
-     
+
          /* check whether we read the ACL successfully */
          if (r == 0) {
            /* Assuming we now have a valid call to an ACL,
@@ -451,10 +530,10 @@ static int mfu_copy_acls(
              rc = -1;
            }
          }
-     
+
          /* free the memory from the buffer */
          mfu_free(&aclbufmem);
-    }
+
 #endif /* GPFS_SUPPORT */
 
     return rc;
@@ -463,7 +542,8 @@ static int mfu_copy_acls(
 static int mfu_copy_timestamps(
     mfu_flist flist,
     uint64_t idx,
-    const char* dest_path)
+    const char* dest_path,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -487,7 +567,7 @@ static int mfu_copy_timestamps(
      * assume path is relative to current working directory,
      * if it's not absolute, and set times on link (not target file)
      * if dest_path refers to a link */
-    if(mfu_utimensat(AT_FDCWD, dest_path, times, AT_SYMLINK_NOFOLLOW) != 0) {
+    if(mfu_file_utimensat(AT_FDCWD, dest_path, times, AT_SYMLINK_NOFOLLOW, mfu_dst_file) != 0) {
         MFU_LOG(MFU_LOG_ERR, "Failed to change timestamps on `%s' utime() (errno=%d %s)",
             dest_path, errno, strerror(errno)
            );
@@ -497,29 +577,6 @@ static int mfu_copy_timestamps(
     return rc;
 }
 
-static int mfu_copy_close_file(mfu_copy_file_cache_t* cache)
-{
-    int rc = 0;
-
-    /* close file if we have one */
-    char* name = cache->name;
-    if (name != NULL) {
-        int fd = cache->fd;
-
-        /* if open for write, fsync */
-        int read_flag = cache->read;
-        if (! read_flag) {
-            rc = mfu_fsync(name, fd);
-        }
-
-        /* close the file and delete the name string */
-        rc = mfu_close(name, fd);
-        mfu_free(&cache->name);
-    }
-
-    return rc;
-}
-
 /* progress message to print while setting file metadata */
 static void meta_progress_fn(const uint64_t* vals, int count, int complete, int ranks, double secs)
 {
@@ -558,9 +615,16 @@ static void meta_progress_fn(const uint64_t* vals, int count, int complete, int
  * and permissions starting from deepest level and working upwards,
  * we go in this direction in case updating a file updates its
  * parent directory */
-static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_copy_set_metadata(
+    int levels,                     /* number of levels */
+    int minlevel,                   /* value of minimum level */
+    mfu_flist* lists,               /* list of items at each level */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -573,7 +637,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
     if (rank == 0) {
-        if(mfu_copy_opts->preserve) {
+        if(copy_opts->preserve) {
             MFU_LOG(MFU_LOG_INFO, "Setting ownership, permissions, and timestamps.");
         }
         else {
@@ -608,7 +672,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
 
             /* get destination name of item */
             char* dest = mfu_param_path_copy_dest(name, numpaths,
-                    paths, destpath, mfu_copy_opts);
+                    paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
             /* No need to copy it */
             if (dest == NULL) {
@@ -618,12 +682,12 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
             /* update our running total */
             total_count++;
 
-            if(mfu_copy_opts->preserve) {
-                tmp_rc = mfu_copy_ownership(list, idx, dest);
+            if(copy_opts->preserve) {
+                tmp_rc = mfu_copy_ownership(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -631,7 +695,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
-                tmp_rc = mfu_copy_timestamps(list, idx, dest);
+                tmp_rc = mfu_copy_timestamps(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -639,7 +703,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
             else {
                 /* TODO: set permissions based on source permissons
                  * masked by umask */
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -687,9 +751,16 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
  * and permissions starting from deepest level and working upwards,
  * we go in this direction in case updating a file updates its
  * parent directory */
-static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_copy_set_metadata_dirs(
+    int levels,                     /* number of levels */
+    int minlevel,                   /* value of minimum level */
+    mfu_flist* lists,               /* list of items at each level */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -702,7 +773,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
     if (rank == 0) {
-        if(mfu_copy_opts->preserve) {
+        if(copy_opts->preserve) {
             MFU_LOG(MFU_LOG_INFO, "Setting ownership, permissions, and timestamps on directories.");
         }
         else {
@@ -734,7 +805,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
 
             /* get destination name of item */
             char* dest = mfu_param_path_copy_dest(name, numpaths,
-                    paths, destpath, mfu_copy_opts);
+                    paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
             /* No need to copy it */
             if (dest == NULL) {
@@ -750,12 +821,12 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
             /* update our running total */
             total_count++;
 
-            if(mfu_copy_opts->preserve) {
-                tmp_rc = mfu_copy_ownership(list, idx, dest);
+            if(copy_opts->preserve) {
+                tmp_rc = mfu_copy_ownership(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -763,7 +834,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
-                tmp_rc = mfu_copy_timestamps(list, idx, dest);
+                tmp_rc = mfu_copy_timestamps(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -771,7 +842,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
             else {
                 /* TODO: set permissions based on source permissons
                  * masked by umask */
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -814,9 +885,15 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
  * and creates dir at same relative path under destpath, copies xattrs
  * when preserving permissions, which contains file striping info on Lustre,
  * returns 0 on success and -1 on error */
-static int mfu_create_directory(mfu_flist list, uint64_t idx,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_directory(
+    mfu_flist list,                 /* flist holding target directory */
+    uint64_t idx,                   /* index of target directory within its list */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -826,7 +903,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     char* dest_path = mfu_param_path_copy_dest(name, numpaths, paths,
-            destpath, mfu_copy_opts);
+            destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -845,7 +922,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
      * not dsync is on happens prior to this in
      * mfu_param_path_copy_dest. */
 
-    if (mfu_copy_opts->do_sync &&
+    if (copy_opts->do_sync &&
         (strncmp(dest_path, destpath->path, strlen(dest_path)) == 0) &&
         destpath->target_stat_valid)
     {
@@ -855,7 +932,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
 
     /* create the destination directory */
     MFU_LOG(MFU_LOG_DBG, "Creating directory `%s'", dest_path);
-    int mkdir_rc = mfu_mkdir(dest_path, DCOPY_DEF_PERMS_DIR);
+    int mkdir_rc = mfu_file_mkdir(dest_path, DCOPY_DEF_PERMS_DIR, mfu_dst_file);
     if(mkdir_rc < 0) {
         if(errno == EEXIST) {
             MFU_LOG(MFU_LOG_WARN,
@@ -875,8 +952,8 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
      * creating / striping files in the directory */
 
     /* copy extended attributes on directory */
-    if (mfu_copy_opts->preserve) {
-        int tmp_rc = mfu_copy_xattrs(list, idx, dest_path);
+    if (copy_opts->preserve) {
+        int tmp_rc = mfu_copy_xattrs(list, idx, dest_path, copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -895,9 +972,16 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
  * with a barrier in between levels, so that we don't try to create
  * a child directory until the parent exists,
  * returns 0 on success and -1 on failure */
-static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_directories(
+    int levels,                     /* number of levels */
+    int minlevel,                   /* value of minimum level */
+    mfu_flist* lists,               /* list of items at each level */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -938,7 +1022,7 @@ static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
             if (type == MFU_TYPE_DIR) {
                 /* create the directory */
                 int tmp_rc = mfu_create_directory(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1003,9 +1087,15 @@ static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
  * that contains source link, computes relative path to link under source path,
  * and creates link at same relative path under destpath,
  * returns 0 on success and -1 on error */
-static int mfu_create_link(mfu_flist list, uint64_t idx,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_link(
+    mfu_flist list,
+    uint64_t idx,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1015,7 +1105,7 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, numpaths,
-           paths, destpath, mfu_copy_opts);
+           paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1024,7 +1114,7 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
 
     /* read link target */
     char path[PATH_MAX + 1];
-    ssize_t readlink_rc = mfu_readlink(src_path, path, sizeof(path) - 1);
+    ssize_t readlink_rc = mfu_file_readlink(src_path, path, sizeof(path) - 1, mfu_src_file);
     if(readlink_rc < 0) {
         MFU_LOG(MFU_LOG_ERR, "Failed to read link `%s' readlink() (errno=%d %s)",
             src_path, errno, strerror(errno)
@@ -1037,7 +1127,7 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
     path[readlink_rc] = '\0';
 
     /* create new link */
-    int symlink_rc = mfu_symlink(path, dest_path);
+    int symlink_rc = mfu_file_symlink(path, dest_path, mfu_dst_file);
     if(symlink_rc < 0) {
         if(errno == EEXIST) {
             MFU_LOG(MFU_LOG_WARN,
@@ -1053,8 +1143,8 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
     }
 
     /* set permissions on link */
-    if (mfu_copy_opts->preserve) {
-        int xattr_rc = mfu_copy_xattrs(list, idx, dest_path);
+    if (copy_opts->preserve) {
+        int xattr_rc = mfu_copy_xattrs(list, idx, dest_path, copy_opts, mfu_src_file, mfu_dst_file);
         if (xattr_rc < 0) {
             rc = -1;
         }
@@ -1074,9 +1164,15 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
  * and creates file at same relative path under destpath, copies xattrs
  * when preserving permissions, which contains file striping info on Lustre,
  * returns 0 on success and -1 on error */
-static int mfu_create_file(mfu_flist list, uint64_t idx,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_file(
+    mfu_flist list,
+    uint64_t idx,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1086,7 +1182,7 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, numpaths,
-            paths, destpath, mfu_copy_opts);
+            paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1101,12 +1197,11 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
      * see makedev() to create valid dev */
     dev_t dev;
     memset(&dev, 0, sizeof(dev_t));
-    int mknod_rc = mfu_mknod(dest_path, DCOPY_DEF_PERMS_FILE | S_IFREG, dev);
+    int mknod_rc = mfu_file_mknod(dest_path, DCOPY_DEF_PERMS_FILE | S_IFREG, dev, mfu_dst_file);
     if(mknod_rc < 0) {
         if(errno == EEXIST) {
             /* destination already exists, no big deal, but print warning */
-            MFU_LOG(MFU_LOG_WARN,
-                    "Original file exists, skip the creation: `%s' (errno=%d %s)",
+            MFU_LOG(MFU_LOG_WARN, "Original file exists, skip the creation: `%s' (errno=%d %s)",
                     dest_path, errno, strerror(errno));
         } else {
             /* failed to create inode, that's a problem */
@@ -1121,8 +1216,8 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
     /* copy extended attributes, important to do this first before
      * writing data because some attributes tell file system how to
      * stripe data, e.g., Lustre */
-    if (mfu_copy_opts->preserve) {
-        int tmp_rc = mfu_copy_xattrs(list, idx, dest_path);
+    if (copy_opts->preserve) {
+        int tmp_rc = mfu_copy_xattrs(list, idx, dest_path, copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -1131,13 +1226,13 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
     /* Truncate destination files to 0 bytes when sparse file is enabled,
      * this is because we will not overwrite sections corresponding to holes
      * and we need those to be set to 0 */
-    if (mfu_copy_opts->sparse) {
+    if (copy_opts->sparse) {
         /* truncate destination file to 0 bytes */
         struct stat st;
-        int status = mfu_lstat(dest_path, &st);
+        int status = mfu_file_lstat(dest_path, &st, mfu_dst_file);
         if (status == 0) {
             /* destination exists, truncate it to 0 bytes */
-            status = mfu_truncate(dest_path, 0);
+            status = mfu_file_truncate(dest_path, 0, mfu_dst_file);
             if (status) {
                 /* when using sparse file optimization, consider this to be an error,
                  * since we will not be overwriting the holes */
@@ -1166,9 +1261,14 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
 
 /* creates hardlink in destpath for specified file, identifies source path
  * returns 0 on success and -1 on error */
-static int mfu_create_hardlink(mfu_flist list, uint64_t idx,
-        const mfu_param_path* srcpath,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_hardlink(
+    mfu_flist list,
+    uint64_t idx,
+    const mfu_param_path* srcpath,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1178,7 +1278,7 @@ static int mfu_create_hardlink(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, 1,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1238,9 +1338,16 @@ static void create_progress_fn(const uint64_t* vals, int count, int complete, in
 
 /* creates file inodes and symlinks,
  * returns 0 on success and -1 on error */
-static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_files(
+    int levels,
+    int minlevel,
+    mfu_flist* lists,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     int rc = 0;
 
@@ -1284,7 +1391,7 @@ static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
             if (type == MFU_TYPE_FILE) {
                 /* create inode and copy xattr for regular file */
                 int tmp_rc = mfu_create_file(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1293,7 +1400,7 @@ static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
             } else if (type == MFU_TYPE_LINK) {
                 /* create symlink */
                 int tmp_rc = mfu_create_link(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1359,9 +1466,15 @@ static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
 
 /* creates hardlinks,
  * returns 0 on success and -1 on error */
-static int mfu_create_hardlinks(int levels, int minlevel, mfu_flist* lists,
-        const mfu_param_path* srcpath,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_hardlinks(
+    int levels,
+    int minlevel,
+    mfu_flist* lists,
+    const mfu_param_path* srcpath,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     int rc = 0;
 
@@ -1404,8 +1517,9 @@ static int mfu_create_hardlinks(int levels, int minlevel, mfu_flist* lists,
                 continue;
             }
 
-            int tmp_rc = mfu_create_hardlink(list, idx, srcpath, destpath,
-                                             mfu_copy_opts);
+            int tmp_rc = mfu_create_hardlink(list, idx, srcpath,
+                                             destpath, copy_opts,
+                                             mfu_src_file, mfu_dst_file);
             if (tmp_rc != 0) {
                 rc = -1;
             }
@@ -1527,95 +1641,87 @@ static int mfu_is_all_null(const char* buf, uint64_t buf_size)
     return 1;
 }
 
-/* when using sparse files, we need to write the last byte if the
- * hole is adjacent to EOF, so we need to detect whether we're at
- * the end of the file */
-static int mfu_is_eof(const char* file, int fd)
-{
-    /* read one byte from fd to determine whether this is EOF.
-     * This is not efficient, but it is the only reliable way */
-    char buf[1];
-    ssize_t num_of_bytes_read = mfu_read(file, fd, buf, 1);
-
-    /* return if we detect EOF */
-    if(! num_of_bytes_read) {
-        return 1;
-    }
-
-    /* otherwise, we're not at EOF yet, seek back one byte */
-    if(mfu_lseek(file, fd, -1, SEEK_CUR) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in path `%s' (errno=%d %s)",
-                  file, errno, strerror(errno));
-        return -1;
-    }
-    return 0;
-}
-
 static int mfu_copy_file_normal(
     const char* src,
     const char* dest,
-    const int in_fd,
-    const int out_fd,
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
-    /* hint that we'll read from file sequentially */
-//    posix_fadvise(in_fd, offset, chunk_size, POSIX_FADV_SEQUENTIAL);
-
-    /* seek to offset in source file */
-    if(mfu_lseek(src, in_fd, offset, SEEK_SET) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)",
-            src, errno, strerror(errno));
-        return -1;
-    }
-
-    /* seek to offset in destination file */
-    if(mfu_lseek(dest, out_fd, offset, SEEK_SET) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
-            dest, errno, strerror(errno));
-        return -1;
+    /* set buffer and buffer size */
+    size_t buf_size = copy_opts->block_size;
+    void* buf       = copy_opts->block_buf1;
+
+    /* for O_DIRECT, check that length is multiple of block_size */
+    if (copy_opts->direct &&           /* using O_DIRECT */
+        offset + length < file_size && /* not at end of file */
+        length % buf_size != 0)        /* length not an integer multiple of block size */
+    {
+        MFU_ABORT(-1, "O_DIRECT requires chunk size to be integer multiple of block size %llu",
+            buf_size);
     }
 
-    /* get buffer */
-    size_t buf_size = mfu_copy_opts->block_size;
-    void* buf = mfu_copy_opts->block_buf1;
+    /* initialize our starting offset within the file */
+    off_t off = offset;
 
     /* write data */
-    size_t total_bytes = 0;
-    while(total_bytes < (size_t)length) {
-        /* determine number of bytes that we
-         * can read = max(buf size, remaining chunk) */
-        size_t left_to_read = (size_t)length - total_bytes;
-        if(left_to_read > buf_size) {
-            left_to_read = buf_size;
-        }
-        if(mfu_copy_opts->synchronous) {
-            /* O_DIRECT requires particular read sizes */
-            left_to_read = buf_size;
+    uint64_t total_bytes = 0;
+    while (total_bytes < length) {
+        /* determine number of bytes to read,
+         * O_DIRECT requires read operation of certain size blocks,
+         * even if we know that would run past the end of the file */
+        size_t left_to_read = buf_size;
+        if (! copy_opts->direct) {
+            uint64_t remainder = length - total_bytes;
+            if (remainder < (uint64_t) buf_size) {
+                left_to_read = (size_t) remainder;
+            }
         }
 
         /* read data from source file */
-        ssize_t num_of_bytes_read = mfu_read(src, in_fd, buf, left_to_read);
+        ssize_t bytes_read = mfu_file_pread(src, buf, left_to_read, off, mfu_src_file);
 
-        /* check for EOF */
-        if(! num_of_bytes_read) {
-            break;
+        /* If we're using O_DIRECT, deal with short reads.
+         * Retry with same buffer and offset since those must
+         * be aligned at block boundaries. */
+        while (copy_opts->direct &&            /* using O_DIRECT */
+               bytes_read > 0 &&               /* read was not an error or eof */
+               bytes_read < left_to_read &&    /* shorter than requested */
+               (off + bytes_read) < file_size) /* not at end of file */
+        {
+            /* TODO: probably should retry a limited number of times then abort */
+            bytes_read = mfu_file_pread(src, buf, left_to_read, off, mfu_src_file);
+        }
+
+        /* check for an error */
+        if (bytes_read < 0) {
+            MFU_LOG(MFU_LOG_ERR, "Read error when copying from `%s' to `%s' (errno=%d %s)",
+                src, dest, errno, strerror(errno));
+            return -1;
+        }
+
+        /* check for early EOF */
+        if (bytes_read == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source file `%s' shorter than expected %llu (errno=%d %s)",
+                src, file_size, errno, strerror(errno));
+            return -1;
         }
 
         /* compute number of bytes to write */
-        size_t bytes_to_write = (size_t) num_of_bytes_read;
-        if(mfu_copy_opts->synchronous) {
+        size_t bytes_to_write = (size_t) bytes_read;
+        if (copy_opts->direct) {
             /* O_DIRECT requires particular write sizes,
              * ok to write beyond end of file so long as
              * we truncate in cleanup step */
-            size_t remainder = buf_size - (size_t) num_of_bytes_read;
-            if(remainder > 0) {
+            size_t remainder = buf_size - (size_t) bytes_read;
+            if (remainder > 0) {
                 /* zero out the end of the buffer for security,
                  * don't want to leave data from another file at end of
                  * current file if we fail before truncating */
-                char* bufzero = ((char*)buf + num_of_bytes_read);
+                char* bufzero = ((char*)buf + bytes_read);
                 memset(bufzero, 0, remainder);
             }
 
@@ -1623,69 +1729,46 @@ static int mfu_copy_file_normal(
             bytes_to_write = buf_size;
         }
 
-        /* Write data to destination file.
-         * Do nothing for a hole in the middle of a file,
-         * because write of next chunk will create one for us.
-         * Write only the last byte to create the hole,
-         * if the hole is next to EOF. */
-        ssize_t num_of_bytes_written = (ssize_t)bytes_to_write;
-        if (mfu_copy_opts->sparse && mfu_is_all_null(buf, bytes_to_write)) {
-            /* TODO: isn't there a better way to know if we're at EOF,
-             * e.g., by using file size? */
-            /* determine whether we're at the end of the file */
-            int end_of_file = mfu_is_eof(src, in_fd);
-            if (end_of_file < 0) {
-                /* hit an error while looking for EOF */
-                return -1;
-            }
+        /* If in sparse mode, skip writing out blocks that are all 0.
+         * Rely on posix hole semantics to account for those 0 values instead.
+         * If this hole is at the end of the file, the truncate below will
+         * set the file size correctly. */
+        int skip_write = 0;
+        if (copy_opts->sparse && mfu_is_all_null(buf, bytes_to_write)) {
+            skip_write = 1;
+        }
+
+        /* write data to destination file if needed */
+        if (! skip_write) {
+            /* we loop to account for short writes */
+            ssize_t n = 0;
+            while (n < bytes_to_write) {
+                /* write bytes to destination file */
+                ssize_t bytes_written = mfu_file_pwrite(dest, ((char*)buf) + n, bytes_to_write - n, off + n, mfu_dst_file);
 
-            /* if we're at the end of the file, write out a byte,
-             * otherwise just seek out destination file pointer
-             * ahead without writing anything */
-            if (end_of_file) {
-                /* seek to last byte position in file */
-                if(mfu_lseek(dest, out_fd, (off_t)bytes_to_write - 1, SEEK_CUR) == (off_t)-1) {
-                    MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
-                        dest, errno, strerror(errno));
+                /* check for an error */
+                if (bytes_written < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s' (errno=%d %s)",
+                        src, dest, errno, strerror(errno));
                     return -1;
                 }
 
-                /* write out a single byte */
-                mfu_write(dest, out_fd, buf, 1);
-            } else {
-                /* this section of the destination file is all 0,
-                 * seek past this section */
-                if(mfu_lseek(dest, out_fd, (off_t)bytes_to_write, SEEK_CUR) == (off_t)-1) {
-                    MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
-                        dest, errno, strerror(errno));
-                    return -1;
+                /* So long as we're not using O_DIRECT, we can handle short writes
+                 * by advancing by the number of bytes written.  For O_DIRECT, we
+                 * need to keep buffer, file offset, and amount to write aligned
+                 * on block boundaries, so just retry the entire operation. */
+                if (!copy_opts->direct || bytes_written == bytes_to_write) {
+                    n += bytes_written;
                 }
             }
-        } else {
-            /* write bytes to destination file */
-            num_of_bytes_written = mfu_write(dest, out_fd, buf, bytes_to_write);
         }
 
-        /* check for an error */
-        if(num_of_bytes_written < 0) {
-            MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s' (errno=%d %s)",
-                src, dest, errno, strerror(errno));
-            return -1;
-        }
-
-        /* check that we wrote the same number of bytes that we read */
-        if((size_t)num_of_bytes_written != bytes_to_write) {
-            MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s'",
-                src, dest);
-            return -1;
-        }
-
-        /* add bytes to our total (use bytes read,
-         * which may be less than number written) */
-        total_bytes += (size_t) num_of_bytes_read;
+        /* update current offset and accumulate number of bytes copied */
+        off += (off_t) bytes_read;
+        total_bytes += (uint64_t) bytes_read;
 
         /* update number of bytes we have copied for progress messages */
-        copy_count += (uint64_t) num_of_bytes_read;
+        copy_count += (uint64_t) bytes_read;
         mfu_progress_update(&copy_count, copy_prog);
     }
 
@@ -1695,17 +1778,11 @@ static int mfu_copy_file_normal(
 
 #if 0
     /* force data to file system */
-    if(total_bytes > 0) {
+    if (total_bytes > 0) {
         mfu_fsync(dest, out_fd);
     }
 #endif
 
-    /* no need to truncate if sparse file is enabled,
-     * since we truncated files when they were first created */
-    if (mfu_copy_opts->sparse) {
-        return 0;
-    }
-
     /* if we wrote the last chunk, truncate the file */
     off_t last_written = offset + length;
     off_t file_size_offt = (off_t) file_size;
@@ -1713,33 +1790,38 @@ static int mfu_copy_file_normal(
         /* Use ftruncate() here rather than truncate(), because grouplock
          * of Lustre would cause block to truncate() since the fd is different
          * from the out_fd. */
-        if(mfu_ftruncate(out_fd, file_size_offt) < 0) {
+        if (mfu_file_ftruncate(mfu_dst_file, file_size_offt) < 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to truncate destination file: %s (errno=%d %s)",
                 dest, errno, strerror(errno));
             return -1;
-       }
+        }
     }
 
-    /* we don't bother closing the file because our cache does it for us */
-
     return 0;
 }
 
 static int mfu_copy_file_fiemap(
     const char* src,
     const char* dest,
-    const int in_fd,
-    const int out_fd,
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
     bool* normal_copy_required,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     *normal_copy_required = true;
-    if (mfu_copy_opts->synchronous) {
+    if (copy_opts->direct) {
+        goto fail_normal_copy;
+    }
+
+#ifdef DAOS_SUPPORT
+    /* Not yet supported */
+    if (mfu_src_file->type == DAOS) {
         goto fail_normal_copy;
     }
+#endif
 
     size_t last_ext_start = offset;
     size_t last_ext_len = 0;
@@ -1758,31 +1840,39 @@ static int mfu_copy_file_fiemap(
     fiemap->fm_mapped_extents = 0;
 
     struct stat sb;
-    if (fstat(in_fd, &sb) < 0) {
-        goto fail_normal_copy;
+    if (fstat(mfu_src_file->fd, &sb) < 0) {
+        goto fail_fiemap;
     }
 
-    if (ioctl(in_fd, FS_IOC_FIEMAP, fiemap) < 0) {
-        MFU_LOG(MFU_LOG_ERR, "fiemap ioctl() failed for src `%s'", src);
-        goto fail_normal_copy;
+    if (ioctl(mfu_src_file->fd, FS_IOC_FIEMAP, fiemap) < 0) {
+        if (errno == ENOTSUP) {
+            /* silently ignore */
+        } else {
+            MFU_LOG(MFU_LOG_ERR, "fiemap ioctl() failed for src '%s' (errno=%d %s)",
+                    src, errno, strerror(errno));
+        }
+        goto fail_fiemap;
     }
 
     size_t extents_size = sizeof(struct fiemap_extent) * (fiemap->fm_mapped_extents);
 
-    if ((fiemap = (struct fiemap*)realloc(fiemap,sizeof(struct fiemap) +
-                                  extents_size)) == NULL)
-    {
+    /* reallocate the fiemap.
+     * If realloc returns NULL, the original fiemap is left malloc'ed */
+    struct fiemap* new_fiemap = (struct fiemap*) realloc(fiemap, sizeof(struct fiemap) + extents_size);
+    if (new_fiemap == NULL) {
         MFU_LOG(MFU_LOG_ERR, "Out of memory reallocating fiemap");
-        goto fail_normal_copy;
+        goto fail_fiemap;
     }
+    fiemap = new_fiemap;
 
     memset(fiemap->fm_extents, 0, extents_size);
     fiemap->fm_extent_count   = fiemap->fm_mapped_extents;
     fiemap->fm_mapped_extents = 0;
 
-    if (ioctl(in_fd, FS_IOC_FIEMAP, fiemap) < 0) {
-        MFU_LOG(MFU_LOG_ERR, "fiemap ioctl() failed for src `%s'", src);
-        goto fail_normal_copy;
+    if (ioctl(mfu_src_file->fd, FS_IOC_FIEMAP, fiemap) < 0) {
+        MFU_LOG(MFU_LOG_ERR, "fiemap ioctl() failed for src '%s' (errno=%d %s)",
+                src, errno, strerror(errno));
+        goto fail_fiemap;
     }
 
     uint64_t last_byte = offset + length;
@@ -1806,17 +1896,17 @@ static int mfu_copy_file_fiemap(
     *normal_copy_required = false;
 
     /* seek to offset in source file */
-    if (mfu_lseek(src, in_fd, (off_t)last_ext_start, SEEK_SET) < 0) {
+    if (mfu_file_lseek(src, mfu_src_file, (off_t)last_ext_start, SEEK_SET) < 0) {
         MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)",
             src, errno, strerror(errno));
-        goto fail;
+        goto fail_fiemap;
     }
 
     /* seek to offset in destination file */
-    if (mfu_lseek(dest, out_fd, (off_t)last_ext_start, SEEK_SET) < 0) {
+    if (mfu_file_lseek(dest, mfu_dst_file, (off_t)last_ext_start, SEEK_SET) < 0) {
         MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
             dest, errno, strerror(errno));
-        goto fail;
+        goto fail_fiemap;
     }
 
     unsigned int i;
@@ -1825,23 +1915,23 @@ static int mfu_copy_file_fiemap(
         size_t ext_len;
         size_t ext_hole_size;
 
-        size_t buf_size = mfu_copy_opts->block_size;
-        void* buf = mfu_copy_opts->block_buf1;
+        size_t buf_size = copy_opts->block_size;
+        void* buf = copy_opts->block_buf1;
 
         ext_start = fiemap->fm_extents[i].fe_logical;
         ext_len = fiemap->fm_extents[i].fe_length;
         ext_hole_size = ext_start - (last_ext_start + last_ext_len);
 
         if (ext_hole_size) {
-            if (mfu_lseek(src, in_fd, (off_t)ext_start, SEEK_SET) < 0) {
+            if (mfu_file_lseek(src, mfu_src_file, (off_t)ext_start, SEEK_SET) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)",
                     src, errno, strerror(errno));
-                goto fail;
+                goto fail_fiemap;
             }
-            if (mfu_lseek(dest, out_fd, (off_t)ext_hole_size, SEEK_CUR) < 0) {
+            if (mfu_file_lseek(dest, mfu_dst_file, (off_t)ext_hole_size, SEEK_CUR) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
                     dest, errno, strerror(errno));
-                goto fail;
+                goto fail_fiemap;
             }
         }
 
@@ -1849,22 +1939,21 @@ static int mfu_copy_file_fiemap(
         last_ext_len = ext_len;
 
         while (ext_len) {
-            ssize_t num_read = mfu_read(src, in_fd, buf, MIN(ext_len, buf_size));
+            ssize_t num_read = mfu_file_read(src, buf, MIN(ext_len, buf_size), mfu_src_file);
 
             if (!num_read)
                 break;
-
-            ssize_t num_written = mfu_write(dest, out_fd, buf, (size_t)num_read);
+            ssize_t num_written = mfu_file_write(dest, buf, (size_t)num_read, mfu_dst_file);
 
             if (num_written < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s' (errno=%d %s)",
                           src, dest, errno, strerror(errno));
-                goto fail;
+                goto fail_fiemap;
             }
             if (num_written != num_read) {
                 MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s'",
                     src, dest);
-                goto fail;
+                goto fail_fiemap;
             }
 
             ext_len -= (size_t)num_written;
@@ -1878,10 +1967,10 @@ static int mfu_copy_file_fiemap(
         /* Use ftruncate() here rather than truncate(), because grouplock
          * of Lustre would cause block to truncate() since the fd is different
          * from the out_fd. */
-        if (mfu_ftruncate(out_fd, file_size_offt) < 0) {
+        if (mfu_file_ftruncate(mfu_dst_file, file_size_offt) < 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to truncate destination file: %s (errno=%d %s)",
                 dest, errno, strerror(errno));
-            goto fail;
+            goto fail_fiemap;
        }
     }
 
@@ -1894,7 +1983,7 @@ static int mfu_copy_file_fiemap(
     free(fiemap);
     return 0;
 
-fail:
+fail_fiemap:
     free(fiemap);
 
 fail_normal_copy:
@@ -1907,38 +1996,42 @@ static int mfu_copy_file(
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     int ret;
-    bool normal_copy_required;
 
     /* open the input file */
-    int in_fd = mfu_copy_open_file(src, 1, &mfu_copy_src_cache, mfu_copy_opts);
-    if (in_fd < 0) {
+    ret = mfu_copy_open_file(src, 1, &mfu_copy_src_cache,
+                             copy_opts, mfu_src_file);
+    if (ret) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open input file `%s' (errno=%d %s)",
             src, errno, strerror(errno));
         return -1;
     }
 
     /* open the output file */
-    int out_fd = mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, mfu_copy_opts);
-    if (out_fd < 0) {
+    ret = mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache,
+                             copy_opts, mfu_dst_file);
+    if (ret) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open output file `%s' (errno=%d %s)",
-            dest, errno, strerror(errno));
+                dest, errno, strerror(errno));
         return -1;
     }
 
-    if (mfu_copy_opts->sparse) {
-        ret = mfu_copy_file_fiemap(src, dest, in_fd, out_fd, offset,
-                               length, file_size,
-                               &normal_copy_required, mfu_copy_opts);
+    if (copy_opts->sparse) {
+        bool normal_copy_required;
+        ret = mfu_copy_file_fiemap(src, dest, offset, length, file_size,
+                               &normal_copy_required, copy_opts,
+                               mfu_src_file, mfu_dst_file);
         if (!ret || !normal_copy_required) {
             return ret;
         }
     }
 
-    ret = mfu_copy_file_normal(src, dest, in_fd, out_fd,
-            offset, length, file_size, mfu_copy_opts);
+    ret = mfu_copy_file_normal(src, dest, offset, length, file_size,
+                               copy_opts, mfu_src_file, mfu_dst_file);
 
     return ret;
 }
@@ -1946,9 +2039,14 @@ static int mfu_copy_file(
 /* slices files in list at boundaries of chunk size, evenly distributes
  * chunks, and copies data from source to destination file,
  * returns 0 on success and -1 on error */
-static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_copy_files(
+    mfu_flist list,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1979,7 +2077,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
 
     /* split file list into a linked list of file sections,
      * this evenly spreads the file sections across processes */
-    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, chunk_size);
+    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, copy_opts->chunk_size);
 
     /* get a count of how many items are the chunk list */
     uint64_t list_count = mfu_file_chunk_list_size(head);
@@ -1998,7 +2096,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
 
         /* get name of destination file */
         char* dest = mfu_param_path_copy_dest(p->name, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
         if (dest == NULL) {
             /* No need to copy it */
             p = p->next;
@@ -2011,7 +2109,8 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
         /* copy portion of file corresponding to this chunk,
          * and record whether copy operation succeeded */
         int copy_rc = mfu_copy_file(p->name, dest, (uint64_t)p->offset,
-                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts);
+                (uint64_t)p->length, (uint64_t)p->file_size, copy_opts,
+                mfu_src_file, mfu_dst_file);
         if (copy_rc < 0) {
             /* error copying file */
             vals[i] = 1;
@@ -2025,8 +2124,8 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
     }
 
     /* close files */
-    mfu_copy_close_file(&mfu_copy_src_cache);
-    mfu_copy_close_file(&mfu_copy_dst_cache);
+    mfu_copy_close_file(&mfu_copy_src_cache, mfu_src_file);
+    mfu_copy_close_file(&mfu_copy_dst_cache, mfu_dst_file);
 
     /* barrier to ensure all files are closed,
      * may try to unlink bad destination files below */
@@ -2052,7 +2151,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
              * compute destination name and delete it */
             const char* name = mfu_flist_file_get_name(list, i);
             const char* dest = mfu_param_path_copy_dest(name, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
             if (dest != NULL) {
                 /* sanity check to ensure we don't * delete the source file */
                 if (strcmp(dest, name) != 0) {
@@ -2060,7 +2159,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
                     rc = -1;
 #if 0
                     /* delete destination file */
-                    int unlink_rc = mfu_unlink(dest);
+                    int unlink_rc = mfu_file_unlink(dest, mfu_dst_file);
                     if (unlink_rc != 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to unlink `%s' (errno=%d %s)",
                                   name, errno, strerror(errno)
@@ -2075,6 +2174,9 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
         }
     }
 
+    /* free the list of success/fail for each chunk */
+    mfu_free(&vals);
+
     /* free copy flags */
     mfu_free(&results);
 
@@ -2243,25 +2345,35 @@ static void print_summary(mfu_flist flist)
     return;
 }
 
-int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
-        const mfu_param_path* paths, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts)
+int mfu_flist_copy(
+    mfu_flist src_cp_list,          /* list of source items to be copied */
+    int numpaths,                   /* number of entries in paths array below */
+    const mfu_param_path* paths,    /* list of paths, each source item is from one path in this list */
+    const mfu_param_path* destpath, /* destination path to copy items to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure how copy is executed */
+    mfu_file_t* mfu_src_file,       /* whether source items are coming from POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
 
+    /* DAOS only supports using one source path */
+    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
+        if (numpaths != 1) {
+            MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
+        }
+    }
+
     /* get our rank */
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
-    /* set mfu_copy options in mfu_copy_opts_t struct */
-
     /* copy the destination path to user opts structure */
-    mfu_copy_opts->dest_path = MFU_STRDUP((*destpath).path);
+    copy_opts->dest_path = MFU_STRDUP((*destpath).path);
 
     /* print note about what we're doing and the amount of files/data to be moved */
     if (rank == 0) {
-        MFU_LOG(MFU_LOG_INFO, "Copying to %s", mfu_copy_opts->dest_path);
+        MFU_LOG(MFU_LOG_INFO, "Copying to %s", copy_opts->dest_path);
     }
     mfu_flist_print_summary(src_cp_list);
 
@@ -2270,8 +2382,8 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
     /* allocate buffer to read/write files, aligned on 1MB boundaraies */
     size_t alignment = 1024*1024;
-    mfu_copy_opts->block_buf1 = (char*) MFU_MEMALIGN(mfu_copy_opts->block_size, alignment);
-    mfu_copy_opts->block_buf2 = (char*) MFU_MEMALIGN(mfu_copy_opts->block_size, alignment);
+    copy_opts->block_buf1 = (char*) MFU_MEMALIGN(copy_opts->block_size, alignment);
+    copy_opts->block_buf2 = (char*) MFU_MEMALIGN(copy_opts->block_size, alignment);
 
     /* Grab a relative and actual start time for the epilogue. */
     time(&(mfu_copy_stats.time_started));
@@ -2298,13 +2410,13 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
     /* create directories, from top down */
     int tmp_rc = mfu_create_directories(levels, minlevel, lists, numpaths,
-            paths, destpath, mfu_copy_opts);
+            paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
 
     /* operate on files in batches if batch size is given */
-    uint64_t batch_size = mfu_copy_opts->batch_files;
+    uint64_t batch_size = copy_opts->batch_files;
     if (batch_size > 0) {
         /* operate in batches, get total size of list, our global
          * offset within it, and the local size of our list to
@@ -2361,14 +2473,14 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
                 /* create files and links */
                 tmp_rc = mfu_create_files(levels2, minlevel2, lists2, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
 
                 /* copy data */
-                tmp_rc = mfu_copy_files(spreadlist, mfu_copy_opts->chunk_size,
-                        numpaths, paths, destpath, mfu_copy_opts);
+                tmp_rc = mfu_copy_files(spreadlist, numpaths, paths, destpath,
+                    copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -2379,7 +2491,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
                 /* set permissions, ownership, and timestamps if needed */
                 mfu_copy_set_metadata(levels2, minlevel2, lists2, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
                 /* free our lists of levels */
                 mfu_flist_array_free(levels2, &lists2);
@@ -2466,7 +2578,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* set permissions, ownership, and timestamps if needed */
         mfu_copy_set_metadata_dirs(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
         /* force updates to disk */
         mfu_sync_all("Syncing directory updates to disk.");
@@ -2475,14 +2587,14 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* create files and links */
         tmp_rc = mfu_create_files(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
 
         /* copy data */
-        tmp_rc = mfu_copy_files(src_cp_list, mfu_copy_opts->chunk_size,
-                numpaths, paths, destpath, mfu_copy_opts);
+        tmp_rc = mfu_copy_files(src_cp_list, numpaths, paths, destpath,
+            copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -2493,7 +2605,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* set permissions, ownership, and timestamps if needed */
         mfu_copy_set_metadata(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
         /* force updates to disk */
         mfu_sync_all("Syncing directory updates to disk.");
@@ -2503,8 +2615,8 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
     mfu_flist_array_free(levels, &lists);
 
     /* free buffers */
-    mfu_free(&mfu_copy_opts->block_buf1);
-    mfu_free(&mfu_copy_opts->block_buf2);
+    mfu_free(&copy_opts->block_buf1);
+    mfu_free(&copy_opts->block_buf2);
 
     /* Determine the actual and relative end time for the epilogue. */
     mfu_copy_stats.wtime_ended = MPI_Wtime();
@@ -2642,17 +2754,17 @@ static int mfu_fill_file(
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_file)
 {
-    int ret;
-
     /* open the file */
-    int out_fd = mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, mfu_copy_opts);
-    if (out_fd < 0) {
+    int ret = mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, copy_opts, mfu_file);
+    if (ret) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open output file `%s' (errno=%d %s)",
             dest, errno, strerror(errno));
         return -1;
     }
+    int out_fd = mfu_file->fd;
 
     /* seek to offset in file */
     if (mfu_lseek(dest, out_fd, offset, SEEK_SET) == (off_t)-1) {
@@ -2662,8 +2774,8 @@ static int mfu_fill_file(
     }
 
     /* get buffer */
-    size_t buf_size = mfu_copy_opts->block_size;
-    void* buf = mfu_copy_opts->block_buf1;
+    size_t buf_size = copy_opts->block_size;
+    void* buf = copy_opts->block_buf1;
 
     /* fill buffer with data */
 
@@ -2678,7 +2790,7 @@ static int mfu_fill_file(
         }
 
         /* compute number of bytes to write */
-        if (mfu_copy_opts->synchronous) {
+        if (copy_opts->direct) {
             /* O_DIRECT requires particular write sizes,
              * ok to write beyond end of file so long as
              * we truncate in cleanup step */
@@ -2715,7 +2827,6 @@ static int mfu_fill_file(
     /* Increment the global counter. */
     //mfu_copy_stats.total_size += (int64_t) total_bytes;
     //mfu_copy_stats.total_bytes_copied += (int64_t) total_bytes;
-
 #if 0
     /* force data to file system */
     if(total_bytes > 0) {
@@ -2742,19 +2853,19 @@ static int mfu_fill_file(
     return ret;
 }
 
-int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
+int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* copy_opts, mfu_file_t* mfu_file)
 {
     int rc = MFU_SUCCESS;
 
     /* allocate buffer to write files, aligned on 1MB boundaraies */
     size_t alignment = 1024*1024;
-    mfu_copy_opts->block_buf1 = (char*) MFU_MEMALIGN(mfu_copy_opts->block_size, alignment);
+    copy_opts->block_buf1 = (char*) MFU_MEMALIGN(copy_opts->block_size, alignment);
 
     /* fill buffer with data */
-    //memset(mfu_copy_opts->block_buf1, 0, mfu_copy_opts->block_size);
+    //memset(copy_opts->block_buf1, 0, copy_opts->block_size);
     size_t idx;
-    for (idx = 0; idx < mfu_copy_opts->block_size; idx++) {
-        mfu_copy_opts->block_buf1[idx] = (char) rand();
+    for (idx = 0; idx < copy_opts->block_size; idx++) {
+        copy_opts->block_buf1[idx] = (char) rand();
     }
 
     /* determine whether we should print status messages */
@@ -2784,7 +2895,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
 
     /* split file list into a linked list of file sections,
      * this evenly spreads the file sections across processes */
-    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, mfu_copy_opts->chunk_size);
+    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, copy_opts->chunk_size);
 
     /* get a count of how many items are the chunk list */
     uint64_t list_count = mfu_file_chunk_list_size(head);
@@ -2807,7 +2918,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
         /* copy portion of file corresponding to this chunk,
          * and record whether copy operation succeeded */
         int copy_rc = mfu_fill_file(p->name, (uint64_t)p->offset,
-                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts);
+                (uint64_t)p->length, (uint64_t)p->file_size, copy_opts, mfu_file);
         if (copy_rc < 0) {
             /* error copying file */
             vals[i] = 1;
@@ -2818,7 +2929,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
     }
 
     /* close files */
-    mfu_copy_close_file(&mfu_copy_dst_cache);
+    mfu_copy_close_file(&mfu_copy_dst_cache, mfu_file);
 
     /* barrier to ensure all files are closed,
      * may try to unlink bad destination files below */
@@ -2893,7 +3004,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
     }
 
     /* force data to backend to avoid the following metadata
-      * setting mismatch, which may happen on lustre */
+     * setting mismatch, which may happen on lustre */
      mfu_sync_all("Syncing data to disk.");
 
     /* determine whether any process reported an error,
@@ -2901,13 +3012,16 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
     int all_rc;
     MPI_Allreduce(&rc, &all_rc, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);
     rc = all_rc;
-
     return rc;
 }
 
-int mfu_flist_hardlink(mfu_flist src_link_list,
-        const mfu_param_path* srcpath, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts)
+int mfu_flist_hardlink(
+    mfu_flist src_link_list,
+    const mfu_param_path* srcpath,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -2916,14 +3030,12 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
-    /* set mfu_copy options in mfu_copy_opts_t struct */
-
     /* copy the destination path to user opts structure */
-    mfu_copy_opts->dest_path = MFU_STRDUP((*destpath).path);
+    copy_opts->dest_path = MFU_STRDUP((*destpath).path);
 
     /* print note about what we're doing and the amount of files/data to be moved */
     if (rank == 0) {
-        MFU_LOG(MFU_LOG_INFO, "Linking to %s", mfu_copy_opts->dest_path);
+        MFU_LOG(MFU_LOG_INFO, "Linking to %s", copy_opts->dest_path);
     }
     mfu_flist_print_summary(src_link_list);
 
@@ -2952,7 +3064,7 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
 
     /* create directories, from top down */
     int tmp_rc = mfu_create_directories(levels, minlevel, lists, 1,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
@@ -2964,14 +3076,14 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
      * has better idea for it. */
     /* create hard links */
     tmp_rc = mfu_create_hardlinks(levels, minlevel, lists,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
 
     /* set permissions, ownership, and timestamps if needed */
     mfu_copy_set_metadata(levels, minlevel, lists, 1,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* force updates to disk */
     mfu_sync_all("Syncing directory updates to disk.");
@@ -3037,7 +3149,9 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
     return rc;
 }
 
-int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist dst_list, uint64_t dst_index)
+int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index,
+                             mfu_flist dst_list, uint64_t dst_index,
+                             mfu_file_t* mfu_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -3055,7 +3169,7 @@ int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist d
 
     /* update ownership on destination if needed */
     if ((src_uid != dst_uid) || (src_gid != dst_gid)) {
-        tmp_rc = mfu_copy_ownership(src_list, src_index, dest_path);
+        tmp_rc = mfu_copy_ownership(src_list, src_index, dest_path, mfu_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -3065,19 +3179,13 @@ int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist d
     mode_t src_mode = (mode_t) mfu_flist_file_get_mode(src_list, src_index);
     mode_t dst_mode = (mode_t) mfu_flist_file_get_mode(dst_list, dst_index);
     if (src_mode != dst_mode) {
-        tmp_rc = mfu_copy_permissions(src_list, src_index, dest_path);
+        tmp_rc = mfu_copy_permissions(src_list, src_index, dest_path, mfu_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
     }
 
     /* TODO: test ACLs and update if different */
-    /* 
-    tmp_rc = mfu_copy_acls(src_list, src_index, dest_path);
-    if (tmp_rc < 0) {
-        rc = -1;
-    }
-    */
 
     /* get atime seconds and nsecs */
     uint64_t src_atime      = mfu_flist_file_get_atime(src_list, src_index);
@@ -3095,7 +3203,7 @@ int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist d
     if ((src_atime != dst_atime) || (src_atime_nsec != dst_atime_nsec) ||
         (src_mtime != dst_mtime) || (src_mtime_nsec != dst_mtime_nsec))
     {
-        tmp_rc = mfu_copy_timestamps(src_list, src_index, dest_path);
+        tmp_rc = mfu_copy_timestamps(src_list, src_index, dest_path, mfu_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -3104,6 +3212,28 @@ int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist d
     return rc;
 }
 
+/* return a newly allocated mfu_file structure, set default values on its fields */
+mfu_file_t* mfu_file_new(void)
+{
+    mfu_file_t* mfile = (mfu_file_t*) MFU_MALLOC(sizeof(mfu_file_t));
+    mfile->type       = POSIX;
+    mfile->fd         = -1;
+#ifdef DAOS_SUPPORT
+    mfile->obj        = NULL;
+    mfile->dfs        = NULL;
+    mfile->dfs_hash   = NULL;
+#endif
+    return mfile;
+}
+
+void mfu_file_delete(mfu_file_t** pfile)
+{
+  if (pfile != NULL) {
+    mfu_file_t* mfile = *pfile;
+    mfu_free(pfile);
+  }
+}
+
 /* return a newly allocated copy_opts structure, set default values on its fields */
 mfu_copy_opts_t* mfu_copy_opts_new(void)
 {
@@ -3113,36 +3243,43 @@ mfu_copy_opts_t* mfu_copy_opts_new(void)
     opts->copy_into_dir = 0;
 
     /* By default, we want the sync option off */
-    opts->do_sync       = 0;
+    opts->do_sync = 0;
 
     /* to record destination path that we'll be copying to */
-    opts->dest_path     = NULL;
+    opts->dest_path = NULL;
 
     /* records name of input file to read source list from (not used?) */
-    opts->input_file    = NULL;
+    opts->input_file = NULL;
 
     /* By default, don't bother to preserve all attributes. */
-    opts->preserve      = false;
+    opts->preserve = false;
+
+    /* By default, don't dereference source symbolic links. 
+     * This is not a perfect opposite of no_dereference */
+    opts->dereference = 0;
+
+    /* By default, dereference source symbolic links in the access check */
+    opts->no_dereference = 0;
 
     /* By default, don't use O_DIRECT. */
-    opts->synchronous   = false;
+    opts->direct = false;
 
     /* By default, don't use sparse file. */
-    opts->sparse        = false;
+    opts->sparse = false;
 
     /* Set default chunk size */
-    opts->chunk_size    = FD_CHUNK_SIZE;
+    opts->chunk_size = MFU_CHUNK_SIZE;
 
     /* temporaries used during the copy operation for buffers to read/write data */
-    opts->block_size    = FD_BLOCK_SIZE;
-    opts->block_buf1    = NULL;
-    opts->block_buf2    = NULL;
+    opts->block_size = MFU_BLOCK_SIZE;
+    opts->block_buf1 = NULL;
+    opts->block_buf2 = NULL;
 
     /* Zero is invalid for the Lustre grouplock ID. */
-    opts->grouplock_id  = 0;
+    opts->grouplock_id = 0;
 
     /* By default, do not limit the batch size */
-    opts->batch_files   = 0;
+    opts->batch_files = 0;
 
     return opts;
 }
diff --git a/src/common/mfu_flist_walk.c b/src/common/mfu_flist_walk.c
index 264bf2a..6c4a2e0 100644
--- a/src/common/mfu_flist_walk.c
+++ b/src/common/mfu_flist_walk.c
@@ -50,6 +50,8 @@ static const char** CURRENT_DIRS;
 static flist_t* CURRENT_LIST;
 static int SET_DIR_PERMS;
 static int REMOVE_FILES;
+static int DEREFERENCE;
+static mfu_file_t** CURRENT_PFILE;
 
 /****************************************
  * Global counter and callbacks for LIBCIRCLE reductions
@@ -152,17 +154,21 @@ static void walk_getdents_process_dir(const char* dir, CIRCLE_handle* handle)
     char buf[BUF_SIZE];
 
     /* TODO: may need to try these functions multiple times */
-    int fd = mfu_open(dir, O_RDONLY | O_DIRECTORY);
-    if (fd == -1) {
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
+    mfu_file_open(dir, O_RDONLY | O_DIRECTORY, mfu_file);
+    if (mfu_file->fd == -1) {
         /* print error */
         MFU_LOG(MFU_LOG_ERR, "Failed to open directory for reading: `%s' (errno=%d %s)", dir, errno, strerror(errno));
         return;
     }
 
+#if !defined(SYS_getdents) && defined(SYS_getdents64)
+#define SYS_getdents SYS_getdents64
+#endif
     /* Read all directory entries */
     while (1) {
         /* execute system call to get block of directory entries */
-        int nread = syscall(SYS_getdents, fd, buf, (int) BUF_SIZE);
+        int nread = syscall(SYS_getdents, mfu_file->fd, buf, (int) BUF_SIZE);
         if (nread == -1) {
             MFU_LOG(MFU_LOG_ERR, "syscall to getdents failed when reading `%s' (errno=%d %s)", dir, errno, strerror(errno));
             break;
@@ -243,7 +249,7 @@ static void walk_getdents_process_dir(const char* dir, CIRCLE_handle* handle)
         }
     }
 
-    mfu_close(dir, fd);
+    mfu_file_close(dir, mfu_file);
 
     return;
 }
@@ -257,9 +263,11 @@ static void walk_getdents_create(CIRCLE_handle* handle)
 
         /* stat top level item */
         struct stat st;
-        int status = mfu_lstat(path, &st);
+        mfu_file_t* mfu_file = *CURRENT_PFILE;
+        int status = mfu_file_lstat(path, &st, mfu_file);
         if (status != 0) {
-            /* TODO: print error */
+            MFU_LOG(MFU_LOG_ERR, "Failed to stat: '%s' (errno=%d %s)",
+                    path, errno, strerror(errno));
             return;
         }
 
@@ -296,35 +304,33 @@ static void walk_getdents_process(CIRCLE_handle* handle)
 static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
 {
     /* TODO: may need to try these functions multiple times */
-    DIR* dirp = mfu_opendir(dir);
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
+    DIR* dirp = mfu_file_opendir(dir, mfu_file);
 
     /* if there is a permissions error and the usr read & execute are being turned
      * on when walk_stat=0 then catch the permissions error and turn the bits on */
     if (dirp == NULL) {
         if (errno == EACCES && SET_DIR_PERMS) {
             struct stat st;
-            mfu_lstat(dir, &st);
+            mfu_file_t* mfu_file = *CURRENT_PFILE;
+            int status = mfu_file_lstat(dir, &st, mfu_file);
             // turn on the usr read & execute bits
             st.st_mode |= S_IRUSR;
             st.st_mode |= S_IXUSR;
-            mfu_chmod(dir, st.st_mode);
-            dirp = mfu_opendir(dir);
-            if (dirp == NULL) {
-                if (errno == EACCES) {
-                    MFU_LOG(MFU_LOG_ERR, "Failed to open directory with opendir: `%s' (errno=%d %s)", dir, errno, strerror(errno));
-                }
-            }
+            mfu_file_chmod(dir, st.st_mode, mfu_file);
+            dirp = mfu_file_opendir(dir, mfu_file);
         }
     }
 
     if (! dirp) {
-        /* TODO: print error */
+        MFU_LOG(MFU_LOG_ERR, "Failed to open directory with opendir: '%s' (errno=%d %s)",
+                dir, errno, strerror(errno));
     }
     else {
         /* Read all directory entries */
         while (1) {
             /* read next directory entry */
-            struct dirent* entry = mfu_readdir(dirp);
+            struct dirent* entry = mfu_file_readdir(dirp, mfu_file);
             if (entry == NULL) {
                 break;
             }
@@ -349,7 +355,7 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
                         /* unlink files here if remove option is on,
                          * and dtype is known without a stat */
                         if (REMOVE_FILES && (entry->d_type != DT_DIR)) {
-                            mfu_unlink(newpath);
+                            mfu_file_unlink(newpath, mfu_file);
                         } else {
                             /* we can read object type from directory entry */
                             have_mode = 1;
@@ -360,20 +366,21 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
                     else {
                         /* type is unknown, we need to stat it */
                         struct stat st;
-                        int status = mfu_lstat(newpath, &st);
+                        int status = mfu_file_lstat(newpath, &st, mfu_file);
                         if (status == 0) {
                             have_mode = 1;
                             mode = st.st_mode;
                             /* unlink files here if remove option is on,
                              * and stat was necessary to get type */
                             if (REMOVE_FILES && !S_ISDIR(st.st_mode)) {
-                                mfu_unlink(newpath);
+                                mfu_file_unlink(newpath, mfu_file);
                             } else {
                                 mfu_flist_insert_stat(CURRENT_LIST, newpath, mode, &st);
                             }
                         }
                         else {
-                            /* error */
+                            MFU_LOG(MFU_LOG_ERR, "Failed to stat: '%s' (errno=%d %s)",
+                                    newpath, errno, strerror(errno));
                         }
                     }
 
@@ -395,7 +402,7 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
         }
     }
 
-    mfu_closedir(dirp);
+    mfu_file_closedir(dirp, mfu_file);
 
     return;
 }
@@ -409,9 +416,11 @@ static void walk_readdir_create(CIRCLE_handle* handle)
 
         /* stat top level item */
         struct stat st;
-        int status = mfu_lstat(path, &st);
+        mfu_file_t* mfu_file = *CURRENT_PFILE;
+        int status = mfu_file_lstat(path, &st, mfu_file);
         if (status != 0) {
-            /* TODO: print error */
+            MFU_LOG(MFU_LOG_ERR, "Failed to stat: '%s' (errno=%d %s)",
+                    path, errno, strerror(errno));
             return;
         }
 
@@ -448,15 +457,17 @@ static void walk_readdir_process(CIRCLE_handle* handle)
 static void walk_stat_process_dir(char* dir, CIRCLE_handle* handle)
 {
     /* TODO: may need to try these functions multiple times */
-    DIR* dirp = mfu_opendir(dir);
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
+    DIR* dirp = mfu_file_opendir(dir, mfu_file);
 
     if (! dirp) {
-        /* TODO: print error */
+        MFU_LOG(MFU_LOG_ERR, "Failed to open directory with opendir: '%s' (errno=%d %s)",
+                dir, errno, strerror(errno));
     }
     else {
         while (1) {
             /* read next directory entry */
-            struct dirent* entry = mfu_readdir(dirp);
+            struct dirent* entry = mfu_file_readdir(dirp, mfu_file);
             if (entry == NULL) {
                 break;
             }
@@ -483,9 +494,7 @@ static void walk_stat_process_dir(char* dir, CIRCLE_handle* handle)
             }
         }
     }
-
-    mfu_closedir(dirp);
-
+    mfu_file_closedir(dirp, mfu_file);
     return;
 }
 
@@ -506,12 +515,21 @@ static void walk_stat_process(CIRCLE_handle* handle)
     /* get path from queue */
     char path[CIRCLE_MAX_STRING_LEN];
     handle->dequeue(path);
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
 
     /* stat item */
     struct stat st;
-    int status = mfu_lstat(path, &st);
+    int status;
+    if (DEREFERENCE) {
+        /* if symlink, stat the symlink value */
+        status = mfu_file_stat(path, &st, mfu_file);
+    } else {
+        /* if symlink, stat the symlink itself */
+        status = mfu_file_lstat(path, &st, mfu_file);
+    }
     if (status != 0) {
-        /* print error */
+        MFU_LOG(MFU_LOG_ERR, "Failed to stat: '%s' (errno=%d %s)",
+                path, errno, strerror(errno));
         return;
     }
 
@@ -521,7 +539,7 @@ static void walk_stat_process(CIRCLE_handle* handle)
     /* TODO: filter items by stat info */
 
     if (REMOVE_FILES && !S_ISDIR(st.st_mode)) {
-        mfu_unlink(path);
+        mfu_file_unlink(path, mfu_file);
     } else {
         /* record info for item in list */
         mfu_flist_insert_stat(CURRENT_LIST, path, st.st_mode, &st);
@@ -539,28 +557,29 @@ static void walk_stat_process(CIRCLE_handle* handle)
             if (!((usr_r_mask & st.st_mode) && (usr_x_mask & st.st_mode))) {
                 st.st_mode |= S_IRUSR;
                 st.st_mode |= S_IXUSR;
-                mfu_chmod(path, st.st_mode);
+                mfu_file_chmod(path, st.st_mode, mfu_file);
             }
         }
-
         /* TODO: check that we can recurse into directory */
         walk_stat_process_dir(path, handle);
     }
-
     return;
 }
 
 /* Set up and execute directory walk */
-void mfu_flist_walk_path(const char* dirpath, mfu_walk_opts_t* walk_opts,
-                         mfu_flist bflist)
+void mfu_flist_walk_path(const char* dirpath,
+                         mfu_walk_opts_t* walk_opts,
+                         mfu_flist bflist,
+                         mfu_file_t* mfu_file)
 {
-    mfu_flist_walk_paths(1, &dirpath, walk_opts, bflist);
+    mfu_flist_walk_paths(1, &dirpath, walk_opts, bflist, mfu_file);
     return;
 }
 
 /* Set up and execute directory walk */
 void mfu_flist_walk_paths(uint64_t num_paths, const char** paths,
-                          mfu_walk_opts_t* walk_opts, mfu_flist bflist)
+                          mfu_walk_opts_t* walk_opts, mfu_flist bflist,
+                          mfu_file_t* mfu_file)
 {
     /* report walk count, time, and rate */
     double start_walk = MPI_Wtime();
@@ -577,6 +596,12 @@ void mfu_flist_walk_paths(uint64_t num_paths, const char** paths,
         REMOVE_FILES = 1;
     }
 
+    /* if dereference is set to 1 then set global variable */
+    DEREFERENCE = 0;
+    if (walk_opts->dereference) {
+        DEREFERENCE = 1;
+    }
+
     /* convert handle to flist_t */
     flist_t* flist = (flist_t*) bflist;
 
@@ -622,6 +647,7 @@ void mfu_flist_walk_paths(uint64_t num_paths, const char** paths,
     }
 
     /* register callbacks */
+    CURRENT_PFILE = &mfu_file;
     if (walk_opts->use_stat) {
         /* walk directories by calling stat on every item */
         CIRCLE_cb_create(&walk_stat_create);
@@ -681,11 +707,19 @@ void mfu_flist_walk_paths(uint64_t num_paths, const char** paths,
 void mfu_flist_walk_param_paths(uint64_t num,
                                 const mfu_param_path* params,
                                 mfu_walk_opts_t* walk_opts,
-                                mfu_flist flist)
+                                mfu_flist flist,
+                                mfu_file_t* mfu_file)
 {
     /* allocate memory to hold a list of paths */
     const char** path_list = (const char**) MFU_MALLOC(num * sizeof(char*));
 
+    /* DAOS only supports using one source path */
+    if (mfu_file->type == DAOS) {
+        if (num != 1) {
+            MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
+        }
+    }
+
     /* fill list of paths and print each one */
     uint64_t i;
     for (i = 0; i < num; i++) {
@@ -694,7 +728,7 @@ void mfu_flist_walk_param_paths(uint64_t num,
     }
 
     /* walk file tree and record stat data for each file */
-    mfu_flist_walk_paths((uint64_t) num, path_list, walk_opts, flist);
+    mfu_flist_walk_paths((uint64_t) num, path_list, walk_opts, flist, mfu_file);
 
     /* free the list */
     mfu_free(&path_list);
@@ -709,7 +743,9 @@ void mfu_flist_stat(
   mfu_flist input_flist,
   mfu_flist flist,
   mfu_flist_skip_fn skip_fn,
-  void *skip_args)
+  void *skip_args,
+  int dereference,
+  mfu_file_t* mfu_file)
 {
     flist_t* file_list = (flist_t*)flist;
 
@@ -740,11 +776,34 @@ void mfu_flist_stat(
             continue;
         }
 
+        /* If the dereference flag is passed in, try to dereference all paths.
+         * Otherwise, if we have stat info for the mode, and the path is
+         * not a link, then try to dereference it.
+         * This accounts for dwalk --dereference, because a link might be
+         * stored as a file, meaning that it should be dereferenced */
+        bool do_dereference = false;
+        if (dereference) {
+            do_dereference = true;
+        } else {
+            mode_t mode = mfu_flist_file_get_mode(input_flist, idx);
+            if (mode && !S_ISLNK(mode)) {
+                do_dereference = true;
+            }
+        }
+        
         /* stat the item */
         struct stat st;
-        int status = mfu_lstat(name, &st);
+        int status;
+        if (do_dereference) {
+            /* dereference symbolic link */
+            status = mfu_file_stat(name, &st, mfu_file);
+        } else {
+            /* don't dereference symbolic links */
+            status = mfu_file_lstat(name, &st, mfu_file);
+        }
         if (status != 0) {
-            MFU_LOG(MFU_LOG_ERR, "mfu_lstat() failed: `%s' rc=%d (errno=%d %s)", name, status, errno, strerror(errno));
+            MFU_LOG(MFU_LOG_ERR, "mfu_lstat() failed: '%s' rc=%d (errno=%d %s)",
+                    name, status, errno, strerror(errno));
             continue;
         }
 
diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 0ec97da..51815bc 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -1,3 +1,5 @@
+#define _GNU_SOURCE
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -9,13 +11,266 @@
 #include <string.h>
 #include <errno.h>
 #include <stdarg.h>
+#include <assert.h>
+#include <libgen.h>
+
+#ifdef DAOS_SUPPORT
+#include <gurt/common.h>
+#include <gurt/hash.h>
+#endif
 
 #include "mfu.h"
 
 #define MFU_IO_TRIES  (5)
 #define MFU_IO_USLEEP (100)
 
+static int mpi_rank;
+
+#ifdef DAOS_SUPPORT
+/* Handle for a hash table entry */
+struct daos_dir_hdl {
+    d_list_t    entry;
+    dfs_obj_t*  oh;
+    char*       name;
+};
+
+/* Return a newly allocated daos_dir_hdl structure */
+static struct daos_dir_hdl* daos_dir_hdl_new(void)
+{
+    struct daos_dir_hdl* hdl = (struct daos_dir_hdl*) MFU_MALLOC(sizeof(struct daos_dir_hdl));
+    hdl->oh = NULL;
+    hdl->name = NULL;
+
+    return hdl;
+}
+
+/* free a daos_dir_hdl structure */
+static void daos_dir_hdl_delete(struct daos_dir_hdl** phdl)
+{
+    if (phdl != NULL) {
+        struct daos_dir_hdl* hdl = *phdl;
+        if (hdl->oh != NULL) {
+            dfs_release(hdl->oh);
+        }
+        mfu_free(&hdl->name);
+        mfu_free(phdl);
+    }
+}
+
+/* Get the daos_dir_hdl from its entry */
+static inline struct daos_dir_hdl* hdl_obj(d_list_t* rlink)
+{
+    return container_of(rlink, struct daos_dir_hdl, entry);
+}
+
+/* Simple string comparison of hdl->name as the key */
+static bool key_cmp(struct d_hash_table* htable, d_list_t* rlink, 
+        const void* key, unsigned int ksize)
+{
+    struct daos_dir_hdl* hdl = hdl_obj(rlink);
+
+    return (strcmp(hdl->name, (const char *)key) == 0);
+}
+
+/* Since we only delete entries when we are finished with them,
+ * this should always return true so rec_free is called */
+static bool rec_decref(struct d_hash_table* htable, d_list_t* rlink)
+{
+    return true;
+}
+
+/* Free a hash entry. Called when the table is destroyed */
+static void rec_free(struct d_hash_table* htable, d_list_t* rlink)
+{
+    struct daos_dir_hdl* hdl = hdl_obj(rlink);
+
+    assert(d_hash_rec_unlinked(&hdl->entry));
+    daos_dir_hdl_delete(&hdl);
+}
+
+/* Operations for the hash table */
+static d_hash_table_ops_t hdl_hash_ops = {
+    .hop_key_cmp    = key_cmp,
+    .hop_rec_decref = rec_decref,
+    .hop_rec_free   = rec_free
+};
+
+/* Caches calls to dfs_lookup and returns lookups from the cache.
+ * On error, sets errno and returns NULL */
+static dfs_obj_t* daos_hash_lookup(const char* name, mfu_file_t* mfu_file)
+{
+    struct daos_dir_hdl* hdl;
+    d_list_t* rlink;
+    int rc;
+
+    /* Make sure the hash is initialized */
+    if (mfu_file->dfs_hash == NULL) {
+        rc = d_hash_table_create(D_HASH_FT_NOLOCK, 16, NULL, &hdl_hash_ops, &mfu_file->dfs_hash);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to initialize dir hashtable");
+            errno = ENOMEM;
+            return NULL;
+        }
+    }
+
+    /* If cached, return it */
+    rlink = d_hash_rec_find(mfu_file->dfs_hash, name, strlen(name));
+    if (rlink != NULL) {
+        hdl = hdl_obj(rlink);
+        return hdl->oh;
+    }
+
+    /* Create a new entry */
+    hdl = daos_dir_hdl_new();
+    if (hdl == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to initialze hash entry");
+        daos_dir_hdl_delete(&hdl);
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    /* Allocate space for name, up to PATH_MAX,
+     * leaving 1 extra for the null terminator */
+    size_t name_len = strnlen(name, PATH_MAX);
+    if (name_len > PATH_MAX-1) {
+        daos_dir_hdl_delete(&hdl);
+        errno = ENAMETOOLONG;
+        return NULL;
+    }
+    hdl->name = MFU_STRDUP(name);
+
+    /* Lookup the object handle */
+    rc = dfs_lookup(mfu_file->dfs, name, O_RDWR, &hdl->oh, NULL, NULL);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup() of %s Failed", name);
+        daos_dir_hdl_delete(&hdl);
+        errno = rc;
+        return NULL;
+    }
+
+    /* Store this entry in the hash.
+     * Since we have already called d_hash_rec_find,
+     * pass exclusive=false to avoid another find being called */
+    rc = d_hash_rec_insert(mfu_file->dfs_hash, hdl->name, name_len,
+                            &hdl->entry, false);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to insert hash entry");
+        daos_dir_hdl_delete(&hdl);
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    /* Return the object */
+    return hdl->oh;
+}
+
+static int parse_filename(const char* path, char** _obj_name, char** _cont_name)
+{
+	char *f1 = NULL;
+	char *f2 = NULL;
+	char *fname = NULL;
+	char *cont_name = NULL;
+	int rc = 0;
+
+	if (path == NULL || _obj_name == NULL || _cont_name == NULL)
+		return -EINVAL;
+
+	if (strcmp(path, "/") == 0) {
+		*_cont_name = strdup("/");
+		if (*_cont_name == NULL)
+			return -ENOMEM;
+		*_obj_name = NULL;
+		return 0;
+	}
+
+	f1 = strdup(path);
+	if (f1 == NULL) {
+                rc = -ENOMEM;
+                goto out;
+        }
+
+	f2 = strdup(path);
+	if (f2 == NULL) {
+                rc = -ENOMEM;
+                goto out;
+        }
+
+	fname = basename(f1);
+	cont_name = dirname(f2);
+
+	if (cont_name[0] == '.' || cont_name[0] != '/') {
+		char cwd[1024];
+
+		if (getcwd(cwd, 1024) == NULL) {
+                        rc = -ENOMEM;
+                        goto out;
+                }
+
+		if (strcmp(cont_name, ".") == 0) {
+			cont_name = strdup(cwd);
+			if (cont_name == NULL) {
+                                rc = -ENOMEM;
+                                goto out;
+                        }
+		} else {
+			char *new_dir = calloc(strlen(cwd) + strlen(cont_name)
+					       + 1, sizeof(char));
+			if (new_dir == NULL) {
+                                rc = -ENOMEM;
+                                goto out;
+                        }
+
+			strcpy(new_dir, cwd);
+			if (cont_name[0] == '.') {
+				strcat(new_dir, &cont_name[1]);
+			} else {
+				strcat(new_dir, "/");
+				strcat(new_dir, cont_name);
+			}
+			cont_name = new_dir;
+		}
+		*_cont_name = cont_name;
+	} else {
+		*_cont_name = strdup(cont_name);
+		if (*_cont_name == NULL) {
+                        rc = -ENOMEM;
+                        goto out;
+                }
+	}
+
+	*_obj_name = strdup(fname);
+	if (*_obj_name == NULL) {
+		free(*_cont_name);
+		*_cont_name = NULL;
+                rc = -ENOMEM;
+                goto out;
+	}
+
+out:
+	if (f1)
+		free(f1);
+	if (f2)
+		free(f2);
+	return rc;
+}
+
+#endif /* DAOS_SUPPORT */
+
 /* calls access, and retries a few times if we get EIO or EINTR */
+int mfu_file_access(const char* path, int amode, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_access(path, amode);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_access(path, amode, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 int mfu_access(const char* path, int amode)
 {
     int rc;
@@ -36,7 +291,161 @@ retry:
     return rc;
 }
 
+int daos_access(const char* path, int amode, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } else {
+        rc = dfs_access(mfu_file->dfs, parent, name, amode);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_access %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+    
+    return rc;
+#else
+    return 0;
+#endif
+}
+
+/* calls faccessat, and retries a few times if we get EIO or EINTR */
+int mfu_file_faccessat(int dirfd, const char* path, int amode, int flags, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_faccessat(dirfd, path, amode, flags);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_faccessat(dirfd, path, amode, flags, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    } 
+}
+
+int mfu_faccessat(int dirfd, const char* path, int amode, int flags)
+{
+    int rc;
+    int tries = MFU_IO_TRIES;
+retry:
+    errno = 0;
+    rc = faccessat(dirfd, path, amode, flags);
+    if (rc != 0) {
+        if (errno == EINTR || errno == EIO) {
+            tries--;
+            if (tries > 0) {
+                /* sleep a bit before consecutive tries */
+                usleep(MFU_IO_USLEEP);
+                goto retry;
+            }
+        }
+    }
+    return rc;
+}
+
+/* Emulates faccessat for a DAOS path */
+int daos_faccessat(int dirfd, const char* path, int amode, int flags, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* Only current working directory supported at this time */
+    if (dirfd != AT_FDCWD) {
+        errno = ENOTSUP;
+        return -1;
+    }
+
+    /* Only real user and group IDs supported at this time */
+    if (flags & AT_EACCESS) {
+        errno = ENOTSUP;
+        return -1;
+    }
+
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } else {
+        /* Get the mode of the object */
+        mode_t mode;
+        dfs_obj_t* obj;
+        int lookup_flags = O_RDWR;
+        if (flags & AT_SYMLINK_NOFOLLOW) {
+            lookup_flags |= O_NOFOLLOW;
+        }
+        rc = dfs_lookup_rel(mfu_file->dfs, parent, name, lookup_flags, &obj, &mode, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s/%s failed", dir_name, name);
+            errno = rc;
+            rc = -1;
+        } else {
+            /* return success for links, since dfs_access does not have proper support */
+            if (!S_ISLNK(mode)) {
+                rc = dfs_access(mfu_file->dfs, parent, name, amode);
+                if (rc) {
+                    MFU_LOG(MFU_LOG_ERR, "dfs_access %s failed (%d %s)",
+                            name, rc, strerror(rc));
+                    errno = rc;
+                    rc = -1;
+                }
+            }
+
+            /* Release the obj */
+            int tmp_rc = dfs_release(obj);
+            if (tmp_rc && (rc != -1)) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                        name, tmp_rc, strerror(tmp_rc));
+                errno = tmp_rc;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 /* calls lchown, and retries a few times if we get EIO or EINTR */
+int mfu_file_lchown(const char* path, uid_t owner, gid_t group, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_lchown(path, owner, group);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_lchown(path, owner, group, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }    
+}
+
 int mfu_lchown(const char* path, uid_t owner, gid_t group)
 {
     int rc;
@@ -57,7 +466,49 @@ retry:
     return rc;
 }
 
-/* calls chmod, and retries a few times if we get EIO or EINTR */
+int daos_lchown(const char* path, uid_t owner, gid_t group, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* At this time, DFS does not support updating the uid or gid.
+     * These are set at the container level, not file level */
+    return 0;
+#else
+    return 0;
+#endif
+}
+
+int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } else {
+        rc = dfs_chmod(mfu_file->dfs, parent, name, mode);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_chmod %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 int mfu_chmod(const char* path, mode_t mode)
 {
     int rc;
@@ -78,8 +529,38 @@ retry:
     return rc;
 }
 
+/* calls chmod, and retries a few times if we get EIO or EINTR */
+int mfu_file_chmod(const char* path, mode_t mode, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_chmod(path, mode);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_chmod(path, mode, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 /* calls utimensat, and retries a few times if we get EIO or EINTR */
-int mfu_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags)
+int mfu_file_utimensat(int dirfd, const char* pathname, const struct timespec times[2], int flags,
+                       mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_utimensat(dirfd, pathname, times, flags);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_utimensat(dirfd, pathname, times, flags, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  pathname, mfu_file->type);
+    }
+}
+
+int mfu_utimensat(int dirfd, const char* pathname, const struct timespec times[2], int flags)
 {
     int rc;
     int tries = MFU_IO_TRIES;
@@ -99,9 +580,184 @@ retry:
     return rc;
 }
 
-/* calls lstat, and retries a few times if we get EIO or EINTR */
-int mfu_lstat(const char* path, struct stat* buf)
+/* Emulates utimensat by calling dfs_osetattr */
+int daos_utimensat(int dirfd, const char* pathname, const struct timespec times[2], int flags,
+                   mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* Only current working directory supported at this time */
+    if (dirfd != AT_FDCWD) {
+        errno = ENOTSUP;
+        return -1;
+    }
+
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(pathname, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } else {
+        /* Lookup the object */
+        dfs_obj_t* obj;
+        int lookup_flags = O_RDWR;
+        if (flags & AT_SYMLINK_NOFOLLOW) {
+            lookup_flags |= O_NOFOLLOW;
+        }
+        rc = dfs_lookup_rel(mfu_file->dfs, parent, name, lookup_flags, &obj, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed", pathname);
+            errno = rc;
+            rc = -1;
+        } else {
+            /* Set the times on the obj */
+            if (rc != -1) {
+                struct stat stbuf;
+                stbuf.st_atim = times[0];
+                stbuf.st_mtim = times[1];
+                rc = dfs_osetattr(mfu_file->dfs, obj, &stbuf, DFS_SET_ATTR_ATIME | DFS_SET_ATTR_MTIME);
+                if (rc) {
+                    MFU_LOG(MFU_LOG_ERR, "dfs_osetattr %s failed", pathname);
+                    errno = rc;
+                    rc = -1;
+                }
+            }
+
+            /* Release the obj */
+            int tmp_rc = dfs_release(obj);
+            if (tmp_rc && (rc != -1)) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                        pathname, tmp_rc, strerror(tmp_rc));
+                errno = tmp_rc;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
+/* Since dfs_stat() performs like lstat(), this is emulated. */
+int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
 {
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+        goto out_free_name;
+    }
+
+    /* Lookup name within the parent */
+    dfs_obj_t* obj;
+    rc = dfs_lookup_rel(mfu_file->dfs, parent, name, O_RDWR, &obj, NULL, buf);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s / %s failed", dir_name, name);
+        errno = rc;
+        rc = -1;
+        goto out_free_name;
+    }
+
+    dfs_release(obj);
+out_free_name:
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
+int mfu_stat(const char* path, struct stat* buf) {
+    int rc;
+    int tries = MFU_IO_TRIES;
+retry:
+    errno = 0;
+    rc = stat(path, buf);
+    if (rc != 0) {
+        if (errno == EINTR || errno == EIO) {
+            tries--;
+            if (tries > 0) {
+                /* sleep a bit before consecutive tries */
+                usleep(MFU_IO_USLEEP);
+                goto retry;
+            }
+        }
+    }
+    return rc;
+}
+
+/* calls stat, and retries a few times if we get EIO or EINTR */
+int mfu_file_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_stat(path, buf);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_stat(path, buf, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
+/* lstat a DAOS path */
+int daos_lstat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } else {
+        /* Stat the path.
+         * dfs_stat interrogates the link itself */
+        rc = dfs_stat(mfu_file->dfs, parent, name, buf);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_stat %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
+int mfu_lstat(const char* path, struct stat* buf) {
     int rc;
     int tries = MFU_IO_TRIES;
 retry:
@@ -120,6 +776,21 @@ retry:
     return rc;
 }
 
+/* calls lstat, and retries a few times if we get EIO or EINTR */
+int mfu_file_lstat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_lstat(path, buf);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_lstat(path, buf, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 /* calls lstat64, and retries a few times if we get EIO or EINTR */
 int mfu_lstat64(const char* path, struct stat64* buf)
 {
@@ -141,7 +812,66 @@ retry:
     return rc;
 }
 
-/* call mknod, retry a few times on EINTR or EIO */
+/* emulates mknod with dfs_open, dfs_release */
+int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* Only regular files are supported at this time */
+    mode_t dfs_mode = mode | S_IFREG;
+    mode_t filetype = dfs_mode & S_IFMT;
+    if (filetype != S_IFREG) {
+        MFU_LOG(MFU_LOG_ERR, "Invalid entry type (not a file)");
+        errno = EINVAL;
+        return -1;
+    }
+
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    }
+    else {
+        /* create regular file */
+        rc = dfs_open(mfu_file->dfs, parent, name,
+                      dfs_mode, O_CREAT | O_EXCL,
+                      0, 0, NULL, &(mfu_file->obj));
+        if (rc) {
+            /* Avoid excessive logging */
+            if (rc != EEXIST) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_open %s failed (%d %s)",
+                        name, rc, strerror(rc));
+            }
+            errno = rc;
+            rc = -1;
+        }
+        else {
+            /* close the file */
+            rc = dfs_release(mfu_file->obj);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 int mfu_mknod(const char* path, mode_t mode, dev_t dev)
 {
     int rc;
@@ -162,6 +892,21 @@ retry:
     return rc;
 }
 
+/* call mknod, retry a few times on EINTR or EIO */
+int mfu_file_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_mknod(path, mode, dev);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_mknod(path, mode, dev, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 /* call remove, retry a few times on EINTR or EIO */
 int mfu_remove(const char* path)
 {
@@ -187,6 +932,63 @@ retry:
  * Links
  ****************************/
 
+/* emulates readlink with dfs_lookup, dfs_get_symlink_value */
+ssize_t daos_readlink(const char* path, char* buf, size_t bufsize, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    daos_size_t got_size = (daos_size_t) bufsize;
+
+    /* Lookup the parent directory first, since it is likely cached */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        got_size = -1;
+    } else { 
+        /* Lookup the symlink within the parent */
+        dfs_obj_t* sym_obj;
+        int lookup_flags = O_RDWR | O_NOFOLLOW;
+        int rc = dfs_lookup_rel(mfu_file->dfs, parent, name, lookup_flags, &sym_obj, NULL, NULL);
+        if (sym_obj == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed", path);
+            errno = rc;
+            got_size = -1;
+        } else {
+            /* Read the symlink value. This also makes sure it is S_IFLNK */
+            rc = dfs_get_symlink_value(sym_obj, buf, &got_size);
+            if (rc) {
+                errno = rc;
+                got_size = -1;
+            } else {
+                /* got_size includes the NULL terminator, but mfu_file_readlink
+                * expects that it does not */
+                got_size--;
+            }
+
+            /* Release the symlink */
+            rc = dfs_release(sym_obj);
+            if (rc && (got_size != -1)) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return (ssize_t) got_size;
+
+#else
+    return (ssize_t) 0;
+#endif
+}
+
 /* call readlink, retry a few times on EINTR or EIO */
 ssize_t mfu_readlink(const char* path, char* buf, size_t bufsize)
 {
@@ -208,6 +1010,71 @@ retry:
     return rc;
 }
 
+ssize_t mfu_file_readlink(const char* path, char* buf, size_t bufsize, mfu_file_t* mfu_file)
+{
+    int rc;
+
+    if (mfu_file->type == POSIX) {
+        rc = mfu_readlink(path, buf, bufsize);
+    } else if (mfu_file->type == DAOS) {
+        rc = daos_readlink(path, buf, bufsize, mfu_file);
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+
+    return rc;
+}
+
+/* emulates symlink for a DAOS symlink */
+int daos_symlink(const char* oldpath, const char* newpath, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(newpath, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } else {
+        /* open/create the symlink */
+        rc = dfs_open(mfu_file->dfs, parent, name,
+                      S_IFLNK, O_CREAT | O_EXCL,
+                      0, 0, oldpath, &(mfu_file->obj));
+        if (rc) {
+            /* Avoid excessive logging */
+            if (rc != EEXIST) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_open %s failed (%d %s)",
+                        name, rc, strerror(rc));
+            }
+            errno = rc;
+            rc = -1;
+        } else {
+            /* close the symlink */
+            rc = dfs_release(mfu_file->obj);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                        newpath, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 /* call symlink, retry a few times on EINTR or EIO */
 int mfu_symlink(const char* oldpath, const char* newpath)
 {
@@ -229,6 +1096,22 @@ retry:
     return rc;
 }
 
+int mfu_file_symlink(const char* oldpath, const char* newpath, mfu_file_t* mfu_file)
+{
+    int rc;
+
+    if (mfu_file->type == POSIX) {
+        rc = mfu_symlink(oldpath, newpath);
+    } else if (mfu_file->type == DAOS) {
+        rc = daos_symlink(oldpath, newpath, mfu_file);
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  oldpath, mfu_file->type);
+    }
+
+    return rc;
+}
+
 /* call hardlink, retry a few times on EINTR or EIO */
 int mfu_hardlink(const char* oldpath, const char* newpath)
 {
@@ -253,6 +1136,75 @@ retry:
 /*****************************
  * Files
  ****************************/
+int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* Only regular files are supported at this time */
+    mode_t dfs_mode = mode | S_IFREG;
+    if (!S_ISREG(dfs_mode)) {
+        MFU_LOG(MFU_LOG_ERR, "Invalid entry type (not a file)");
+        errno = EINVAL;
+        return -1;
+    }
+
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(file, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } else {
+        mode_t obj_mode;
+        rc = dfs_lookup_rel(mfu_file->dfs, parent, name, O_RDWR, &(mfu_file->obj),
+                            &obj_mode, NULL);
+        if (!rc) {
+            /* lookup found an obj */
+            if (flags & O_CREAT && flags & O_EXCL) {
+                /* ... but it should not have */
+                dfs_release(mfu_file->obj);
+                errno = EEXIST;
+                rc = -1;
+            } else if (!S_ISREG(obj_mode)) {
+                /* ... but the obj isn't a file */
+                dfs_release(mfu_file->obj);
+                MFU_LOG(MFU_LOG_ERR, "Invalid entry type (not a file)");
+                errno = EINVAL;
+                rc = -1;
+            } else {
+                /* good */
+            }
+        } else if (rc == ENOENT && flags & O_CREAT) {
+            /* call dfs_open so it can be created */
+            rc = dfs_open(mfu_file->dfs, parent, name,
+                          dfs_mode, flags,
+                          0, 0, NULL, &(mfu_file->obj));
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_open %s failed (%d %s)",
+                        name, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+        } else if (rc) {
+            /* this is actually an error */
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s/%s failed", dir_name, name);
+            errno = rc;
+            rc = -1;
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
 
 /* open file with specified flags and mode, retry open a few times on failure */
 int mfu_open(const char* file, int flags, ...)
@@ -297,13 +1249,56 @@ int mfu_open(const char* file, int flags, ...)
             tries--;
         }
 
-        /* if we still don't have a valid file, consider it an error */
-        if (fd < 0) {
-            /* we could abort, but probably don't want to here */
+         /* if we still don't have a valid file, consider it an error */
+         if (fd < 0) {
+             /* we could abort, but probably don't want to here */
+         }
+    }
+    return fd;
+}
+
+void mfu_file_open(const char* file, int flags, mfu_file_t* mfu_file, ...)
+{
+    /* extract the mode (see man 2 open) */
+    int mode_set = 0;
+    mode_t mode  = 0;
+    if (flags & O_CREAT) {
+        va_list ap;
+        va_start(ap, mfu_file);
+        mode = va_arg(ap, mode_t);
+        va_end(ap);
+        mode_set = 1;
+    }
+
+    if (mfu_file->type == POSIX) {
+        if (mode_set) {
+            mfu_file->fd = mfu_open(file, flags, mode);
+        } else {
+            mfu_file->fd = mfu_open(file, flags);
         }
+    } else if (mfu_file->type == DAOS) {
+        daos_open(file, flags, mode, mfu_file);
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
     }
+}
 
-    return fd;
+/* release an open object */
+int daos_close(const char* file, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    int rc = dfs_release(mfu_file->obj);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_close %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    return rc;
+#else
+    return 0;
+#endif
 }
 
 /* close file */
@@ -326,6 +1321,42 @@ retry:
     return rc;
 }
 
+int mfu_file_close(const char* file, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_close(file, mfu_file->fd);
+        if (rc == 0) {
+            mfu_file->fd = -1;
+        }
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_close(file, mfu_file);
+#ifdef DAOS_SUPPORT
+        if (rc == 0) {
+            mfu_file->obj = NULL;
+        }
+#endif
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
+int daos_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence)
+{
+#ifdef DAOS_SUPPORT
+    if (whence == SEEK_SET) {
+        mfu_file->offset = (daos_off_t)pos;
+    } else {
+        MFU_ABORT(-1, "daos_lseek whence type not known: %d", whence);
+    }
+    return 0;
+#else
+    return 0;
+#endif
+}
+
 /* seek file descriptor to specified position */
 off_t mfu_lseek(const char* file, int fd, off_t pos, int whence)
 {
@@ -343,28 +1374,244 @@ retry:
             }
         }
     }
-    return rc;
+    return rc;
+}
+
+off_t mfu_file_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence)
+{
+    if (mfu_file->type == POSIX) {
+        off_t rc = mfu_lseek(file, mfu_file->fd, pos, whence);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        off_t rc = daos_lseek(file, mfu_file, pos, whence);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
+/* reliable read from file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t got_size = mfu_read(file, mfu_file->fd, buf, size);
+        return got_size;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t got_size = daos_read(file, buf, size, mfu_file);
+        return got_size;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
+ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, buf, size);
+
+    /* define scatter-gather list for dfs_read */
+    d_sg_list_t sgl;
+    sgl.sg_nr = 1;
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+
+    /* execute read operation */
+    daos_size_t got_size;
+    int rc = dfs_read(mfu_file->dfs, mfu_file->obj, &sgl, mfu_file->offset, &got_size, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_read %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        return -1;
+    }
+
+    /* update file pointer with number of bytes read */
+    mfu_file->offset += (daos_off_t)got_size;
+
+    return (ssize_t)got_size;
+#else
+    return (ssize_t)0;
+#endif
+}
+
+ssize_t mfu_read(const char* file, int fd, void* buf, size_t size)
+{
+    int tries = MFU_IO_TRIES;
+    ssize_t n = 0;
+    while ((size_t)n < size) {
+        errno = 0;
+        ssize_t rc = read(fd, (char*) buf + n, size - (size_t)n);
+        if (rc > 0) {
+            /* read some data */
+            n += rc;
+            tries = MFU_IO_TRIES;
+
+            /* return, even if we got a short read */
+            return n;
+        }
+        else if (rc == 0) {
+            /* EOF */
+            return n;
+        }
+        else {   /* (rc < 0) */
+            /* something worth printing an error about */
+            tries--;
+            if (tries <= 0) {
+                /* too many failed retries, give up */
+                MFU_ABORT(-1, "Failed to read file %s errno=%d (%s)",
+                            file, errno, strerror(errno)
+                           );
+            }
+
+            /* sleep a bit before consecutive tries */
+            usleep(MFU_IO_USLEEP);
+        }
+    }
+    return n;
+}
+
+/* reliable write to file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t num_bytes_written = mfu_write(file, mfu_file->fd, buf, size);
+        return num_bytes_written;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t num_bytes_written = daos_write(file, buf, size, mfu_file);
+        return num_bytes_written;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
+ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size)
+{
+    int tries = MFU_IO_TRIES;
+    ssize_t n = 0;
+    while ((size_t)n < size) {
+        errno = 0;
+        ssize_t rc = write(fd, (const char*) buf + n, size - (size_t)n);
+        if (rc > 0) {
+            /* wrote some data */
+            n += rc;
+            tries = MFU_IO_TRIES;
+        }
+        else if (rc == 0) {
+            /* something bad happened, print an error and abort */
+            MFU_ABORT(-1, "Failed to write file %s errno=%d (%s)",
+                        file, errno, strerror(errno)
+                       );
+        }
+        else {   /* (rc < 0) */
+            /* something worth printing an error about */
+            tries--;
+            if (tries <= 0) {
+                /* too many failed retries, give up */
+                MFU_ABORT(-1, "Failed to write file %s errno=%d (%s)",
+                            file, errno, strerror(errno)
+                           );
+            }
+
+            /* sleep a bit before consecutive tries */
+            usleep(MFU_IO_USLEEP);
+        }
+    }
+    return n;
+}
+
+ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, (void*) buf, size);
+
+    /* define scatter-gather list for dfs_write */
+    d_sg_list_t sgl;
+    sgl.sg_nr = 1;
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+
+    /* execute write operation,
+     * dfs_write writes all bytes if there is no error */
+    int rc = dfs_write(mfu_file->dfs, mfu_file->obj, &sgl, mfu_file->offset, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_write %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        return -1;
+    }
+
+    /* update file pointer with number of bytes written */
+    mfu_file->offset += (daos_off_t)size;
+
+    return (ssize_t)size;
+#else
+    return (ssize_t)0;
+#endif
+}
+
+/* reliable pread from file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_pread(file, mfu_file->fd, buf, size, offset);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_pread(file, buf, size, offset, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+            file, mfu_file->type);
+    }
+}
+
+ssize_t daos_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, buf, size);
+
+    /* define scatter-gather list for dfs_read */
+    d_sg_list_t sgl;
+    sgl.sg_nr = 1;
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+
+    /* execute read operation */
+    daos_size_t got_size;
+    int rc = dfs_read(mfu_file->dfs, mfu_file->obj, &sgl, offset, &got_size, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_read %s failed (%d %s)",
+            file, rc, strerror(rc));
+        errno = rc;
+        return -1;
+    }
+
+    return (ssize_t)got_size;
+#else
+    return (ssize_t)0;
+#endif
 }
 
-/* reliable read from file descriptor (retries, if necessary, until hard error) */
-ssize_t mfu_read(const char* file, int fd, void* buf, size_t size)
+ssize_t mfu_pread(const char* file, int fd, void* buf, size_t size, off_t offset)
 {
     int tries = MFU_IO_TRIES;
-    ssize_t n = 0;
-    while ((size_t)n < size) {
-        errno = 0;
-        ssize_t rc = read(fd, (char*) buf + n, size - (size_t)n);
+    while (1) {
+        ssize_t rc = pread(fd, (char*) buf, size, offset);
         if (rc > 0) {
             /* read some data */
-            n += rc;
-            tries = MFU_IO_TRIES;
-
-            /* return, even if we got a short read */
-            return n;
+            return rc;
         }
         else if (rc == 0) {
             /* EOF */
-            return n;
+            return rc;
         }
         else {   /* (rc < 0) */
             /* something worth printing an error about */
@@ -372,51 +1619,99 @@ ssize_t mfu_read(const char* file, int fd, void* buf, size_t size)
             if (tries <= 0) {
                 /* too many failed retries, give up */
                 MFU_ABORT(-1, "Failed to read file %s errno=%d (%s)",
-                            file, errno, strerror(errno)
-                           );
+                    file, errno, strerror(errno));
             }
 
             /* sleep a bit before consecutive tries */
             usleep(MFU_IO_USLEEP);
         }
     }
-    return n;
 }
 
-/* reliable write to file descriptor (retries, if necessary, until hard error) */
-ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size)
+ssize_t mfu_file_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
 {
-    int tries = 10;
-    ssize_t n = 0;
-    while ((size_t)n < size) {
-        errno = 0;
-        ssize_t rc = write(fd, (const char*) buf + n, size - (size_t)n);
+    if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_pwrite(file, mfu_file->fd, buf, size, offset);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_pwrite(file, buf, size, offset, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+            file, mfu_file->type);
+    }
+}
+
+ssize_t mfu_pwrite(const char* file, int fd, const void* buf, size_t size, off_t offset)
+{
+    int tries = MFU_IO_TRIES;
+    while (1) {
+        ssize_t rc = pwrite(fd, (const char*) buf, size, offset);
         if (rc > 0) {
             /* wrote some data */
-            n += rc;
-            tries = MFU_IO_TRIES;
+            return rc;
         }
         else if (rc == 0) {
-            /* something bad happened, print an error and abort */
-            MFU_ABORT(-1, "Failed to write file %s errno=%d (%s)",
-                        file, errno, strerror(errno)
-                       );
+            /* didn't write anything, but not an error either */
+            return rc;
         }
-        else {   /* (rc < 0) */
+        else { /* (rc < 0) */
             /* something worth printing an error about */
             tries--;
             if (tries <= 0) {
                 /* too many failed retries, give up */
                 MFU_ABORT(-1, "Failed to write file %s errno=%d (%s)",
-                            file, errno, strerror(errno)
-                           );
+                    file, errno, strerror(errno));
             }
 
             /* sleep a bit before consecutive tries */
             usleep(MFU_IO_USLEEP);
         }
     }
-    return n;
+}
+
+ssize_t daos_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, (void*) buf, size);
+
+    /* define scatter-gather list for dfs_write */
+    d_sg_list_t sgl;
+    sgl.sg_nr = 1;
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+
+    /* execute write operation,
+     * dfs_write writes all bytes if there is no error */
+    int rc = dfs_write(mfu_file->dfs, mfu_file->obj, &sgl, offset, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_write %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        return -1;
+    }
+
+    return (ssize_t)size;
+#else
+    return (ssize_t)0;
+#endif
+}
+
+/* truncate a file */
+int mfu_file_truncate(const char* file, off_t length, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_truncate(file, length);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_truncate(file, length, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
 }
 
 /* truncate a file */
@@ -440,7 +1735,80 @@ retry:
     return rc;
 }
 
-/* ftruncate a file */
+int daos_truncate(const char* file, off_t length, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(file, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        errno = ENOENT;
+        rc = -1;
+    } else {
+        /* open the obj in the parent */
+        dfs_obj_t* obj;
+        rc = dfs_open(mfu_file->dfs, parent, name,
+                      S_IFREG, O_RDWR,
+                      0, 0, NULL, &obj);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_open %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        } else {
+            /* truncate the obj */
+            daos_off_t offset = (daos_off_t) length;
+            rc = dfs_punch(mfu_file->dfs, obj, offset, DFS_MAX_FSIZE);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_punch failed (%d %s)",
+                        rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+
+            /* close the obj */
+            int tmp_rc = dfs_release(mfu_file->obj);
+            if (tmp_rc && (rc != -1)) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                        file, tmp_rc, strerror(tmp_rc));
+                errno = tmp_rc;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
+int daos_ftruncate(mfu_file_t* mfu_file, off_t length)
+{
+#ifdef DAOS_SUPPORT
+    daos_off_t offset = (daos_off_t) length;
+    int rc = dfs_punch(mfu_file->dfs, mfu_file->obj, offset, DFS_MAX_FSIZE);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_punch failed (%d %s)",
+                rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 int mfu_ftruncate(int fd, off_t length)
 {
     int rc;
@@ -461,6 +1829,75 @@ retry:
     return rc;
 }
 
+/* ftruncate a file */
+int mfu_file_ftruncate(mfu_file_t* mfu_file, off_t length)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_ftruncate(mfu_file->fd, length);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_ftruncate(mfu_file, length);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
+/* unlink a file */
+int mfu_file_unlink(const char* file, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_unlink(file);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_unlink(file, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    } 
+}
+
+/* emulates unlink on a DAOS file or symlink.
+ * Since checking the file type would require another
+ * lookup, for performance considerations,
+ * this also works on directories. */
+int daos_unlink(const char* file, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(file, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    } 
+    else {
+        /* remove the file */
+        rc = dfs_remove(mfu_file->dfs, parent, name, false, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_remove failed (%d %s)",
+                    rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 /* delete a file */
 int mfu_unlink(const char* file)
 {
@@ -519,7 +1956,43 @@ void mfu_getcwd(char* buf, size_t size)
     }
 }
 
-/* create directory, retry a few times on EINTR or EIO */
+int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(dir, &name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* only call mkdir if name is not the root DFS directory */
+    if (name && strcmp(name, "/") != 0) {
+        /* Lookup the parent directory */
+        dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+        if (parent == NULL) {
+            rc = -1;
+        } else {
+            /* Make the directory */
+            rc = dfs_mkdir(mfu_file->dfs, parent, name, mode, 0);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_mkdir %s failed (%d %s)", 
+                        name, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 int mfu_mkdir(const char* dir, mode_t mode)
 {
     int rc;
@@ -540,6 +2013,21 @@ retry:
     return rc;
 }
 
+/* create directory, retry a few times on EINTR or EIO */
+int mfu_file_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_mkdir(dir, mode);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_mkdir(dir, mode, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  dir, mfu_file->type);
+    }
+}
+
 /* remove directory, retry a few times on EINTR or EIO */
 int mfu_rmdir(const char* dir)
 {
@@ -561,6 +2049,83 @@ retry:
     return rc;
 }
 
+#define NUM_DIRENTS 24
+
+#ifdef DAOS_SUPPORT
+struct dfs_mfu_t {
+    dfs_obj_t* dir;
+    struct dirent ents[NUM_DIRENTS];
+    daos_anchor_t anchor;
+    int num_ents;
+};
+#endif
+
+/* open directory. The entry itself is not cached in mfu_file->dir_hash */
+DIR* daos_opendir(const char* dir, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    struct dfs_mfu_t* dirp = calloc(1, sizeof(*dirp));
+    if (dirp == NULL) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(dir, &name, &dir_name);
+    assert(dir_name);
+
+    if (!name || strcmp(name, "/") == 0) {
+        /* For root, just lookup the entry */
+        int rc = dfs_lookup(mfu_file->dfs, dir, O_RDWR, &dirp->dir, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir);
+            errno = rc;
+            free(dirp);
+            return NULL;
+        }
+    } else {
+        /* for non-root, try to cache the parent */
+        dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+        if (parent == NULL) {
+            goto err_dirp;
+        } else {
+            mode_t mode;
+            int rc = dfs_lookup_rel(mfu_file->dfs, parent, name, O_RDWR, &dirp->dir,
+                                   &mode, NULL);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed", dir);
+                errno = rc;
+                goto err_dirp;
+            } else {
+                if (!S_ISDIR(mode)) {
+                    errno = ENOTDIR;
+                    rc = dfs_release(dirp->dir);
+                    if (rc) {
+                        MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                                dir, rc, strerror(rc));
+                    }
+                    goto err_dirp;
+                }
+            }
+        }
+    }
+
+    mfu_free(&dir_name);
+    mfu_free(&name);
+
+    return (DIR *)dirp;
+
+err_dirp:
+    mfu_free(&dir_name);
+    mfu_free(&name);
+    free(dirp);
+    return NULL;
+#else
+    return NULL;
+#endif
+}
+
 /* open directory, retry a few times on EINTR or EIO */
 DIR* mfu_opendir(const char* dir)
 {
@@ -582,6 +2147,40 @@ retry:
     return dirp;
 }
 
+/* open directory, retry a few times on EINTR or EIO */
+DIR* mfu_file_opendir(const char* dir, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        DIR* dirp = mfu_opendir(dir);
+        return dirp;
+    } else if (mfu_file->type == DAOS) {
+        DIR* dirp = daos_opendir(dir, mfu_file);
+        return dirp;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  dir, mfu_file->type);
+    }
+}
+
+/* close dir. This is not cached in mfu_file->dir_hash */
+int daos_closedir(DIR* _dirp, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    struct dfs_mfu_t *dirp = (struct dfs_mfu_t *)_dirp;
+    int rc = dfs_release(dirp->dir);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d %s)",
+                rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    free(dirp);
+    return rc;
+#else
+    return 0;
+#endif
+}
+
 /* close directory, retry a few times on EINTR or EIO */
 int mfu_closedir(DIR* dirp)
 {
@@ -603,6 +2202,54 @@ retry:
     return rc;
 }
 
+int mfu_file_closedir(DIR* dirp, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_closedir(dirp);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_closedir(dirp, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
+struct dirent* daos_readdir(DIR* _dirp, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    struct dfs_mfu_t *dirp = (struct dfs_mfu_t *)_dirp;
+    if (dirp->num_ents) {
+        goto ret;
+    }
+    dirp->num_ents = NUM_DIRENTS;
+    int rc;
+    while (!daos_anchor_is_eof(&dirp->anchor)) {
+        rc = dfs_readdir(mfu_file->dfs, dirp->dir,
+                         &dirp->anchor, &dirp->num_ents,
+                         dirp->ents);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_readdir failed (%d %s)", rc, strerror(rc));
+            dirp->num_ents = 0;
+            errno = ENOENT;
+            return NULL;
+        }
+        if (dirp->num_ents == 0) {
+            continue;
+        }
+        goto ret;
+    }
+    assert(daos_anchor_is_eof(&dirp->anchor));
+    return NULL;
+ret:
+    dirp->num_ents--;
+    return &dirp->ents[dirp->num_ents];
+#else
+    return NULL;
+#endif
+}
+
 /* read directory entry, retry a few times on ENOENT, EIO, or EINTR */
 struct dirent* mfu_readdir(DIR* dirp)
 {
@@ -624,3 +2271,422 @@ retry:
     }
     return entry;
 }
+
+struct dirent* mfu_file_readdir(DIR* dirp, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        struct dirent* entry = mfu_readdir(dirp);
+        return entry;
+    } else if (mfu_file->type == DAOS) {
+        struct dirent* entry = daos_readdir(dirp, mfu_file);
+        return entry;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
+/* list xattrs (link interrogation) */
+ssize_t mfu_file_llistxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_llistxattr(path, list, size);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_llistxattr(path, list, size, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
+ssize_t mfu_llistxattr(const char* path, char* list, size_t size)
+{
+    ssize_t rc = llistxattr(path, list, size);
+    return rc;
+}
+
+/* DAOS wrapper for dfs_listxattr that adjusts return
+ * codes and errno to be similar to POSIX llistxattr */
+ssize_t daos_llistxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    daos_size_t got_size = (daos_size_t) size;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        got_size = -1;
+    }
+    else {
+        /* lookup and open name */
+        dfs_obj_t* obj;
+        int lookup_flags = O_RDWR | O_NOFOLLOW;
+        int rc = dfs_lookup_rel(mfu_file->dfs, parent, name, lookup_flags, &obj, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed (%d %s)",
+                    path, rc, strerror(rc));
+            errno = rc;
+            got_size = -1;
+        } else {
+            /* list the xattrs */
+            rc = dfs_listxattr(mfu_file->dfs, obj, list, &got_size);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_listxattr %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                got_size = -1;
+            } else if (size == 0) {
+                /* we will just return got_size */
+            } else if (size < got_size) {
+                errno = ERANGE;
+                got_size = -1;
+            }
+
+            /* Release the obj.
+             * Don't log the error if we already have a different error. */
+            rc = dfs_release(obj);
+            if (rc && (got_size != -1)) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d %s)",
+                        rc, strerror(rc));
+                errno = rc;
+                got_size = -1;
+            }
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return (ssize_t) got_size;
+#else
+    return (ssize_t) 0;
+#endif
+}
+
+/* list xattrs (link dereference) */
+ssize_t mfu_file_listxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_listxattr(path, list, size);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_listxattr(path, list, size, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
+ssize_t mfu_listxattr(const char* path, char* list, size_t size)
+{
+    ssize_t rc = listxattr(path, list, size);
+    return rc;
+}
+
+/* DAOS wrapper for dfs_listxattr that adjusts return
+ * codes and errno to be similar to POSIX listxattr */
+ssize_t daos_listxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    daos_size_t got_size = (daos_size_t) size;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        got_size = -1;
+    }
+    else {
+        /* lookup the object */
+        dfs_obj_t* obj;
+        int rc = dfs_lookup_rel(mfu_file->dfs, parent, name, O_RDWR, &obj, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed (%d %s)",
+                    path, rc, strerror(rc));
+            errno = rc;
+            got_size = -1;
+        } else {
+            /* list the xattrs of the obj */
+            rc = dfs_listxattr(mfu_file->dfs, obj, list, &got_size);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_listxattr %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                got_size = -1;
+            } else if (size == 0) {
+                /* we will just return got_size */
+            } else if (size < got_size) {
+                errno = ERANGE;
+                got_size = -1;
+            }
+        }
+
+        /* Release the obj */
+        rc = dfs_release(obj);
+        if (rc && (got_size != -1)) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d %s)",
+                    rc, strerror(rc));
+            errno = rc;
+            got_size = -1;
+        }
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return (ssize_t) got_size;
+#else
+    return (ssize_t) 0;
+#endif
+}
+
+/* get xattrs (link interrogation) */
+ssize_t mfu_file_lgetxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file)
+{
+   if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_lgetxattr(path, name, value, size);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_lgetxattr(path, name, value, size, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    } 
+}
+
+ssize_t mfu_lgetxattr(const char* path, const char* name, void* value, size_t size)
+{
+    ssize_t rc = lgetxattr(path, name, value, size);
+    return rc;
+}
+
+ssize_t daos_lgetxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* obj_name = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &obj_name, &dir_name);
+    assert(dir_name);
+
+    daos_size_t got_size = (daos_size_t) size;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        got_size = -1;
+    }
+    else {
+        /* lookup and open obj_name */
+        dfs_obj_t* obj;
+        int lookup_flags = O_RDWR | O_NOFOLLOW;
+        int rc = dfs_lookup_rel(mfu_file->dfs, parent, obj_name, lookup_flags, &obj, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed (%d %s)",
+                    path, rc, strerror(rc));
+            errno = rc;
+            got_size = -1;
+        } else {
+            /* get the xattr */
+            rc = dfs_getxattr(mfu_file->dfs, obj, name, value, &got_size);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_getxattr %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                got_size = -1;
+            } else if (size == 0) {
+                /* we will just return got_size */
+            } else if (size < got_size) {
+                errno = ERANGE;
+                got_size = -1;
+            }
+
+            /* Release the obj */
+            rc = dfs_release(obj);
+            if (rc && (got_size != -1)) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d %s)",
+                        rc, strerror(rc));
+                errno = rc;
+                got_size = -1;
+            }
+        }
+    }
+
+    mfu_free(&obj_name);
+    mfu_free(&dir_name);
+
+    return (ssize_t) got_size;
+#else
+    return (ssize_t) 0;
+#endif
+}
+
+/* get xattrs (link dereference) */
+ssize_t mfu_file_getxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file)
+{
+   if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_getxattr(path, name, value, size);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_getxattr(path, name, value, size, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    } 
+}
+
+ssize_t mfu_getxattr(const char* path, const char* name, void* value, size_t size)
+{
+    ssize_t rc = getxattr(path, name, value, size);
+    return rc;
+}
+
+ssize_t daos_getxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* obj_name = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &obj_name, &dir_name);
+    assert(dir_name);
+
+    daos_size_t got_size = (daos_size_t) size;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        got_size = -1;
+    }
+    else {
+        /* lookup the object */
+        dfs_obj_t* obj;
+        int rc = dfs_lookup_rel(mfu_file->dfs, parent, obj_name, O_RDWR, &obj, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed (%d %s)",
+                    path, rc, strerror(rc));
+            errno = rc;
+            got_size = -1;
+        } else {
+            /* get the xattr of the obj */
+            rc = dfs_getxattr(mfu_file->dfs, obj, name, value, &got_size);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_getxattr %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                got_size = -1;
+            } else if (size == 0) {
+                /* we will just return got_size */
+            } else if (size < got_size) {
+                errno = ERANGE;
+                got_size = -1;
+            }
+        }
+
+        /* Release the obj */
+        rc = dfs_release(obj);
+        if (rc && (got_size != -1)) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d %s)",
+                    rc, strerror(rc));
+            errno = rc;
+            got_size = -1;
+        }
+    }
+
+    mfu_free(&obj_name);
+    mfu_free(&dir_name);
+
+    return (ssize_t) got_size;
+#else
+    return (ssize_t) 0;
+#endif
+}
+
+/* set xattrs (link interrogation) */
+int mfu_file_lsetxattr(const char* path, const char* name, const void* value, size_t size, int flags,
+                       mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_lsetxattr(path, name, value, size, flags);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_lsetxattr(path, name, value, size, flags, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
+int mfu_lsetxattr(const char* path, const char* name, const void* value, size_t size, int flags)
+{
+    int rc = lsetxattr(path, name, value, size, flags);
+    return rc;
+}
+
+int daos_lsetxattr(const char* path, const char* name, const void* value, size_t size, int flags,
+                   mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* obj_name = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &obj_name, &dir_name);
+    assert(dir_name);
+
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        rc = -1;
+    }
+    else {
+        /* lookup and open obj_name */
+        dfs_obj_t* obj;
+        int lookup_flags = O_RDWR | O_NOFOLLOW;
+        rc = dfs_lookup_rel(mfu_file->dfs, parent, obj_name, lookup_flags, &obj, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup_rel %s failed (%d %s)",
+                    path, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        } else {
+            /* set the xattr */
+            rc = dfs_setxattr(mfu_file->dfs, obj, name, value, size, flags);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_setxattr %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+
+            /* Release the obj */
+            int rc_rel = dfs_release(obj);
+            if (rc_rel && (rc != -1)) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d %s)",
+                        rc_rel, strerror(rc_rel));
+                errno = rc_rel;
+                rc = -1;
+            }
+        }
+    }
+
+    mfu_free(&obj_name);
+    mfu_free(&dir_name);
+
+    return rc;
+#else
+    return 0;
+#endif
+}
diff --git a/src/common/mfu_io.h b/src/common/mfu_io.h
index cbbf1c1..197c863 100644
--- a/src/common/mfu_io.h
+++ b/src/common/mfu_io.h
@@ -34,6 +34,13 @@ extern "C" {
 #include <fcntl.h>
 #include <dirent.h>
 
+#ifdef DAOS_SUPPORT
+#include <daos.h>
+#include <daos_fs.h>
+#endif
+
+#include "mfu_param_path.h"
+
 /* Intent is to wrap all POSIX I/O routines used by mfu tools.  May
  * abort on fatal conditions to avoid checking condition at every call.
  * May also automatically retry on things like EINTR. */
@@ -47,68 +54,155 @@ struct stat64;
  ****************************/
 
 /* calls access, and retries a few times if we get EIO or EINTR */
+int mfu_file_access(const char* path, int amode, mfu_file_t* mfu_file);
 int mfu_access(const char* path, int amode);
+int daos_access(const char* path, int amode, mfu_file_t* mfu_file);
+
+/* calls faccessat, and retries a few times if we get EIO or EINTR */
+int mfu_file_faccessat(int dirfd, const char* path, int amode, int flags, mfu_file_t* mfu_file);
+int mfu_faccessat(int dirfd, const char* path, int amode, int flags);
+int daos_faccessat(int dirfd, const char* path, int amode, int flags, mfu_file_t* mfu_file);
 
 /* calls lchown, and retries a few times if we get EIO or EINTR */
+int mfu_file_lchown(const char* path, uid_t owner, gid_t group, mfu_file_t* mfu_file);
 int mfu_lchown(const char* path, uid_t owner, gid_t group);
+int daos_lchown(const char* path, uid_t owner, gid_t group, mfu_file_t* mfu_file);
 
 /* calls chmod, and retries a few times if we get EIO or EINTR */
+int daos_chmod(const char* path, mode_t mode, mfu_file_t* mfu_file);
 int mfu_chmod(const char* path, mode_t mode);
+int mfu_file_chmod(const char* path, mode_t mode, mfu_file_t* mfu_file);
 
 /* calls utimensat, and retries a few times if we get EIO or EINTR */
+int mfu_file_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags,
+                       mfu_file_t* mfu_file);
 int mfu_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags);
+int daos_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags,
+                   mfu_file_t* mfu_file);
 
 /* calls lstat, and retries a few times if we get EIO or EINTR */
+int mfu_file_lstat(const char* path, struct stat* buf, mfu_file_t* mfu_file);
 int mfu_lstat(const char* path, struct stat* buf);
+int daos_lstat(const char* path, struct stat* buf, mfu_file_t* mfu_file);
 
-/* calls lstat, and retries a few times if we get EIO or EINTR */
+/* only dcp1 calls mfu_lstat64, is it necessary? */
 int mfu_lstat64(const char* path, struct stat64* buf);
 
+/* calls stat, and retries a few times if we get EIO or EINTR */
+int mfu_file_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file);
+int mfu_stat(const char* path, struct stat* buf);
+int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file);
+
 /* call mknod, retry a few times on EINTR or EIO */
+int mfu_file_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file);
+int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file);
 int mfu_mknod(const char* path, mode_t mode, dev_t dev);
 
 /* call remove, retry a few times on EINTR or EIO */
 int mfu_remove(const char* path);
 
+/* read directory entry, retry a few times on ENOENT, EIO, or EINTR */
+struct dirent* mfu_file_readdir(DIR* dirp, mfu_file_t* mfu_file);
+struct dirent* mfu_readdir(DIR* dirp);
+struct dirent* daos_readdir(DIR* dirp, mfu_file_t* mfu_file);
+
+/* list xattrs (link interrogation) */
+ssize_t mfu_file_llistxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file);
+ssize_t mfu_llistxattr(const char* path, char* list, size_t size);
+ssize_t daos_llistxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file);
+
+/* list xatters (link dereference */
+ssize_t mfu_file_listxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file);
+ssize_t mfu_listxattr(const char* path, char* list, size_t size);
+ssize_t daos_listxattr(const char* path, char* list, size_t size, mfu_file_t* mfu_file);
+
+/* get xattrs (link interrogation) */
+ssize_t mfu_file_lgetxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file);
+ssize_t mfu_lgetxattr(const char* path, const char* name, void* value, size_t size);
+ssize_t daos_lgetxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file);
+
+/* get xattrs (link dereference) */
+ssize_t mfu_file_getxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file);
+ssize_t mfu_getxattr(const char* path, const char* name, void* value, size_t size);
+ssize_t daos_getxattr(const char* path, const char* name, void* value, size_t size, mfu_file_t* mfu_file);
+
+/* set xattrs (link interrogation) */
+int mfu_file_lsetxattr(const char* path, const char* name, const void* value, size_t size, int flags,
+                               mfu_file_t* mfu_file);
+int mfu_lsetxattr(const char* path, const char* name, const void* value, size_t size, int flags);
+int daos_lsetxattr(const char* path, const char* name, const void* value, size_t size, int flags,
+                           mfu_file_t* mfu_file);
+
 /*****************************
  * Links
  ****************************/
 
 /* call readlink, retry a few times on EINTR or EIO */
+ssize_t mfu_file_readlink(const char* path, char* buf, size_t bufsize, mfu_file_t* mfu_file);
+ssize_t daos_readlink(const char* path, char* buf, size_t bufsize, mfu_file_t* mfu_file);
 ssize_t mfu_readlink(const char* path, char* buf, size_t bufsize);
 
-/* call symlink, retry a few times on EINTR or EIO */
-int mfu_symlink(const char* oldpath, const char* newpath);
-
 /* call hardlink, retry a few times on EINTR or EIO */
 int mfu_hardlink(const char* oldpath, const char* newpath);
 
+/* call symlink, retry a few times on EINTR or EIO */
+int mfu_file_symlink(const char* oldpath, const char* newpath, mfu_file_t* mfu_file);
+int daos_symlink(const char* oldpath, const char* newpath, mfu_file_t* mfu_file);
+int mfu_symlink(const char* oldpath, const char* newpath);
+
 /*****************************
  * Files
  ****************************/
 
 /* open file with specified flags and mode, retry open a few times on failure */
+void mfu_file_open(const char* file, int flags, mfu_file_t* mfu_file, ...);
+int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file);
 int mfu_open(const char* file, int flags, ...);
 
 /* close file */
+int mfu_file_close(const char* file, mfu_file_t* mfu_file);
+int daos_close(const char* file, mfu_file_t* mfu_file);
 int mfu_close(const char* file, int fd);
 
 /* seek file descriptor to specified position */
+off_t mfu_file_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence);
+/* actually a noop since daos doesn't have an lseek */
+int daos_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence);
 off_t mfu_lseek(const char* file, int fd, off_t pos, int whence);
 
 /* reliable read from opened file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file);
+ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file);
 ssize_t mfu_read(const char* file, int fd, void* buf, size_t size);
 
 /* reliable write to opened file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file);
+ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file);
 ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size);
 
+/* pread from opened file descriptor (may return short read) */
+ssize_t mfu_file_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t daos_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t mfu_pread(const char* file, int fd, void* buf, size_t size, off_t offset);
+
+/* pwrite to opened file descriptor (may return short write) */
+ssize_t mfu_file_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t daos_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t mfu_pwrite(const char* file, int fd, const void* buf, size_t size, off_t offset);
+
 /* truncate a file */
+int mfu_file_truncate(const char* file, off_t length, mfu_file_t* mfu_file);
 int mfu_truncate(const char* file, off_t length);
+int daos_truncate(const char* file, off_t length, mfu_file_t* mfu_file);
 
 /* ftruncate a file */
+int mfu_file_ftruncate(mfu_file_t* mfu_file, off_t length);
+int daos_ftruncate(mfu_file_t* mfu_file, off_t length);
 int mfu_ftruncate(int fd, off_t length);
 
 /* delete a file */
+int mfu_file_unlink(const char* file, mfu_file_t* mfu_file);
+int daos_unlink(const char* file, mfu_file_t* mfu_file);
 int mfu_unlink(const char* file);
 
 /* force flush of written data */
@@ -122,19 +216,22 @@ int mfu_fsync(const char* file, int fd);
 void mfu_getcwd(char* buf, size_t size);
 
 /* create directory, retry a few times on EINTR or EIO */
+int mfu_file_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file);
 int mfu_mkdir(const char* dir, mode_t mode);
+int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file);
 
 /* remove directory, retry a few times on EINTR or EIO */
 int mfu_rmdir(const char* dir);
 
 /* open directory, retry a few times on EINTR or EIO */
+DIR* mfu_file_opendir(const char* dir, mfu_file_t* mfu_file);
 DIR* mfu_opendir(const char* dir);
+DIR* daos_opendir(const char* dir, mfu_file_t* mfu_file);
 
 /* close directory, retry a few times on EINTR or EIO */
+int mfu_file_closedir(DIR* dirp, mfu_file_t* mfu_file);
 int mfu_closedir(DIR* dirp);
-
-/* read directory entry, retry a few times on ENOENT, EIO, or EINTR */
-struct dirent* mfu_readdir(DIR* dirp);
+int daos_closedir(DIR* dirp, mfu_file_t* mfu_file);
 
 #endif /* MFU_IO_H */
 
diff --git a/src/common/mfu_param_path.c b/src/common/mfu_param_path.c
index d4c6a48..fb61e52 100644
--- a/src/common/mfu_param_path.c
+++ b/src/common/mfu_param_path.c
@@ -1,3 +1,5 @@
+#define _GNU_SOURCE
+
 #include "mfu.h"
 #include "mpi.h"
 
@@ -7,6 +9,9 @@
 #include <stdarg.h>
 #include <errno.h>
 
+#include <fcntl.h>
+#include <unistd.h>
+
 /* initialize fields in param */
 static void mfu_param_path_init(mfu_param_path* param)
 {
@@ -329,7 +334,8 @@ static void mfu_unpack_param(const char** pptr, mfu_param_path* param)
  * path to this item and then prepend destination prefix. */
 char* mfu_param_path_copy_dest(const char* name, int numpaths,
         const mfu_param_path* paths, const mfu_param_path* destpath, 
-        mfu_copy_opts_t* mfu_copy_opts)
+        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file,
+        mfu_file_t* mfu_dst_file)
 {
     /* identify which source directory this came from */
     int i;
@@ -397,7 +403,11 @@ char* mfu_param_path_copy_dest(const char* name, int numpaths,
 
 /* check that source and destination paths are valid */
 void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths, 
-        const mfu_param_path* destpath, int* flag_valid, int* flag_copy_into_dir)
+        const mfu_param_path* destpath, mfu_file_t* mfu_src_file,
+        mfu_file_t* mfu_dst_file,
+        int no_dereference,
+        int* flag_valid,
+        int* flag_copy_into_dir)
 {
     /* initialize output params */
     *flag_valid = 0;
@@ -417,15 +427,31 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
 
     /* just have rank 0 check */
     if(rank == 0) {
+        /* DAOS-specific error checks*/
+        if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
+            if (num != 1) {
+                MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
+                valid = 0;
+                goto bcast;
+            }
+        }
+        
         /* count number of readable source paths */
         uint64_t i;
         int num_readable = 0;
         for(i = 0; i < num; i++) {
             const char* path = paths[i].path;
-            if(mfu_access(path, R_OK) == 0) {
-                num_readable++;
+            int access_rc;
+            if (no_dereference) {
+                /* Don't dereference symlinks in the access call */
+                access_rc = mfu_file_faccessat(AT_FDCWD, path, R_OK, AT_SYMLINK_NOFOLLOW, mfu_src_file);
+            } else {
+                /* Do dereference symlinks in the access call */
+                access_rc = mfu_file_access(path, R_OK, mfu_src_file);
             }
-            else {
+            if (access_rc == 0) {
+                num_readable++;
+            } else {
                 /* found a source path that we can't read, not fatal,
                  * but print an error to notify user */
                 const char* orig = paths[i].orig;
@@ -507,7 +533,7 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
             }
 
             /* check that dest is writable */
-            if(mfu_access(destpath->path, W_OK) < 0) {
+            if(mfu_file_access(destpath->path, W_OK, mfu_dst_file) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Destination is not writable `%s'",
                     destpath->path);
                 valid = 0;
@@ -525,7 +551,7 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
             mfu_path_delete(&parent);
 
             /* check that parent is writable */
-            if(mfu_access(parent_str, W_OK) < 0) {
+            if(mfu_file_access(parent_str, W_OK, mfu_dst_file) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Destination parent directory is not writable `%s'",
                     parent_str);
                 valid = 0;
diff --git a/src/common/mfu_param_path.h b/src/common/mfu_param_path.h
index 9e6f4ed..e2b81c6 100644
--- a/src/common/mfu_param_path.h
+++ b/src/common/mfu_param_path.h
@@ -14,6 +14,7 @@ extern "C" {
 #include <stdbool.h>
 #include <stdint.h>
 #include "mpi.h"
+#include "mfu_io.h"
 
 /* for struct stat */
 #include <sys/types.h>
@@ -51,6 +52,19 @@ typedef struct mfu_param_path_t {
     struct stat target_stat; /* stat of target path */
 } mfu_param_path;
 
+/* options passed to I/O functions that tell them which backend filesystem to use */
+typedef struct {
+    enum                 {POSIX, DAOS} type;
+    int                  fd;
+#ifdef DAOS_SUPPORT
+    /* DAOS specific variables for I/O */
+    daos_off_t           offset;
+    dfs_obj_t*           obj;
+    dfs_t*               dfs;
+    struct d_hash_table* dfs_hash;
+#endif
+} mfu_file_t;
+
 /* set fields in param according to path */
 void mfu_param_path_set(const char* path, mfu_param_path* param);
 
@@ -75,32 +89,39 @@ void mfu_param_path_check_copy(
     uint64_t num,                   /* IN  - number of source paths */
     const mfu_param_path* paths,    /* IN  - array of source param paths */
     const mfu_param_path* destpath, /* IN  - dest param path */
+    mfu_file_t* mfu_src_file,       /* IN  - mfu_file for source that specifies which I/O calls to make */
+    mfu_file_t* mfu_dst_file,       /* IN  - mfu_file for destination that specifies which I/O calls to make */
+    int no_dereference,             /* IN  - if true, don't dereference source symbolic links */
     int* flag_valid,                /* OUT - flag indicating whether combination of source and dest param paths are valid (1) or not (0) */
     int* flag_copy_into_dir         /* OUT - flag indicating whether source items should be copied into destination directory (1) or not (0) */
 );
 
 /* options passed to walk that effect how the walk is executed */
 typedef struct {
-    int    dir_perms;    /* flag option to update dir perms during walk */
-    int    remove;       /* flag option to remove files during walk */
-    int    use_stat;     /* flag option on whether or not to stat files during walk */
+    int dir_perms;      /* flag option to update dir perms during walk */
+    int remove;         /* flag option to remove files during walk */
+    int use_stat;       /* flag option on whether or not to stat files during walk */
+    int dereference;    /* flag option to dereference symbolic links */
 } mfu_walk_opts_t;
 
 /* options passed to mfu_ */
 typedef struct {
-    int    copy_into_dir; /* flag indicating whether copying into existing dir */
-    int    do_sync;       /* flag option to sync src dir with dest dir */ 
-    char*  dest_path;     /* prefex of destination directory */
-    char*  input_file;    /* file name of input list */
-    bool   preserve;      /* whether to preserve timestamps, ownership, permissions, etc. */
-    bool   synchronous;   /* whether to use O_DIRECT */
-    bool   sparse;        /* whether to create sparse files */
-    size_t chunk_size;    /* size to chunk files by */
-    size_t block_size;    /* block size to read/write to file system */
-    char*  block_buf1;    /* buffer to read / write data */
-    char*  block_buf2;    /* another buffer to read / write data */
-    int    grouplock_id;  /* Lustre grouplock ID */
-    uint64_t batch_files; /* max batch size to copy files, 0 implies no limit */
+    int    copy_into_dir;  /* flag indicating whether copying into existing dir */
+    int    do_sync;        /* flag option to sync src dir with dest dir */ 
+    char*  dest_path;      /* prefex of destination directory */
+    char*  input_file;     /* file name of input list */
+    bool   preserve;       /* whether to preserve timestamps, ownership, permissions, etc. */
+    int    dereference;    /* if true, dereference symbolic links in the source.
+                            * this is not a perfect opposite of no_dereference */
+    int    no_dereference; /* if true, don't dereference source symbolic links */
+    bool   direct;         /* whether to use O_DIRECT */
+    bool   sparse;         /* whether to create sparse files */
+    size_t chunk_size;     /* size to chunk files by */
+    size_t block_size;     /* block size to read/write to file system */
+    char*  block_buf1;     /* buffer to read / write data */
+    char*  block_buf2;     /* another buffer to read / write data */
+    int    grouplock_id;   /* Lustre grouplock ID */
+    uint64_t batch_files;  /* max batch size to copy files, 0 implies no limit */
 } mfu_copy_opts_t;
 
 /* Given a source item name, determine which source path this item
@@ -114,7 +135,9 @@ char* mfu_param_path_copy_dest(
     int numpaths,                   /* IN  - number of source paths */
     const mfu_param_path* paths,    /* IN  - array of source param paths */
     const mfu_param_path* destpath, /* IN  - dest param path */
-    mfu_copy_opts_t* mfu_copy_opts  /* IN  - options to be used during copy */
+    mfu_copy_opts_t* mfu_copy_opts, /* IN  - options to be used during copy */
+    mfu_file_t* mfu_src_file,       /* IN  - I/O filesystem functions to use for copy of src */
+    mfu_file_t* mfu_dst_file        /* IN  - I/O filesystem functions to use for copy of dst */
 );
 
 #endif /* MFU_PARAM_PATH_H */
diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index edd8703..ca93932 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -4,6 +4,7 @@
 #include "mfu.h"
 #include "mpi.h"
 #include "dtcmp.h"
+#include "mfu_errors.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -24,6 +25,11 @@
 #include <lustre/lustreapi.h>
 #endif
 
+#ifdef DAOS_SUPPORT
+#include <gurt/common.h>
+#include <gurt/hash.h>
+#endif
+
 int mfu_initialized = 0;
 
 /* set globals */
@@ -36,6 +42,193 @@ mfu_loglevel mfu_debug_level = MFU_LOG_ERR;
 /* default progress message timeout in seconds */
 int mfu_progress_timeout = 10;
 
+/***** DAOS utility functions ******/
+#ifdef DAOS_SUPPORT
+bool daos_uuid_valid(const uuid_t uuid)
+{
+    return uuid && !uuid_is_null(uuid);
+}
+
+/* Distribute process 0's pool or container handle to others. */
+void daos_bcast_handle(
+  int rank,              /* root rank for broadcast */
+  daos_handle_t* handle, /* handle value to be broadcasted */
+  daos_handle_t* poh,    /* daos pool for global2local conversion of container handle */
+  enum handleType type)  /* handle type: POOL_HANDLE or CONT_HANDLE */
+{
+    int rc;
+
+    d_iov_t global;
+    global.iov_buf     = NULL;
+    global.iov_buf_len = 0;
+    global.iov_len     = 0;
+
+    /* Get the global handle size. */
+    if (rank == 0) {
+        if (type == POOL_HANDLE) {
+            rc = daos_pool_local2global(*handle, &global);
+        } else {
+            rc = daos_cont_local2global(*handle, &global);
+        }
+        if (rc != 0) {
+            MFU_ABORT(-1, "Failed to get global handle size");
+        }
+    }
+
+    /* broadcast size of global handle */
+    MPI_Bcast(&global.iov_buf_len, 1, MPI_UINT64_T, 0, MPI_COMM_WORLD);
+
+    /* allocate memory to hold global handle value */
+    global.iov_len = global.iov_buf_len;
+    global.iov_buf = MFU_MALLOC(global.iov_buf_len);
+
+    /* convert from local handle to global handle */
+    if (rank == 0) {
+       if (type == POOL_HANDLE) {
+           rc = daos_pool_local2global(*handle, &global);
+       } else {
+           rc = daos_cont_local2global(*handle, &global);
+       }
+       if (rc != 0) {
+           MFU_ABORT(-1, "Failed to create global handle");
+       }
+    }
+
+    /* broadcast global handle value */
+    MPI_Bcast(global.iov_buf, global.iov_buf_len, MPI_BYTE, 0, MPI_COMM_WORLD);
+
+    /* convert global handle to local value */
+    if (rank != 0) {
+        if (type == POOL_HANDLE) {
+            rc = daos_pool_global2local(global, handle);
+        } else {
+            rc = daos_cont_global2local(*poh, global, handle);
+        }
+        if (rc != 0) {
+            MFU_ABORT(-1, "Failed to get local handle");
+        }
+    }
+
+    /* free temporary buffer used to hold global handle value */
+    mfu_free(&global.iov_buf);
+}
+
+int daos_connect(
+  int rank,
+  uuid_t pool_uuid,
+  uuid_t cont_uuid,
+  daos_handle_t* poh,
+  daos_handle_t* coh,
+  bool connect_pool,
+  bool create_cont)
+{
+    /* assume failure until otherwise */
+    int valid = 0;
+    int rc;
+
+    /* have rank 0 connect to the pool and container,
+     * we'll then broadcast the handle ids from rank 0 to everyone else */
+    if (rank == 0) {
+        /* Connect to DAOS pool */
+        if (connect_pool) {
+            daos_pool_info_t pool_info = {0};
+#if DAOS_API_VERSION_MAJOR < 1
+            rc = daos_pool_connect(pool_uuid, NULL, NULL, DAOS_PC_RW,
+                    poh, &pool_info, NULL);
+#else
+            rc = daos_pool_connect(pool_uuid, NULL, DAOS_PC_RW,
+                    poh, &pool_info, NULL);
+#endif
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to connect to pool");
+                goto bcast;
+            }
+        }
+
+        /* Try to open the container 
+         * If NOEXIST we create it */
+        daos_cont_info_t co_info = {0};
+        rc = daos_cont_open(*poh, cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+        if (rc != 0) {
+            if (!create_cont) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
+                goto bcast;
+            }
+            
+            rc = dfs_cont_create(*poh, cont_uuid, NULL, NULL, NULL);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to create DFS container");
+                goto bcast;
+            }
+
+            /* try to open it again */
+            rc = daos_cont_open(*poh, cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
+                goto bcast;
+            }
+        }
+
+        /* everything looks good so far */
+        valid = 1;
+    }
+
+bcast:
+    /* broadcast valid from rank 0 */
+    MPI_Bcast(&valid, 1, MPI_INT, 0, MPI_COMM_WORLD);
+
+    /* return if invalid */
+    if (valid == 0) {
+        return -1;
+    }
+
+    /* broadcast pool handle from rank 0 
+     * If connect_pool is false, then the handle was unchanged */
+    if (connect_pool) {
+        daos_bcast_handle(rank, poh, poh, POOL_HANDLE);
+    }
+
+    /* broadcast container handle from rank 0 */
+    daos_bcast_handle(rank, coh, poh, CONT_HANDLE);
+
+    return 0;
+}
+
+int daos_mount(
+  mfu_file_t* mfu_file,
+  daos_handle_t* poh,
+  daos_handle_t* coh)
+{
+    /* Mount dfs */
+    int rc = dfs_mount(*poh, *coh, O_RDWR, &mfu_file->dfs);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+        rc = -1;
+    }
+
+    return rc;
+}
+
+int daos_umount(
+  mfu_file_t* mfu_file)
+{
+    /* Unmount dfs */
+    int rc = dfs_umount(mfu_file->dfs);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to unmount DFS namespace");
+        rc = -1;
+    }
+
+    /* Clean up the hash */
+    if (mfu_file->dfs_hash != NULL) {
+        d_hash_table_destroy(mfu_file->dfs_hash, true);
+    }
+
+    return rc;
+}
+#endif
+
 /* initialize mfu library,
  * reference counting allows for multiple init/finalize pairs */
 int mfu_init()
@@ -44,10 +237,10 @@ int mfu_init()
         /* set globals */
         MPI_Comm_rank(MPI_COMM_WORLD, &mfu_rank);
         mfu_debug_stream = stdout;
-
         DTCMP_Init();
         mfu_initialized++;
     }
+
     return MFU_SUCCESS;
 }
 
@@ -682,33 +875,57 @@ int mfu_compare_contents(
     const char* dst_name,          /* IN  - path name to destination file */
     off_t offset,                  /* IN  - offset with file to start comparison */
     off_t length,                  /* IN  - number of bytes to be compared */
-    size_t bufsize,                /* IN  - size of I/O buffer to be used during compare */
+    off_t file_size,               /* IN  - size of file */
     int overwrite,                 /* IN  - whether to replace dest with source contents (1) or not (0) */
+    mfu_copy_opts_t* copy_opts,    /* IN - options for data compare/copy step */
     uint64_t* count_bytes_read,    /* OUT - number of bytes read (src + dest) */
     uint64_t* count_bytes_written, /* OUT - number of bytes written to dest */
     mfu_progress* prg)             /* IN  - progress message structure */
 {
+    /* extract values from copy options */
+    int direct = copy_opts->direct;
+    size_t buf_size = copy_opts->block_size;
+
+    /* for O_DIRECT, check that length is a multiple of buf_size */
+    if (direct &&                      /* using O_DIRECT */
+        offset + length < file_size && /* not at end of file */
+        length % buf_size != 0)        /* length not an integer multiple of block size */
+    {
+        MFU_ABORT(-1, "O_DIRECT requires chunk size to be integer multiple of block size %llu",
+            buf_size);
+    }
+
+    /* open source as read only, with optional O_DIRECT */
+    int src_flags = O_RDONLY;
+    if (direct) {
+        src_flags |= O_DIRECT;
+    }
+
     /* open source file */
-    int src_fd = mfu_open(src_name, O_RDONLY);
+    int src_fd = mfu_open(src_name, src_flags);
     if (src_fd < 0) {
         /* log error if there is an open failure on the src side */
         MFU_LOG(MFU_LOG_ERR, "Failed to open `%s' (errno=%d %s)",
-          src_name, errno, strerror(errno));
+            src_name, errno, strerror(errno));
        return -1;
     }
 
-    /* avoid opening file in write mode if we're only reading */
+    /* avoid opening file in write mode if we're only reading,
+     * optionally enable O_DIRECT */
     int dst_flags = O_RDONLY;
     if (overwrite) {
         dst_flags = O_RDWR;
     }
+    if (direct) {
+        dst_flags |= O_DIRECT;
+    }
 
     /* open destination file */
     int dst_fd = mfu_open(dst_name, dst_flags);
     if (dst_fd < 0) {
         /* log error if there is an open failure on the dst side */
         MFU_LOG(MFU_LOG_ERR, "Failed to open `%s' (errno=%d %s)",
-          dst_name, errno, strerror(errno));
+            dst_name, errno, strerror(errno));
         mfu_close(src_name, src_fd);
         return -1;
     }
@@ -720,53 +937,62 @@ int mfu_compare_contents(
     /* assume we'll find that file contents are the same */
     int rc = 0;
 
-    /* seek to offset in source file */
-    if (mfu_lseek(src_name, src_fd, offset, SEEK_SET) == (off_t)-1) {
-        /* log error if there is an lseek failure on the src side */
-        MFU_LOG(MFU_LOG_ERR, "Failed to lseek `%s', offset: %lx (errno=%d %s)",
-          src_name, (unsigned long)offset, errno, strerror(errno));
-        mfu_close(dst_name, dst_fd);
-        mfu_close(src_name, src_fd);
-        return -1;
-    }
+    /* TODO: replace this with mfu_copy_opts->buf */
+    /* allocate buffer to write files, aligned on 1MB boundaraies */
+    size_t alignment = 1024*1024;
+    void* src_buf = (char*) MFU_MEMALIGN(buf_size, alignment);
+    void* dst_buf = (char*) MFU_MEMALIGN(buf_size, alignment);
 
-    /* seek to offset in destination file */
-    if (mfu_lseek(dst_name, dst_fd, offset, SEEK_SET) == (off_t)-1) {
-        /* log error if there is an lseek failure on the dst side */
-        MFU_LOG(MFU_LOG_ERR, "Failed to lseek `%s', offset: %lx (errno=%d %s)",
-          dst_name, (unsigned long)offset, errno, strerror(errno));
-        mfu_close(dst_name, dst_fd);
-        mfu_close(src_name, src_fd);
-        return -1;
-    }
+    /* initialize our starting offset within the file */
+    off_t off = offset;
 
-    /* allocate buffers to read file data */
-    void* src_buf  = MFU_MALLOC(bufsize);
-    void* dest_buf = MFU_MALLOC(bufsize);
+    /* if we write with O_DIRECT, we may need to truncate file */
+    int need_truncate = 0;
 
     /* read and compare data from files */
     off_t total_bytes = 0;
-    while (length == 0 || total_bytes < length) {
-        /* track current position in file for error reporting and seeking */
-        off_t pos = offset + total_bytes;
-
+    while (total_bytes < length) {
         /* whether we should copy the source bytes to the destination */
         int need_copy = 0;
 
         /* determine number of bytes to read in this iteration */
-        size_t left_to_read = bufsize;
-        if (length > 0) {
-            if (length - total_bytes < (off_t)bufsize) {
-                left_to_read = (size_t)(length - total_bytes);
+        size_t left_to_read = buf_size;
+        if (! direct) {
+            off_t remainder = length - total_bytes;
+            if (remainder < (off_t)buf_size) {
+                left_to_read = (size_t) remainder;
             }
         }
 
         /* read data from source file */
-        ssize_t src_read = mfu_read(src_name, src_fd, (ssize_t*)src_buf, left_to_read);
+        ssize_t src_read = mfu_pread(src_name, src_fd, (ssize_t*)src_buf, left_to_read, off);
+
+        /* If we're using O_DIRECT, deal with short reads.
+         * Retry with same buffer and offset since those must
+         * be aligned at block boundaries. */
+        while (direct &&                     /* using O_DIRECT */
+               src_read > 0 &&               /* read was not an error or eof */
+               src_read < left_to_read &&    /* shorter than requested */
+               (off + src_read) < file_size) /* not at end of file */
+        {
+            /* TODO: probably should retry a limited number of times then abort */
+            src_read = mfu_pread(src_name, src_fd, src_buf, left_to_read, off);
+        }
+
+        /* check for read error */
         if (src_read < 0) {
             /* hit a read error */
             MFU_LOG(MFU_LOG_ERR, "Failed to read `%s' at offset %llx (errno=%d %s)",
-              src_name, (unsigned long long)pos, errno, strerror(errno));
+                src_name, (unsigned long long)off, errno, strerror(errno));
+            rc = -1;
+            break;
+        }
+
+        /* check for early EOF */
+        if (src_read == 0) {
+            /* if the source is shorter than expected, consider this to be an error */
+            MFU_LOG(MFU_LOG_ERR, "Source `%s' is shorter %llx than expected (errno=%d %s)",
+                src_name, (unsigned long long)off, errno, strerror(errno));
             rc = -1;
             break;
         }
@@ -775,11 +1001,34 @@ int mfu_compare_contents(
         *count_bytes_read += (uint64_t) src_read;
 
         /* read data from destination file */
-        ssize_t dst_read = mfu_read(dst_name, dst_fd, (ssize_t*)dest_buf, left_to_read);
+        ssize_t dst_read = mfu_pread(dst_name, dst_fd, (ssize_t*)dst_buf, left_to_read, off);
+
+        /* If we're using O_DIRECT, deal with short reads.
+         * Retry with same buffer and offset since those must
+         * be aligned at block boundaries. */
+        while (direct &&                     /* using O_DIRECT */
+               dst_read > 0 &&               /* read was not an error or eof */
+               dst_read < left_to_read &&    /* shorter than requested */
+               (off + dst_read) < file_size) /* not at end of file */
+        {
+            /* TODO: probably should retry a limited number of times then abort */
+            dst_read = mfu_pread(dst_name, dst_fd, dst_buf, left_to_read, off);
+        }
+
+        /* check for read error */
         if (dst_read < 0) {
             /* hit a read error */
             MFU_LOG(MFU_LOG_ERR, "Failed to read `%s' at offset %llx (errno=%d %s)",
-              dst_name, (unsigned long long)pos, errno, strerror(errno));
+                dst_name, (unsigned long long)off, errno, strerror(errno));
+            rc = -1;
+            break;
+        }
+
+        /* check for early EOF */
+        if (dst_read == 0) {
+            /* destination is shorter than expected, consider this to be an error */
+            MFU_LOG(MFU_LOG_ERR, "Destination `%s' is shorter than expected %llx (errno=%d %s)",
+                dst_name, (unsigned long long)off, errno, strerror(errno));
             rc = -1;
             break;
         }
@@ -787,13 +1036,17 @@ int mfu_compare_contents(
         /* tally up number of bytes read */
         *count_bytes_read += (uint64_t) dst_read;
 
-        /* TODO: could be a non-error short read, we could just adjust number
+        /* we could have a non-error short read, so adjust number
          * of bytes we compare and update offset to shorter of the two values
          * numread = min(src_read, dst_read) */
+        ssize_t min_read = src_read;
+        if (dst_read < min_read) {
+            min_read = dst_read;
+        }
 
-        /* check that we got the same number of bytes from each */
-        if (src_read != dst_read) {
-            /* one read came up shorter than the other */
+        /* if have same size buffers, and read some data, let's check the contents */
+        if (memcmp((ssize_t*)src_buf, (ssize_t*)dst_buf, (size_t)min_read) != 0) {
+            /* memory contents are different */
             rc = 1;
             if (! overwrite) {
                 break;
@@ -801,53 +1054,63 @@ int mfu_compare_contents(
             need_copy = 1;
         }
 
-        /* check for EOF */
-        if (src_read == 0) {
-            /* hit end of source file */
-            break;
-        }
+        /* if the bytes are different,
+         * then copy the bytes from the source into the destination */
+        if (overwrite && need_copy) {
+            /* compute number of bytes to write */
+            size_t bytes_to_write = (size_t) min_read;
+            if (direct) {
+                /* O_DIRECT requires particular write sizes,
+                 * ok to write beyond end of file so long as
+                 * we truncate in cleanup step */
+                size_t remainder = buf_size - (size_t) min_read;
+                if (remainder > 0) {
+                    /* zero out the end of the buffer for security,
+                     * don't want to leave data from another file at end of
+                     * current file if we fail before truncating */
+                    char* bufzero = ((char*)src_buf + min_read);
+                    memset(bufzero, 0, remainder);
+
+                    /* remember that we might need to truncate,
+                     * because we may write past the end of the file */
+                    need_truncate = 1;
+                }
 
-        /* if have same size buffers, and read some data, let's check the contents */
-        if (src_read == dst_read) {
-            if (memcmp((ssize_t*)src_buf, (ssize_t*)dest_buf, (size_t)src_read) != 0) {
-                /* memory contents are different */
-                rc = 1;
-                if (! overwrite) {
+                /* assumes buf_size is magic size for O_DIRECT */
+                bytes_to_write = buf_size;
+            }
+
+            /* we loop to account for short writes */
+            ssize_t n = 0;
+            while (n < bytes_to_write) {
+                /* write data to destination file */
+                ssize_t bytes_written = mfu_pwrite(dst_name, dst_fd, ((char*)src_buf) + n, bytes_to_write - n, off + n);
+
+                /* check for write error */
+                if (bytes_written < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Failed to write `%s' at offset %llx (errno=%d %s)", 
+                        dst_name, (unsigned long long)off + n, strerror(errno));
+                    rc = -1;
                     break;
                 }
-                need_copy = 1;
-            }
-        }
 
-        /* if the bytes are different,
-         * then copy the bytes from the source into the destination */
-        if (overwrite && need_copy == 1) {
-            /* seek back to position to write to in destination file */
-            if (mfu_lseek(dst_name, dst_fd, pos, SEEK_SET) == (off_t)-1) {
-                /* log error if there is an lseek failure on the dst side */
-                MFU_LOG(MFU_LOG_ERR, "Failed to lseek `%s', offset: %llx (errno=%d %s)",
-                  dst_name, (unsigned long long)pos, strerror(errno));
-                rc = -1;
-                break;
-            }
+                /* So long as we're not using O_DIRECT, we can handle short writes
+                 * by advancing by the number of bytes written.  For O_DIRECT, we
+                 * need to keep buffer, file offset, and amount to write aligned
+                 * on block boundaries, so just retry the entire operation. */
+                if (!direct || bytes_written == bytes_to_write) {
+                    /* advance index by number of bytes written */
+                    n += bytes_written;
 
-            /* write data to destination file */
-            size_t bytes_to_write = (size_t) src_read;
-            ssize_t bytes_written = mfu_write(dst_name, dst_fd, src_buf, bytes_to_write);
-            if (bytes_written < 0) {
-                /* hit a write error */
-                MFU_LOG(MFU_LOG_ERR, "Failed to write `%s' at offset %llx (errno=%d %s)",
-                  dst_name, (unsigned long long)pos, strerror(errno));
-                rc = -1;
-                break;
+                    /* tally up number of bytes written */
+                    *count_bytes_written += (uint64_t) bytes_written;
+                }
             }
-
-            /* tally up number of bytes written */
-            *count_bytes_written += (uint64_t) bytes_written;
         }
 
         /* add bytes to our total */
-        total_bytes += (long unsigned int)src_read;
+        off += min_read;
+        total_bytes += (long unsigned int)min_read;
 
         /* update number of bytes read and written for progress messages */
         uint64_t count_bytes[2];
@@ -856,8 +1119,24 @@ int mfu_compare_contents(
         mfu_progress_update(count_bytes, prg);
     }
 
+    /* truncate destination file if we might have written past the end */
+    if (need_truncate) {
+        off_t last_written = offset + length;
+        off_t file_size_offt = (off_t) file_size;
+        if (last_written >= file_size_offt) {
+            /* Use ftruncate() here rather than truncate(), because grouplock
+             * of Lustre would cause block to truncate() since the fd is different
+             * from the out_fd. */
+            if (mfu_ftruncate(dst_fd, file_size_offt) < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to truncate destination file: %s (errno=%d %s)",
+                    dst_name, errno, strerror(errno));
+                rc = -1;
+            }
+        }
+    }
+
     /* free buffers */
-    mfu_free(&dest_buf);
+    mfu_free(&dst_buf);
     mfu_free(&src_buf);
 
     /* close files */
@@ -966,11 +1245,11 @@ void mfu_stripe_set(const char *path, uint64_t stripe_size, int stripe_count)
 }
 
 /* executes a logical AND operation on flag on all procs on comm,
- * returns 1 if all true and 0 otherwise */
-int mfu_alltrue(int flag, MPI_Comm comm)
+ * returns true if all true and false otherwise */
+bool mfu_alltrue(bool flag, MPI_Comm comm)
 {
     /* check that all processes wrote successfully */
-    int alltrue;
-    MPI_Allreduce(&flag, &alltrue, 1, MPI_INT, MPI_LAND, comm);
+    bool alltrue;
+    MPI_Allreduce(&flag, &alltrue, 1, MPI_C_BOOL, MPI_LAND, comm);
     return alltrue;
 }
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index f18d09e..44d89a4 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -33,6 +33,8 @@ extern "C" {
 
 #include "mfu_progress.h"
 
+#include "mfu_io.h"
+
 #if __BYTE_ORDER == __LITTLE_ENDIAN
 #ifdef HAVE_BYTESWAP_H
 # define mfu_ntoh16(x) bswap_16(x)
@@ -68,6 +70,14 @@ typedef enum {
     MFU_LOG_DBG     = 6
 } mfu_loglevel;
 
+#ifdef DAOS_SUPPORT
+enum handleType {
+        POOL_HANDLE,
+        CONT_HANDLE,
+        ARRAY_HANDLE
+};
+#endif
+
 extern int mfu_initialized;
 
 /* set during mfu_init, used in MFU_LOG */
@@ -103,6 +113,43 @@ extern int mfu_progress_timeout;
         } \
     } while (0)
 
+/******** DAOS utility functions ********/
+#ifdef DAOS_SUPPORT
+bool daos_uuid_valid(const uuid_t uuid);
+
+/* Distribute process 0's pool or container handle to others. */
+void daos_bcast_handle(
+  int rank,              /* root rank for broadcast */
+  daos_handle_t* handle, /* handle value to be broadcasted */
+  daos_handle_t* poh,    /* daos pool for global2local conversion of container handle */
+  enum handleType type   /* handle type: POOL_HANDLE or CONT_HANDLE */
+);
+
+/* connect to DAOS pool, and then open container */
+int daos_connect(
+  int rank,
+  uuid_t pool_uuid,
+  uuid_t cont_uuid,
+  daos_handle_t* poh,
+  daos_handle_t* coh,
+  bool connect_pool,
+  bool create_cont
+);
+
+/* Mount DAOS dfs */
+int daos_mount(
+  mfu_file_t* mfu_file,
+  daos_handle_t* poh,
+  daos_handle_t* coh
+);
+
+/* Unmount DAOS dfs.
+ * Cleanup up hash */
+int daos_umount(
+  mfu_file_t* mfu_file
+);
+#endif
+
 /* initialize mfu library,
  * reference counting allows for multiple init/finalize pairs */
 int mfu_init(void);
@@ -234,15 +281,16 @@ void mfu_stat_set_ctimes(struct stat* sb, uint64_t secs, uint64_t nsecs);
 /* compares contents of two files and optionally overwrite dest with source,
  * returns -1 on error, 0 if equal, 1 if different */
 int mfu_compare_contents(
-    const char* src,         /* IN  - path name to souce file */
-    const char* dst,         /* IN  - path name to destination file */
-    off_t offset,            /* IN  - offset with file to start comparison */
-    off_t length,            /* IN  - number of bytes to be compared */
-    size_t bufsize,          /* IN  - size of I/O buffer to be used during compare */
-    int overwrite,           /* IN  - whether to replace dest with source contents (1) or not (0) */
-    uint64_t* bytes_read,    /* OUT - number of bytes read (src + dest) */
-    uint64_t* bytes_written, /* OUT - number of bytes written to dest */
-    mfu_progress* prg        /* IN  - progress message structure */
+    const char* src,          /* IN  - path name to souce file */
+    const char* dst,          /* IN  - path name to destination file */
+    off_t offset,             /* IN  - offset with file to start comparison */
+    off_t length,             /* IN  - number of bytes to be compared */
+    off_t file_size,          /* IN  - size of file to be compared */
+    int overwrite,            /* IN  - whether to replace dest with source contents (1) or not (0) */
+    mfu_copy_opts_t* opts,    /* IN  - options to use in compare/copy */
+    uint64_t* bytes_read,     /* OUT - number of bytes read (src + dest) */
+    uint64_t* bytes_written,  /* OUT - number of bytes written to dest */
+    mfu_progress* prg         /* IN  - progress message structure */
 );
 
 /* uses the lustre api to obtain stripe count and stripe size of a file */
@@ -253,7 +301,7 @@ void mfu_stripe_set(const char *path, uint64_t stripe_size, int stripe_count);
 
 /* executes a logical AND operation on flag on all procs on comm,
  * returns 1 if all true and 0 otherwise */
-int mfu_alltrue(int flag, MPI_Comm comm);
+bool mfu_alltrue(bool flag, MPI_Comm comm);
 
 #endif /* MFU_UTIL_H */
 
diff --git a/src/dchmod/dchmod.c b/src/dchmod/dchmod.c
index 7f81bee..539d870 100644
--- a/src/dchmod/dchmod.c
+++ b/src/dchmod/dchmod.c
@@ -87,7 +87,7 @@ int main(int argc, char** argv)
         {"exclude",  1, 0, 'e'},
         {"match",    1, 0, 'a'},
         {"name",     0, 0, 'n'},
-        {"progress", 1, 0, 'P'},
+        {"progress", 1, 0, 'R'},
         {"verbose",  0, 0, 'v'},
         {"quiet",    0, 0, 'q'},
         {"help",     0, 0, 'h'},
@@ -135,7 +135,7 @@ int main(int argc, char** argv)
             case 'n':
                 name = 1;
                 break;
-            case 'P':
+            case 'R':
                 mfu_progress_timeout = atoi(optarg);
                 break;
             case 'v':
@@ -229,6 +229,9 @@ int main(int argc, char** argv)
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file object */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* flag used to check if permissions need to be
      * set on the walk */
     if (head != NULL) {
@@ -245,7 +248,7 @@ int main(int argc, char** argv)
         }
 
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read list from file */
@@ -306,6 +309,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dcmp/dcmp.c b/src/dcmp/dcmp.c
index fda14f3..7214422 100644
--- a/src/dcmp/dcmp.c
+++ b/src/dcmp/dcmp.c
@@ -30,6 +30,9 @@ static void print_usage(void)
     printf("  -o, --output <EXPR:FILE>  - write list of entries matching EXPR to FILE\n");
     printf("  -t, --text                - change output option to write in text format\n");
     printf("  -b, --base                - enable base checks and normal output with --output\n");
+    printf("      --blocksize <SIZE>    - IO buffer size in bytes (default " MFU_BLOCK_SIZE_STR ")\n");
+    printf("      --chunksize <SIZE>    - minimum work size per task in bytes (default " MFU_CHUNK_SIZE_STR ")\n");
+    printf("  -s, --direct              - open files with O_DIRECT\n");
     printf("      --progress <N>        - print progress every N seconds\n");
     printf("  -v, --verbose             - verbose output\n");
     printf("  -q, --quiet               - quiet output\n");
@@ -754,7 +757,8 @@ static int dcmp_strmap_compare_data(
     strmap* src_map,
     mfu_flist dst_compare_list,
     strmap* dst_map,
-    size_t strlen_prefix)
+    size_t strlen_prefix,
+    mfu_copy_opts_t* copy_opts)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -795,10 +799,13 @@ static int dcmp_strmap_compare_data(
         /* get length of section that we should compare (bytes) */
         off_t length = (off_t)src_p->length;
 
+        /* get size of file that we should compare (bytes) */
+        off_t filesize = (off_t)src_p->file_size;
+
         /* compare the contents of the files */
         int overwrite = 0;
-        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length,
-                1048576, overwrite, &bytes_read, &bytes_written, prg);
+        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length, filesize,
+                overwrite, copy_opts, &bytes_read, &bytes_written, prg);
         if (compare_rc == -1) {
             /* we hit an error while reading */
             rc = -1;
@@ -928,13 +935,15 @@ static void time_strmap_compare(mfu_flist src_list, double start_compare,
 }
 
 /* compare entries from src into dst */
-static int dcmp_strmap_compare(mfu_flist src_list,
-                                strmap* src_map,
-                                mfu_flist dst_list,
-                                strmap* dst_map,
-                                size_t strlen_prefix,
-                                const mfu_param_path* src_path,
-                                const mfu_param_path* dest_path)
+static int dcmp_strmap_compare(
+    mfu_flist src_list,
+    strmap* src_map,
+    mfu_flist dst_list,
+    strmap* dst_map,
+    size_t strlen_prefix,
+    mfu_copy_opts_t* copy_opts,
+    const mfu_param_path* src_path,
+    const mfu_param_path* dest_path)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1092,7 +1101,7 @@ static int dcmp_strmap_compare(mfu_flist src_list,
         cmp_global_size = mfu_flist_global_size(src_compare_list);
         if (cmp_global_size > 0) {
             tmp_rc = dcmp_strmap_compare_data(src_compare_list, src_map, dst_compare_list,
-                    dst_map, strlen_prefix);
+                    dst_map, strlen_prefix, copy_opts);
             if (tmp_rc < 0) {
                 /* got a read error, signal that back to caller */
                 rc = -1;
@@ -2037,9 +2046,12 @@ int main(int argc, char **argv)
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
     MPI_Comm_size(MPI_COMM_WORLD, &ranks);
 
-    /* pointer to mfu_walk_opts */
+    /* allocate structure to define walk options */
     mfu_walk_opts_t* walk_opts = mfu_walk_opts_new();
 
+    /* allocate structure to define copy (comparision) options */
+    mfu_copy_opts_t* copy_opts = mfu_copy_opts_new();
+
     /* TODO: allow user to specify file lists as input files */
 
     /* TODO: three levels of comparison:
@@ -2057,15 +2069,18 @@ int main(int argc, char **argv)
 
     int option_index = 0;
     static struct option long_options[] = {
-        {"output",   1, 0, 'o'},
-        {"text",     0, 0, 't'},
-        {"base",     0, 0, 'b'},
-        {"progress", 1, 0, 'P'},
-        {"verbose",  0, 0, 'v'},
-        {"quiet",    0, 0, 'q'},
-        {"lite",     0, 0, 'l'},
-        {"debug",    0, 0, 'd'},
-        {"help",     0, 0, 'h'},
+        {"output",    1, 0, 'o'},
+        {"text",      0, 0, 't'},
+        {"base",      0, 0, 'b'},
+        {"blocksize", 1, 0, 'B'},
+        {"chunksize", 1, 0, 'k'},
+        {"direct",    0, 0, 's'},
+        {"progress",  1, 0, 'R'},
+        {"verbose",   0, 0, 'v'},
+        {"quiet",     0, 0, 'q'},
+        {"lite",      0, 0, 'l'},
+        {"debug",     0, 0, 'd'},
+        {"help",      0, 0, 'h'},
         {0, 0, 0, 0}
     };
     int ret = 0;
@@ -2074,9 +2089,10 @@ int main(int argc, char **argv)
     /* read in command line options */
     int usage = 0;
     int help  = 0;
+    unsigned long long bytes = 0;
     while (1) {
         int c = getopt_long(
-            argc, argv, "o:tbvqldh",
+            argc, argv, "o:tbsvqldh",
             long_options, &option_index
         );
 
@@ -2097,7 +2113,35 @@ int main(int argc, char **argv)
         case 'b':
             options.base++;
             break;
-        case 'P':
+        case 'B':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse block size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->block_size = (size_t)bytes;
+            }
+            break;
+        case 'k':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse chunk size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->chunk_size = bytes;
+            }
+            break;
+        case 's':
+            copy_opts->direct = true;
+            if(rank == 0) {
+                MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
+            }
+            break;
+        case 'R':
             mfu_progress_timeout = atoi(optarg);
             break;
         case 'v':
@@ -2191,16 +2235,19 @@ int main(int argc, char **argv)
     mfu_flist flist1 = mfu_flist_new();
     mfu_flist flist2 = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_src_file = mfu_file_new();
+    mfu_file_t* mfu_dst_file = mfu_file_new();
 
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking source path");
     }
-    mfu_flist_walk_param_paths(1,  srcpath, walk_opts, flist1);
+    mfu_flist_walk_param_paths(1,  srcpath, walk_opts, flist1, mfu_src_file);
 
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking destination path");
     }
-    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist2);
+    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist2, mfu_dst_file);
 
     /* store src and dest path strings */
     const char* path1 = srcpath->path;
@@ -2215,7 +2262,7 @@ int main(int argc, char **argv)
     strmap* map2 = dcmp_strmap_creat(flist4, path2);
 
     /* compare files in map1 with those in map2 */
-    int tmp_rc = dcmp_strmap_compare(flist3, map1, flist4, map2, strlen(path1), srcpath, destpath);
+    int tmp_rc = dcmp_strmap_compare(flist3, map1, flist4, map2, strlen(path1), copy_opts, srcpath, destpath);
     if (tmp_rc < 0) {
         /* hit a read error on at least one file */
         rc = 1;
@@ -2239,6 +2286,10 @@ int main(int argc, char **argv)
     mfu_flist_free(&flist3);
     mfu_flist_free(&flist4);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_src_file);
+    mfu_file_delete(&mfu_dst_file);
+
     /* free all param paths */
     mfu_param_path_free_all(numargs, paths);
 
@@ -2247,6 +2298,9 @@ int main(int argc, char **argv)
 
     dcmp_option_fini();
 
+    /* free the copy options structure */
+    mfu_copy_opts_delete(&copy_opts);
+
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 823845a..d76dc5b 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -8,10 +8,518 @@
 #include <errno.h>
 #include <stdbool.h>
 
+/* for daos */
+#ifdef DAOS_SUPPORT
+#include <uuid/uuid.h>
+#include <gurt/common.h>
+#include <gurt/hash.h>
+#include <daos.h>
+#include <sys/stat.h>
+#include <daos_fs.h>
+#include <daos_uns.h>
+#endif
+
 #include "mpi.h"
 #include "libcircle.h"
 #include "mfu.h"
 
+#include "mfu_errors.h"
+
+#ifdef DAOS_SUPPORT
+/* struct for holding DAOS arguments */
+typedef struct {
+    daos_handle_t src_poh; /* source pool handle */
+    daos_handle_t dst_poh; /* destination pool handle */
+    daos_handle_t src_coh; /* source container handle */
+    daos_handle_t dst_coh; /* destination container handle */
+    uuid_t src_pool_uuid;  /* source pool UUID */
+    uuid_t dst_pool_uuid;  /* destination pool UUID */
+    uuid_t src_cont_uuid;  /* source container UUID */
+    uuid_t dst_cont_uuid;  /* destination container UUID */
+    char* dfs_prefix;      /* prefix for UNS */
+} daos_args_t;
+
+/* Return a newly allocated daos_args_t structure.
+ * Set default values on its fields. */
+static daos_args_t* daos_args_new(void)
+{
+    daos_args_t* da = (daos_args_t*) MFU_MALLOC(sizeof(daos_args_t));
+    
+    da->src_poh    = DAOS_HDL_INVAL;
+    da->dst_poh    = DAOS_HDL_INVAL;
+    da->src_coh    = DAOS_HDL_INVAL;
+    da->dst_coh    = DAOS_HDL_INVAL;
+    da->dfs_prefix = NULL;
+
+    /* initalize value of DAOS UUID's to NULL with uuid_clear */
+    uuid_clear(da->src_pool_uuid);
+    uuid_clear(da->dst_pool_uuid);
+    uuid_clear(da->src_cont_uuid);
+    uuid_clear(da->dst_cont_uuid);
+    
+    return da;
+}
+
+/* free a daos_args_t structure */
+static void daos_args_delete(daos_args_t** pda)
+{
+    if (pda != NULL) {
+        daos_args_t* da = *pda;
+        mfu_free(&da->dfs_prefix);
+        mfu_free(pda);
+    }
+}
+
+/* Verify DAOS arguments are valid */
+static int daos_check_args(
+    int rank,
+    char** argpaths,
+    daos_args_t* da,
+    int* flag_daos_args)
+{
+    char* src_path = argpaths[0];
+    char* dst_path = argpaths[1];
+
+    bool have_src_path  = src_path != NULL;
+    bool have_dst_path  = dst_path != NULL;
+    bool have_src_pool  = daos_uuid_valid(da->src_pool_uuid);
+    bool have_src_cont  = daos_uuid_valid(da->src_cont_uuid);
+    bool have_dst_pool  = daos_uuid_valid(da->dst_pool_uuid);
+    bool have_dst_cont  = daos_uuid_valid(da->dst_cont_uuid);
+    bool have_prefix    = da->dfs_prefix != NULL;
+
+    /* Determine whether any DAOS arguments are supplied. 
+     * If not, then there is nothing to check. */
+    *flag_daos_args = 0;
+    if (have_src_pool || have_src_cont || have_dst_pool || have_dst_cont
+            || have_prefix) {
+        *flag_daos_args = 1;
+    }
+    else {
+        return 0;
+    } 
+    
+    bool same_pool = false;
+    bool same_cont = false;
+    if (have_src_pool && have_dst_pool 
+            && uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
+        same_pool = true;
+        if (have_src_cont && have_dst_cont
+                && uuid_compare(da->src_cont_uuid, da->dst_cont_uuid) == 0) {
+            same_cont = true;
+        }
+    }
+
+    int rc = 0;
+
+    if (have_src_cont && !have_src_pool) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source container requires source pool");
+        }
+        rc = 1;
+    }
+    if (have_src_pool && !have_src_cont) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source pool requires source container");
+        }
+        rc = 1;
+    }
+    if (have_dst_cont && !have_dst_pool) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Destination container requires destination pool");
+        }
+        rc = 1;
+    }
+
+    /* Make sure the source and destination are different */
+    if (same_cont && have_src_path && have_dst_path) {
+        if (strcmp(src_path, dst_path) == 0) {
+            if (rank == 0) {
+                 MFU_LOG(MFU_LOG_ERR, "DAOS source is DAOS destination");
+            }
+            rc = 1;
+        }
+    }
+
+    return rc;
+}
+
+/* Checks if the prefix is valid.
+ * If valid, returns matching string into suffix */
+static bool daos_check_prefix(char* path, const char* dfs_prefix, char** suffix)
+{
+    bool is_prefix = false;
+    int prefix_len = strlen(dfs_prefix);
+    int path_len = strlen(path);
+
+    /* ignore trailing '/' on the prefix */
+    if (dfs_prefix[prefix_len-1] == '/') {
+        prefix_len--;
+    }
+
+    /* figure out if dfs_prefix is a prefix of the file path */
+    if (strncmp(path, dfs_prefix, prefix_len) == 0) {
+        /* if equal, assume root */
+        if (path_len == prefix_len) {
+            *suffix = "/";
+            is_prefix = true;
+        }
+        /* if path is longer, it must start with '/' */
+        else if (path_len > prefix_len &&
+            path[prefix_len] == '/') {
+            *suffix = path + prefix_len;
+            is_prefix = true;
+        }
+    }
+    return is_prefix;
+}
+
+/* Checks for UNS paths and sets
+ * paths and DAOS args accordingly */
+static int daos_set_paths(
+    int rank,
+    char** argpaths,
+    daos_args_t* da,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
+{
+    int rc = 0;
+
+    bool have_src_pool  = daos_uuid_valid(da->src_pool_uuid);
+    bool have_dst_pool  = daos_uuid_valid(da->dst_pool_uuid);
+    
+    char* src_path = argpaths[0];
+    char* dst_path = argpaths[1];
+
+    bool prefix_on_src = false;
+    bool prefix_on_dst = false;
+
+    /* find out if a dfs_prefix is being used,
+     * if so, then that means that the container
+     * is not being copied from the root of the
+     * UNS path  */
+    if (da->dfs_prefix != NULL) {
+        struct duns_attr_t dattr = {0};
+        rc = duns_resolve_path(da->dfs_prefix, &dattr);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS Prefix UNS path");
+            return 1;
+        }
+
+        /* figure out if prefix is on dst or src for
+         * copying container subsets */
+        if (daos_check_prefix(src_path, da->dfs_prefix, &argpaths[0])) {
+            if (have_src_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS source pool should not be used with DAOS source prefix");
+                return 1;
+            }
+            mfu_src_file->type = DAOS;
+            uuid_copy(da->src_pool_uuid, dattr.da_puuid);
+            uuid_copy(da->src_cont_uuid, dattr.da_cuuid);
+            prefix_on_src = true;
+        } else if (daos_check_prefix(dst_path, da->dfs_prefix, &argpaths[1])) {
+            if (have_dst_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS destination pool should not be used with DAOS destination prefix");
+                return 1;
+            }
+            mfu_dst_file->type = DAOS;
+            uuid_copy(da->dst_pool_uuid, dattr.da_puuid);
+            uuid_copy(da->dst_cont_uuid, dattr.da_cuuid);
+            prefix_on_dst = true;
+        } else {
+            MFU_LOG(MFU_LOG_ERR, "DAOS prefix does not match source or destination");
+            return 1;
+        }
+    }
+
+    /* Forward slash is "root" of container to walk
+     * in daos. Cannot walk from Unified namespace
+     * path given /tmp/dsikich/dfs, it is only used
+     * to lookup pool/cont uuids, and tells you
+     * if that path is mapped to pool/cont uuid in
+     * DAOS 
+     *
+     * For each of the source and destination,
+     * if it is not using a prefix then assume
+     * it is a daos path for UNS. If resolve path
+     * doesn't succeed then it might be a POSIX path */
+    if (!prefix_on_src) {
+        struct duns_attr_t src_dattr = {0};
+        int src_rc = duns_resolve_path(src_path, &src_dattr);
+        
+        if (src_rc == 0) {
+            if (have_src_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS source pool should not be used with DAOS source UNS path");
+                return 1;
+            }
+            mfu_src_file->type = DAOS;
+            uuid_copy(da->src_pool_uuid, src_dattr.da_puuid);
+            uuid_copy(da->src_cont_uuid, src_dattr.da_cuuid);
+            argpaths[0] = "/";
+        }
+    }
+
+    if (!prefix_on_dst) {
+        struct duns_attr_t dst_dattr = {0};
+        int dst_rc = duns_resolve_path(dst_path, &dst_dattr);
+
+        if (dst_rc == 0) {
+            if (have_dst_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS destination pool should not be used with DAOS destination UNS path");
+                return 1;
+            }
+            mfu_dst_file->type = DAOS;
+            uuid_copy(da->dst_pool_uuid, dst_dattr.da_puuid);
+            uuid_copy(da->dst_cont_uuid, dst_dattr.da_cuuid);
+            argpaths[1] = "/";
+        }
+    }
+
+    return 0;
+}
+
+/* return 1 if any process has a local error
+ * return 0 otherwise
+ * ignore if no daos args supplied */
+static int daos_any_error(int rank, bool local_daos_error, int flag_daos_args)
+{
+    bool no_error = !local_daos_error;
+    if (flag_daos_args == 0) {
+        no_error = true;
+    }
+
+    if (! mfu_alltrue(no_error, MPI_COMM_WORLD)) {
+        if (rank == 0) {
+           MFU_LOG(MFU_LOG_ERR, "Detected one or more DAOS errors: "
+                   MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+        }
+        return 1;
+    }
+
+    return 0;
+}
+
+/* Setup DAOS arguments.
+ * Connect to pools.
+ * Open containers.
+ * Mount DFS. 
+ * Returns 1 on error, 0 on success */
+static int daos_setup(
+    int rank,
+    char** argpaths,
+    daos_args_t* da,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
+{
+    int tmp_rc;
+
+    /* Each process keeps track of whether it had any DAOS errors.
+     * If there weren't any daos args, then ignore daos_init errors.
+     * Then, perform a reduction and exit if any process errored. */
+    bool local_daos_error = false;
+    int flag_daos_args;
+
+    /* Make sure we have the required DAOS arguments (if any).
+     * Safe to return here, since all processes have the same values. */
+    tmp_rc = daos_check_args(rank, argpaths, da, &flag_daos_args);
+    if (tmp_rc != 0) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+        }
+        return 1;
+    }
+
+    /* For now, track the error.
+     * Later, ignore if no daos args supplied */
+    tmp_rc = daos_init();
+    if (tmp_rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to initialize daos");
+        local_daos_error = true;
+    }
+
+    /* Figure out if daos path is the src or dst,
+     * using UNS path, then chop off UNS path
+     * prefix since the path is mapped to the root
+     * of the container in the DAOS DFS mount */
+    if (!local_daos_error
+            && (!daos_uuid_valid(da->src_pool_uuid) || !daos_uuid_valid(da->dst_pool_uuid))) {
+        tmp_rc = daos_set_paths(rank, argpaths, da, mfu_src_file, mfu_dst_file);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+            local_daos_error = true;
+        }
+    }
+
+    /* Re-check the required DAOS arguments (if any) */
+    if (!local_daos_error) {
+        tmp_rc = daos_check_args(rank, argpaths, da, &flag_daos_args);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+            local_daos_error = true;
+        }
+    }
+
+    /* Make sure there weren't any errors before continuing.
+     * Since daos_connect has a collective broadcast.
+     * we have to make sure same_pool below is valid. */
+    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
+        tmp_rc = daos_fini();
+        return 1;
+    }
+
+    /* check if DAOS source and destination containers are in the same pool */
+    bool same_pool = false;
+    if (mfu_src_file->type == DAOS && mfu_dst_file->type == DAOS) {
+        if (uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
+            same_pool = true;
+        }
+    }
+
+    /* connect to DAOS source pool if uuid is valid */
+    if (!local_daos_error && mfu_src_file->type == DAOS) {
+        /* Open pool connection, but do not create container if non-existent */
+        tmp_rc = daos_connect(rank, da->src_pool_uuid,
+                da->src_cont_uuid, &da->src_poh, &da->src_coh, true, false);
+        if (tmp_rc != 0) {
+            /* tmp_rc from daos_connect is collective */
+            local_daos_error = true;
+        }
+    }
+
+    /* If the source and destination are in the same pool,
+     * then open the container in that pool.
+     * Otherwise, connect to the second pool and open the container */
+    if (!local_daos_error && mfu_dst_file->type == DAOS) {
+        if (same_pool) {
+            /* Don't reconnect to pool, but do create container if non-existent */
+            tmp_rc = daos_connect(rank, da->dst_pool_uuid,
+                    da->dst_cont_uuid, &da->src_poh, &da->dst_coh, false, true);
+        } else {
+            /* Open pool connection, and create container if non-existent */
+            tmp_rc = daos_connect(rank, da->dst_pool_uuid,
+                    da->dst_cont_uuid, &da->dst_poh, &da->dst_coh, true, true);
+        }
+        if (tmp_rc != 0) {
+            /* tmp_rc from daos_connect is collective */
+            local_daos_error = true;
+        }
+    }
+
+    if (!local_daos_error && mfu_src_file->type == DAOS) {
+        /* DFS is mounted for the source container */
+        tmp_rc = daos_mount(mfu_src_file, &da->src_poh, &da->src_coh);
+        if (tmp_rc != 0) {
+            local_daos_error = true;
+        }
+    }
+
+    if (!local_daos_error && mfu_dst_file->type == DAOS) {
+        /* DFS is mounted for the destination container */
+        if (same_pool) {
+            tmp_rc = daos_mount(mfu_dst_file, &da->src_poh, &da->dst_coh);
+        } else {
+            tmp_rc = daos_mount(mfu_dst_file, &da->dst_poh, &da->dst_coh);
+        }
+        if (tmp_rc != 0) {
+            local_daos_error = true;
+        }
+    }
+
+    /* Return if any process had a daos error */
+    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
+        tmp_rc = daos_fini();
+        return 1;
+    }
+
+    /* Everything looks good so far */
+    return 0;
+}
+
+/* Unmount DFS.
+ * Disconnect from pool/cont.
+ * Cleanup DAOS-related vars, handles. 
+ * Finalize DAOS. */
+static int daos_cleanup(
+    daos_args_t* da,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
+{
+    /* assume success until failure */
+    int rc = 0;
+    int tmp_rc;
+
+    bool same_pool = false;
+    if (daos_uuid_valid(da->src_pool_uuid) && daos_uuid_valid(da->dst_pool_uuid)
+            && uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
+        same_pool = true;
+    }
+
+    if (mfu_src_file->type == DAOS) {
+        tmp_rc = daos_umount(mfu_src_file);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            rc = 1;
+        }
+
+        /* Close the container */
+        tmp_rc = daos_cont_close(da->src_coh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+            rc = 1;
+        }
+    }
+
+    if (mfu_dst_file->type == DAOS) {
+        tmp_rc = daos_umount(mfu_dst_file);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            rc = 1;
+        }
+
+        /* Close the container */
+        tmp_rc = daos_cont_close(da->dst_coh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+            rc = 1;
+        }
+    }
+
+    if (mfu_src_file->type == DAOS) {
+        tmp_rc = daos_pool_disconnect(da->src_poh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from source pool");
+            rc = 1;
+        }
+    }
+
+    if (mfu_dst_file->type == DAOS && !same_pool) {
+        tmp_rc = daos_pool_disconnect(da->dst_poh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool");
+            rc = 1;
+        }
+    }
+
+    /* Finalize DAOS */
+    tmp_rc = daos_fini();
+    if (tmp_rc != 0) {
+        rc = 1;
+    }
+
+    /* Free DAOS args */
+    daos_args_delete(&da);
+
+    return rc;
+}
+#endif 
+
 static int input_flist_skip(const char* name, void *args)
 {
     /* nothing to do if args are NULL */
@@ -38,7 +546,7 @@ static int input_flist_skip(const char* name, void *args)
         mfu_path_result result = mfu_path_cmp(path, src_path);
         if (result == MFU_PATH_SRC_CHILD || result == MFU_PATH_EQUAL) {
             MFU_LOG(MFU_LOG_INFO, "Need to copy %s because of %s.",
-               name, src_name);
+                    name, src_name);
             mfu_path_delete(&src_path);
             mfu_path_delete(&path);
             return 0;
@@ -65,16 +573,25 @@ void print_usage(void)
 #ifdef LUSTRE_SUPPORT
     /* printf("  -g, --grouplock <id> - use Lustre grouplock when reading/writing file\n"); */
 #endif
-    printf("  -b, --blocksize     - IO buffer size in bytes (default 1MB)\n");
-    printf("  -i, --input <file>  - read source list from file\n");
-    printf("  -k, --chunksize     - work size per task in bytes (default 1MB)\n");
-    printf("  -p, --preserve      - preserve permissions, ownership, timestamps, extended attributes\n");
-    printf("  -s, --synchronous   - use synchronous read/write calls (O_DIRECT)\n");
-    printf("  -S, --sparse        - create sparse files when possible\n");
-    printf("      --progress <N>  - print progress every N seconds\n");
-    printf("  -v, --verbose       - verbose output\n");
-    printf("  -q, --quiet         - quiet output\n");
-    printf("  -h, --help          - print usage\n");
+    printf("  -b, --blocksize <SIZE>   - IO buffer size in bytes (default " MFU_BLOCK_SIZE_STR ")\n");
+    printf("  -k, --chunksize <SIZE>   - work size per task in bytes (default " MFU_CHUNK_SIZE_STR ")\n");
+#ifdef DAOS_SUPPORT
+    printf("      --daos-src-pool      - DAOS source pool \n");
+    printf("      --daos-dst-pool      - DAOS destination pool \n");
+    printf("      --daos-src-cont      - DAOS source container \n");
+    printf("      --daos-dst-cont      - DAOS destination container \n");
+    printf("      --daos-prefix        - DAOS prefix for unified namespace path \n");
+#endif
+    printf("  -i, --input <file>       - read source list from file\n");
+    printf("  -L, --dereference        - copy original files instead of links\n");
+    printf("  -P, --no-dereference     - don't follow links in source\n");
+    printf("  -p, --preserve           - preserve permissions, ownership, timestamps, extended attributes\n");
+    printf("  -s, --direct             - open files with O_DIRECT\n");
+    printf("  -S, --sparse             - create sparse files when possible\n");
+    printf("      --progress <N>       - print progress every N seconds\n");
+    printf("  -v, --verbose            - verbose output\n");
+    printf("  -q, --quiet              - quiet output\n");
+    printf("  -h, --help               - print usage\n");
     printf("For more information see https://mpifileutils.readthedocs.io.\n");
     printf("\n");
     fflush(stdout);
@@ -93,6 +610,10 @@ int main(int argc, char** argv)
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
+    /* pointer to mfu_file src and dest objects */
+    mfu_file_t* mfu_src_file = mfu_file_new();
+    mfu_file_t* mfu_dst_file = mfu_file_new();
+
     /* pointer to mfu_copy opts */
     mfu_copy_opts_t* mfu_copy_opts = mfu_copy_opts_new();
 
@@ -109,17 +630,30 @@ int main(int argc, char** argv)
     /* By default, don't have iput file. */
     char* inputname = NULL;
 
+#ifdef DAOS_SUPPORT
+    /* DAOS vars */ 
+    daos_args_t* daos_args = daos_args_new();    
+#endif
+
     int option_index = 0;
     static struct option long_options[] = {
         {"blocksize"            , required_argument, 0, 'b'},
         {"debug"                , required_argument, 0, 'd'}, // undocumented
         {"grouplock"            , required_argument, 0, 'g'}, // untested
+        {"daos-src-pool"        , required_argument, 0, 'x'},
+        {"daos-dst-pool"        , required_argument, 0, 'D'},
+        {"daos-src-cont"        , required_argument, 0, 'y'},
+        {"daos-dst-cont"        , required_argument, 0, 'Y'},
+        {"daos-prefix"          , required_argument, 0, 'X'},
         {"input"                , required_argument, 0, 'i'},
         {"chunksize"            , required_argument, 0, 'k'},
+        {"dereference"          , no_argument      , 0, 'L'},
+        {"no-dereference"       , no_argument      , 0, 'P'},
         {"preserve"             , no_argument      , 0, 'p'},
         {"synchronous"          , no_argument      , 0, 's'},
+        {"direct"               , no_argument      , 0, 's'},
         {"sparse"               , no_argument      , 0, 'S'},
-        {"progress"             , required_argument, 0, 'P'},
+        {"progress"             , required_argument, 0, 'R'},
         {"verbose"              , no_argument      , 0, 'v'},
         {"quiet"                , no_argument      , 0, 'q'},
         {"help"                 , no_argument      , 0, 'h'},
@@ -131,7 +665,7 @@ int main(int argc, char** argv)
     int usage = 0;
     while(1) {
         int c = getopt_long(
-                    argc, argv, "b:d:g:i:k:psSvqh",
+                    argc, argv, "b:d:g:i:k:LPpsSvqh",
                     long_options, &option_index
                 );
 
@@ -203,6 +737,49 @@ int main(int argc, char** argv)
                 }
                 break;
 #endif
+#ifdef DAOS_SUPPORT
+            case 'x':
+                rc = uuid_parse(optarg, daos_args->src_pool_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse source pool uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+                break;
+            case 'D':
+                rc = uuid_parse(optarg, daos_args->dst_pool_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse dst pool uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+                break;
+            case 'y':
+                rc = uuid_parse(optarg, daos_args->src_cont_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse source cont uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+                mfu_src_file->type = DAOS;
+                break;
+            case 'Y':
+                rc = uuid_parse(optarg, daos_args->dst_cont_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse dst cont uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+                mfu_dst_file->type = DAOS;
+                break;
+            case 'X':
+                daos_args->dfs_prefix = MFU_STRDUP(optarg);
+                break;
+#endif
             case 'i':
                 inputname = MFU_STRDUP(optarg);
                 if(rank == 0) {
@@ -220,6 +797,20 @@ int main(int argc, char** argv)
                     mfu_copy_opts->chunk_size = bytes;
                 }
                 break;
+            case 'L':
+                /* turn on dereference.
+                 * turn off no_dereference */
+                mfu_copy_opts->dereference = 1;
+                walk_opts->dereference = 1;
+                mfu_copy_opts->no_dereference = 0;
+                break;
+            case 'P':
+                /* turn on no_dereference.
+                 * turn off dereference */
+                mfu_copy_opts->no_dereference = 1;
+                mfu_copy_opts->dereference = 0;
+                walk_opts->dereference = 0;
+                break;
             case 'p':
                 mfu_copy_opts->preserve = true;
                 if(rank == 0) {
@@ -227,9 +818,9 @@ int main(int argc, char** argv)
                 }
                 break;
             case 's':
-                mfu_copy_opts->synchronous = 1;
+                mfu_copy_opts->direct = 1;
                 if(rank == 0) {
-                    MFU_LOG(MFU_LOG_INFO, "Using synchronous read/write (O_DIRECT)");
+                    MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
                 }
                 break;
             case 'S':
@@ -238,7 +829,7 @@ int main(int argc, char** argv)
                     MFU_LOG(MFU_LOG_INFO, "Using sparse file");
                 }
                 break;
-            case 'P':
+            case 'R':
                 mfu_progress_timeout = atoi(optarg);
                 break;
             case 'v':
@@ -271,10 +862,53 @@ int main(int argc, char** argv)
         usage = 1;
     }
 
+    /* If we need to print the usage
+     * then do so before internal processing */
+    if (usage) {
+        if (rank == 0) {
+            print_usage();
+        }
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    /* Early check to avoid extra processing.
+     * Will be further checked below. */
+    if ((argc-optind) < 2) {
+        MFU_LOG(MFU_LOG_ERR, "A source and destination path is needed: "
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
+    char** argpaths = (&argv[optind]);
+
+#ifdef DAOS_SUPPORT
+    /* Set up DAOS arguments, containers, dfs, etc. */
+    rc = daos_setup(rank, argpaths, daos_args, mfu_src_file, mfu_dst_file);
+    if (rc != 0) {
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+    
+    /* TODO add support for this */
+    if (inputname && mfu_src_file->type == DAOS) {
+        MFU_LOG(MFU_LOG_ERR, "--input is not supported with DAOS"
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+#endif
+
     /* paths to walk come after the options */
     int numpaths = 0;
     int numpaths_src = 0;
     mfu_param_path* paths = NULL;
+
     if (optind < argc) {
         /* determine number of paths specified by user */
         numpaths = argc - optind;
@@ -283,8 +917,8 @@ int main(int argc, char** argv)
         paths = (mfu_param_path*) MFU_MALLOC((size_t)numpaths * sizeof(mfu_param_path));
 
         /* process each path */
-        const char** argpaths = (const char**)(&argv[optind]);
-        mfu_param_path_set_all(numpaths, argpaths, paths);
+
+        mfu_param_path_set_all(numpaths, (const char**)argpaths, paths);
 
         /* advance to next set of options */
         optind += numpaths;
@@ -293,13 +927,10 @@ int main(int argc, char** argv)
         numpaths_src = numpaths - 1;
     }
 
-    if (usage || numpaths_src == 0) {
+    if (numpaths_src == 0) {
         if(rank == 0) {
-            if (usage != 1) {
-                MFU_LOG(MFU_LOG_ERR, "A source and destination path is needed");
-            } else {
-                print_usage();
-            }
+            MFU_LOG(MFU_LOG_ERR, "A source and destination path is needed: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
         }
 
         mfu_param_path_free_all(numpaths, paths);
@@ -314,12 +945,15 @@ int main(int argc, char** argv)
 
     /* Parse the source and destination paths. */
     int valid, copy_into_dir;
-    mfu_param_path_check_copy(numpaths_src, paths, destpath, &valid, &copy_into_dir);
+    mfu_param_path_check_copy(numpaths_src, paths, destpath, mfu_src_file, mfu_dst_file,
+                              mfu_copy_opts->no_dereference, &valid, &copy_into_dir);
     mfu_copy_opts->copy_into_dir = copy_into_dir;
+
     /* exit job if we found a problem */
     if (!valid) {
         if(rank == 0) {
-            MFU_LOG(MFU_LOG_ERR, "Invalid src/dest paths provided. Exiting run.\n");
+            MFU_LOG(MFU_LOG_ERR, "Invalid src/dest paths provided. Exiting run: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
         }
         mfu_param_path_free_all(numpaths, paths);
         mfu_free(&paths);
@@ -332,7 +966,8 @@ int main(int argc, char** argv)
     mfu_flist flist = mfu_flist_new();
 
     if (inputname == NULL) {
-        mfu_flist_walk_param_paths(numpaths_src, paths, walk_opts, flist);
+        /* if daos is set to SRC then use daos_ functions on walk */
+        mfu_flist_walk_param_paths(numpaths_src, paths, walk_opts, flist, mfu_src_file);
     } else {
         struct mfu_flist_skip_args skip_args;
 
@@ -342,13 +977,16 @@ int main(int argc, char** argv)
 
         skip_args.numpaths = numpaths_src;
         skip_args.paths = paths;
-        mfu_flist_stat(input_flist, flist, input_flist_skip, (void *)&skip_args);
+        mfu_flist_stat(input_flist, flist, input_flist_skip, (void *)&skip_args,
+                       walk_opts->dereference, mfu_src_file);
         mfu_flist_free(&input_flist);
     }
 
-    /* copy flist into destination */
-    int tmp_rc = mfu_flist_copy(flist, numpaths_src, paths, destpath, mfu_copy_opts);
-    if (tmp_rc < 0) {
+    /* copy flist into destination */ 
+    rc = mfu_flist_copy(flist, numpaths_src, paths,
+                            destpath, mfu_copy_opts, mfu_src_file,
+                            mfu_dst_file);
+    if (rc < 0) {
         /* hit some sort of error during copy */
         rc = 1;
     }
@@ -371,10 +1009,30 @@ int main(int argc, char** argv)
     /* free the copy options */
     mfu_walk_opts_delete(&walk_opts);
 
-    /* shut down MPI */
-    /* shut down MPI */
+#ifdef DAOS_SUPPORT
+    /* Cleanup DAOS-related variables, etc. */
+    daos_cleanup(daos_args, mfu_src_file, mfu_dst_file);
+#endif
+
+    /* free the mfu_file object */
+    mfu_file_delete(&mfu_src_file);
+    mfu_file_delete(&mfu_dst_file);
+
+    /* Alert the user if there were copy errors */
+    if (rc != 0) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "One or more errors were detected while copying: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DCP_COPY));
+        }
+    }
+
     mfu_finalize();
+
+    /* shut down MPI */
     MPI_Finalize();
 
+    if (rc != 0) {
+        return 1;
+    }
     return 0;
 }
diff --git a/src/ddup/ddup.c b/src/ddup/ddup.c
index c4e3a9b..582ea30 100644
--- a/src/ddup/ddup.c
+++ b/src/ddup/ddup.c
@@ -299,8 +299,11 @@ int main(int argc, char** argv)
     /* allocate a file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file object */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* Walk the path(s) to build the flist */
-    mfu_flist_walk_path(dir, walk_opts, flist);
+    mfu_flist_walk_path(dir, walk_opts, flist, mfu_file);
 
     /* TODO: spread list among procs? */
 
@@ -508,6 +511,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     mfu_free(&group_rank);
     mfu_free(&group_ranks);
     mfu_free(&group_id);
diff --git a/src/dfilemaker1/dfilemaker1.c b/src/dfilemaker1/dfilemaker1.c
index ce97d58..8686372 100644
--- a/src/dfilemaker1/dfilemaker1.c
+++ b/src/dfilemaker1/dfilemaker1.c
@@ -144,9 +144,12 @@ int main(int argc, char* argv[])
   /* pointer to mfu_copy opts */
   mfu_copy_opts_t* mfu_copy_opts = mfu_copy_opts_new();
 
+  /* create new mfu_file objects */
+  mfu_file_t* mfu_file = mfu_file_new();
+
   mfu_flist_mkdir(flist);
   mfu_flist_mknod(flist);
-  mfu_flist_fill(flist, mfu_copy_opts);
+  mfu_flist_fill(flist, mfu_copy_opts, mfu_file);
   //mfu_flist_setmeta()
 
   mfu_flist_free(&flist);
@@ -154,6 +157,9 @@ int main(int argc, char* argv[])
   /* free the copy options */
   mfu_copy_opts_delete(&mfu_copy_opts);
 
+  /* delete file objects */
+  mfu_file_delete(&mfu_file);
+
   /* shut down */
   mfu_finalize();
   MPI_Finalize();
diff --git a/src/dfind/dfind.c b/src/dfind/dfind.c
index 7ec2495..1c25593 100644
--- a/src/dfind/dfind.c
+++ b/src/dfind/dfind.c
@@ -585,9 +585,12 @@ int main (int argc, char** argv)
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read data from cache file */
@@ -631,6 +634,9 @@ int main (int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dreln/dreln.c b/src/dreln/dreln.c
index 1b547b2..57a0da3 100644
--- a/src/dreln/dreln.c
+++ b/src/dreln/dreln.c
@@ -89,7 +89,7 @@ int main (int argc, char* argv[])
         {"input",        1, 0, 'i'},
         {"preserve",     0, 0, 'p'},
         {"relative",     0, 0, 'r'},
-        {"progress",     1, 0, 'P'},
+        {"progress",     1, 0, 'R'},
         {"verbose",      0, 0, 'v'},
         {"quiet",        0, 0, 'q'},
         {"help",         0, 0, 'h'},
@@ -118,7 +118,7 @@ int main (int argc, char* argv[])
             case 'r':
                 relative_targets = 1;
                 break;
-            case 'P':
+            case 'R':
                 mfu_progress_timeout = atoi(optarg);
                 break;
             case 'v':
@@ -217,10 +217,13 @@ int main (int argc, char* argv[])
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* get source file list */
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     } else {
         /* read cache file */
         mfu_flist_read_cache(inputname, flist);
@@ -250,7 +253,7 @@ int main (int argc, char* argv[])
 
     /* create a third list by stat'ing each link to get timestamps and group info */
     mfu_flist linklist = mfu_flist_new();
-    mfu_flist_stat(linklist_prestat, linklist, NULL, NULL);
+    mfu_flist_stat(linklist_prestat, linklist, NULL, NULL, 0, mfu_file);
     mfu_flist_free(&linklist_prestat);
 
     /* initiate progress messages */
@@ -418,6 +421,9 @@ int main (int argc, char* argv[])
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     mfu_path_delete(&path_new);
     mfu_path_delete(&path_old);
 
diff --git a/src/drm/drm.c b/src/drm/drm.c
index 80ea54d..9c9db0e 100644
--- a/src/drm/drm.c
+++ b/src/drm/drm.c
@@ -100,7 +100,7 @@ int main(int argc, char** argv)
         {"dryrun",      0, 0, 'd'},
         {"aggressive",  0, 0, 'A'},
         {"traceless",   0, 0, 'T'},
-        {"progress",    1, 0, 'P'},
+        {"progress",    1, 0, 'R'},
         {"verbose",     0, 0, 'v'},
         {"quiet",       0, 0, 'q'},
         {"help",        0, 0, 'h'},
@@ -164,7 +164,7 @@ int main(int argc, char** argv)
             case 'T':
                 traceless = 1;
                 break;
-            case 'P':
+            case 'R':
                 mfu_progress_timeout = atoi(optarg);
                 break;
             case 'v':
@@ -257,11 +257,14 @@ int main(int argc, char** argv)
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* get our list of files, either by walking or reading an
      * input file */
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read list from file */
@@ -327,6 +330,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dstripe/dstripe.c b/src/dstripe/dstripe.c
index 3020769..a59694b 100644
--- a/src/dstripe/dstripe.c
+++ b/src/dstripe/dstripe.c
@@ -415,7 +415,7 @@ int main(int argc, char* argv[])
         {"size",     1, 0, 's'},
         {"minsize",  1, 0, 'm'},
         {"report",   0, 0, 'r'},
-        {"progress", 1, 0, 'P'},
+        {"progress", 1, 0, 'R'},
         {"verbose",  0, 0, 'v'},
         {"quiet",    0, 0, 'q'},
         {"help",     0, 0, 'h'},
@@ -459,7 +459,7 @@ int main(int argc, char* argv[])
                 /* report striping info */
 		report = 1;
                 break;
-            case 'P':
+            case 'R':
                 mfu_progress_timeout = atoi(optarg);
                 break;
             case 'v':
@@ -549,7 +549,11 @@ int main(int argc, char* argv[])
 
     /* walk list of input paths and stat as we walk */
     mfu_flist flist = mfu_flist_new();
-    mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
+    mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
 
     /* filter down our list to files which don't meet our striping requirements */
     mfu_flist filtered = filter_list(flist, stripes, stripe_size, min_size, &create_prog_count_total, &stripe_prog_bytes_total);
@@ -687,6 +691,9 @@ int main(int argc, char* argv[])
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file object */
+    mfu_file_delete(&mfu_file);
+
     /* free filtered list, path parameters */
     mfu_flist_free(&filtered);
     mfu_param_path_free_all(numpaths, paths);
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index 1dd5d96..12036e6 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -48,16 +48,21 @@ static void print_usage(void)
     printf("Usage: dsync [options] source target\n");
     printf("\n");
     printf("Options:\n");
-    printf("      --dryrun          - show differences, but do not synchronize files\n");
-    printf("  -b  --batch-files <N> - batch files into groups of N during copy\n");
-    printf("  -c, --contents        - read and compare file contents rather than compare size and mtime\n");
-    printf("  -D, --delete          - delete extraneous files from target\n");
-    printf("      --link-dest <DIR> - hardlink to files in DIR when unchanged\n");
-    printf("  -S, --sparse          - create sparse files when possible\n");
-    printf("      --progress <N>    - print progress every N seconds\n");
-    printf("  -v, --verbose         - verbose output\n");
-    printf("  -q, --quiet           - quiet output\n");
-    printf("  -h, --help            - print usage\n");
+    printf("      --dryrun            - show differences, but do not synchronize files\n");
+    printf("  -b  --batch-files <N>   - batch files into groups of N during copy\n");
+    printf("      --blocksize <SIZE>  - IO buffer size in bytes (default " MFU_BLOCK_SIZE_STR ")\n");
+    printf("      --chunksize <SIZE>  - minimum work size per task in bytes (default " MFU_CHUNK_SIZE_STR ")\n");
+    printf("  -c, --contents          - read and compare file contents rather than compare size and mtime\n");
+    printf("  -D, --delete            - delete extraneous files from target\n");
+    printf("  -L, --dereference       - copy original files instead of links\n");
+    printf("  -P, --no-dereference    - don't follow links in source\n"); 
+    printf("  -s, --direct            - open files with O_DIRECT\n");
+    printf("      --link-dest <DIR>   - hardlink to files in DIR when unchanged\n");
+    printf("  -S, --sparse            - create sparse files when possible\n");
+    printf("      --progress <N>      - print progress every N seconds\n");
+    printf("  -v, --verbose           - verbose output\n");
+    printf("  -q, --quiet             - quiet output\n");
+    printf("  -h, --help              - print usage\n");
     printf("\n");
     printf("For more information see https://mpifileutils.readthedocs.io.\n");
     fflush(stdout);
@@ -188,6 +193,11 @@ const char *dsync_default_outputs[] = {
     "EXIST=COMMON@TYPE=COMMON",
     "EXIST=DIFFER",
     "EXIST=COMMON",
+    "EXIST=COMMON@UID=DIFFER",
+    "EXIST=COMMON@GID=DIFFER",
+    "EXIST=COMMON@PERM=DIFFER",
+    "EXIST=COMMON@ATIME=DIFFER",
+    "EXIST=COMMON@MTIME=DIFFER",
     NULL,
 };
 
@@ -682,6 +692,7 @@ static void dsync_strmap_compare_data_link_dest(
     mfu_flist src_compare_list,
     mfu_flist link_compare_list,
     mfu_flist link_same_list,
+    mfu_copy_opts_t* copy_opts,
     uint64_t* count_bytes_read,
     uint64_t* count_bytes_written)
 {
@@ -723,9 +734,12 @@ static void dsync_strmap_compare_data_link_dest(
         /* get length of section that we should compare (bytes) */
         off_t length = (off_t)src_p->length;
         
+        /* get length of file that we should compare (bytes) */
+        off_t filesize = (off_t)src_p->file_size;
+        
         /* compare the contents of the files */
-        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length,
-                1048576, overwrite, count_bytes_read, count_bytes_written, compare_prog);
+        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length, filesize,
+                overwrite, copy_opts, count_bytes_read, count_bytes_written, compare_prog);
         if (compare_rc == -1) {
             /* we hit an error while reading */
             rc = -1;
@@ -793,9 +807,10 @@ static int dsync_strmap_compare_data(
     mfu_flist dst_same_list,
     mfu_flist dst_remove_list,
     size_t strlen_prefix,
+    bool use_hardlinks,
+    mfu_copy_opts_t* copy_opts,
     uint64_t* count_bytes_read,
-    uint64_t* count_bytes_written,
-    bool use_hardlinks)
+    uint64_t* count_bytes_written)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -838,9 +853,12 @@ static int dsync_strmap_compare_data(
         /* get length of section that we should compare (bytes) */
         off_t length = (off_t)src_p->length;
 
+        /* get length of file that we should compare (bytes) */
+        off_t filesize = (off_t)src_p->file_size;
+        
         /* compare the contents of the files */
-        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length,
-                1048576, overwrite, count_bytes_read, count_bytes_written, compare_prog);
+        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length, filesize,
+                overwrite, copy_opts, count_bytes_read, count_bytes_written, compare_prog);
         if (compare_rc == -1) {
             /* we hit an error while reading */
             rc = -1;
@@ -1252,16 +1270,18 @@ static void dsync_only_dst(strmap* src_map,
 }
 
 static int dsync_sync_files(
-        strmap* src_map,
-        strmap* dst_map,
-        const mfu_param_path* src_path,
-        const mfu_param_path* dest_path,
-        const mfu_param_path* link_path,
-        mfu_flist dst_list,
-        mfu_flist dst_remove_list,
-        mfu_flist link_dst_list,
-        mfu_flist src_cp_list,
-        mfu_copy_opts_t* mfu_copy_opts)
+    strmap* src_map,
+    strmap* dst_map,
+    const mfu_param_path* src_path,
+    const mfu_param_path* dest_path,
+    const mfu_param_path* link_path,
+    mfu_flist dst_list,
+    mfu_flist dst_remove_list,
+    mfu_flist link_dst_list,
+    mfu_flist src_cp_list,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1273,11 +1293,12 @@ static int dsync_sync_files(
 
     /* Parse the source and destination paths. */
     int valid, copy_into_dir;
-    mfu_param_path_check_copy(1, src_path, dest_path, &valid, &copy_into_dir);
+    mfu_param_path_check_copy(1, src_path, dest_path, mfu_src_file, mfu_dst_file,
+                              copy_opts->no_dereference, &valid, &copy_into_dir);
 
     /* record copy_into_dir flag result from check_copy into
      * mfu copy options structure */
-    mfu_copy_opts->copy_into_dir = copy_into_dir;
+    copy_opts->copy_into_dir = copy_into_dir;
 
     /* exit job if we found a problem */
     if(!valid) {
@@ -1316,7 +1337,8 @@ static int dsync_sync_files(
         if (rank == 0) {
             MFU_LOG(MFU_LOG_INFO, "Copying items to destination");
         }
-        tmp_rc = mfu_flist_copy(src_cp_list, 1, src_path, dest_path, mfu_copy_opts);
+        tmp_rc = mfu_flist_copy(src_cp_list, 1, src_path, dest_path, copy_opts,
+                                mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -1333,7 +1355,8 @@ static int dsync_sync_files(
             if (rank == 0) {
                 MFU_LOG(MFU_LOG_INFO, "Linking items in destination");
             }
-            tmp_rc = mfu_flist_hardlink(link_dst_list, link_path, dest_path, mfu_copy_opts);
+            tmp_rc = mfu_flist_hardlink(link_dst_list, link_path, dest_path,
+                                        copy_opts, mfu_src_file, mfu_dst_file);
             if (tmp_rc < 0) {
                 rc = -1;
             }
@@ -1349,7 +1372,8 @@ static int dsync_strmap_compare_link_dest(
     strmap* src_map,
     mfu_flist link_list,
     strmap* link_map,
-    mfu_flist link_same_list)
+    mfu_flist link_same_list,
+    mfu_copy_opts_t* copy_opts)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1459,7 +1483,7 @@ static int dsync_strmap_compare_link_dest(
             /* compare file contents byte-by-byte, overwrites destination
              * file in place if found to be different during comparison */
             dsync_strmap_compare_data_link_dest(src_compare_list,
-                link_compare_list, link_same_list,
+                link_compare_list, link_same_list, copy_opts,
                 &total_bytes_read, &total_bytes_written
             );
         } else {
@@ -1500,10 +1524,12 @@ static int dsync_strmap_compare(
     mfu_flist link_list,
     strmap* link_map,
     size_t strlen_prefix,
-    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_copy_opts_t* copy_opts,
     const mfu_param_path* src_path,
     const mfu_param_path* dest_path,
-    const mfu_param_path* link_path)
+    const mfu_param_path* link_path,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1584,9 +1610,6 @@ static int dsync_strmap_compare(
             continue;
         }
 
-        /* add any item that is in both source and destination to meta
-         * refresh list */
-        strmap_setf(metadata_refresh, "%llu=%llu", src_index, dst_index);
 
         /* item exists in both source and destination,
          * so update our state to record that fact */
@@ -1598,6 +1621,25 @@ static int dsync_strmap_compare(
              key);
         assert(tmp_rc >= 0);
 
+        /* add any item that is in both source and destination to meta
+         * refresh list, only include those that have different metadata. */
+        dsync_state uid_state, gid_state, perm_state, atime_state, mtime_state;
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_UID, &uid_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_GID, &gid_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_PERM, &perm_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_ATIME, &atime_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_MTIME, &mtime_state);
+        assert(tmp_rc == 0);
+        if ((uid_state == DCMPS_DIFFER) || (gid_state == DCMPS_DIFFER) ||
+            (perm_state == DCMPS_DIFFER) || (atime_state == DCMPS_DIFFER) ||
+            (mtime_state == DCMPS_DIFFER)) {
+            strmap_setf(metadata_refresh, "%llu=%llu", src_index, dst_index);
+        }
+
         /* Skip if no need to compare type.
          * All the following comparison depends on type. */
         if (!dsync_option_need_compare(DCMPF_TYPE)) {
@@ -1710,8 +1752,8 @@ static int dsync_strmap_compare(
              * and hardlinks are not enabled */
             tmp_rc = dsync_strmap_compare_data(src_compare_list, src_map,
                 dst_compare_list, dst_map, src_list, src_cp_list, dst_same_list,
-                dst_remove_list, strlen_prefix,
-                &total_bytes_read, &total_bytes_written, use_hardlinks
+                dst_remove_list, strlen_prefix, use_hardlinks, copy_opts,
+                &total_bytes_read, &total_bytes_written
             );
             if (tmp_rc < 0) {
                 rc = -1;
@@ -1741,7 +1783,7 @@ static int dsync_strmap_compare(
         /* compare files in source and link-dest and create list of items
          * that are the same */
         rc = dsync_strmap_compare_link_dest(src_list, src_map,
-            link_list, link_map, link_same_list);
+            link_list, link_map, link_same_list, copy_opts);
 
         /* of the items to be copied, some may be actual copies,
          * and some may be hardlinks, we'll break the copy list
@@ -1784,7 +1826,7 @@ static int dsync_strmap_compare(
         /* sync the files that are in the source and destination directories */
         tmp_rc = dsync_sync_files(src_map, dst_map,
             src_path, dest_path, link_path, dst_list, dst_remove_list,
-            link_dst_list, cp_list, mfu_copy_opts);
+            link_dst_list, cp_list, copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -1809,7 +1851,8 @@ static int dsync_strmap_compare(
             uint64_t dst_index = (uint64_t) dst_i;
 
             /* copy metadata values from source to destination, if needed */
-            tmp_rc = mfu_flist_file_sync_meta(src_list, src_index, dst_list, dst_index);
+            tmp_rc = mfu_flist_file_sync_meta(src_list, src_index, dst_list,
+                                              dst_index, mfu_dst_file);
             if (tmp_rc < 0) {
                 rc = -1;
             }
@@ -2781,7 +2824,7 @@ int main(int argc, char **argv)
     mfu_walk_opts_t* walk_opts = mfu_walk_opts_new();
 
     /* pointer to mfu_copy opts */
-    mfu_copy_opts_t* mfu_copy_opts = mfu_copy_opts_new();
+    mfu_copy_opts_t* copy_opts = mfu_copy_opts_new();
 
     /* TODO: allow user to specify file lists as input files */
 
@@ -2801,25 +2844,30 @@ int main(int argc, char **argv)
     mfu_debug_level = MFU_LOG_VERBOSE;
 
     /* By default, sync option will preserve all attributes. */
-    mfu_copy_opts->preserve = true;
+    copy_opts->preserve = true;
 
     /* flag to check for sync option */
-    mfu_copy_opts->do_sync = 1;
+    copy_opts->do_sync = 1;
 
     int option_index = 0;
     static struct option long_options[] = {
-        {"dryrun",        0, 0, 'n'},
-        {"batch-files",   1, 0, 'b'},
-        {"contents",      0, 0, 'c'},
-        {"delete",        0, 0, 'D'},
-        {"output",        1, 0, 'o'}, // undocumented
-        {"debug",         0, 0, 'd'}, // undocumented
-        {"link-dest",     1, 0, 'l'},
-        {"sparse",        0, 0, 'S'},
-        {"progress",      1, 0, 'P'},
-        {"verbose",       0, 0, 'v'},
-        {"quiet",         0, 0, 'q'},
-        {"help",          0, 0, 'h'},
+        {"dryrun",         0, 0, 'n'},
+        {"batch-files",    1, 0, 'b'},
+        {"blocksize",      1, 0, 'B'},
+        {"chunksize",      1, 0, 'k'},
+        {"contents",       0, 0, 'c'},
+        {"delete",         0, 0, 'D'},
+        {"dereference",    0, 0, 'L'},
+        {"no-dereference", 0, 0, 'P'},
+        {"direct",         0, 0, 's'},
+        {"output",         1, 0, 'o'}, // undocumented
+        {"debug",          0, 0, 'd'}, // undocumented
+        {"link-dest",      1, 0, 'l'},
+        {"sparse",         0, 0, 'S'},
+        {"progress",       1, 0, 'R'},
+        {"verbose",        0, 0, 'v'},
+        {"quiet",          0, 0, 'q'},
+        {"help",           0, 0, 'h'},
         {0, 0, 0, 0}
     };
     int ret = 0;
@@ -2828,13 +2876,14 @@ int main(int argc, char **argv)
     /* read in command line options */
     int usage = 0;
     int help  = 0;
+    unsigned long long bytes = 0;
 
     /* Don't delete dst files by default */
     options.delete = 0;
 
     while (1) {
         int c = getopt_long(
-            argc, argv, "b:cDo:Svqh",
+            argc, argv, "b:cDso:LPSvqh",
             long_options, &option_index
         );
 
@@ -2844,7 +2893,29 @@ int main(int argc, char **argv)
 
         switch (c) {
         case 'b':
-            mfu_copy_opts->batch_files = atoi(optarg);
+            copy_opts->batch_files = atoi(optarg);
+            break;
+        case 'B':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse block size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->block_size = (size_t)bytes;
+            }
+            break;
+        case 'k':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse chunk size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->chunk_size = bytes;
+            }
             break;
         case 'c':
             options.contents++;
@@ -2855,6 +2926,25 @@ int main(int argc, char **argv)
         case 'D':
             options.delete = 1;
             break;
+        case 'L':
+            /* turn on dereference.
+             * turn off no_dereference */
+            copy_opts->dereference = 1;
+            walk_opts->dereference = 1;
+            copy_opts->no_dereference = 0;
+        case 'P':
+            /* turn on no_dereference.
+             * turn off dereference */
+            copy_opts->no_dereference = 1;
+            copy_opts->dereference = 0;
+            walk_opts->dereference = 0;
+            break;
+        case 's':
+            copy_opts->direct = true;
+            if(rank == 0) {
+                MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
+            }
+            break;
         case 'l':
             options.link_dest = MFU_STRDUP(optarg);
             break;
@@ -2868,9 +2958,9 @@ int main(int argc, char **argv)
             options.debug++;
             break;
         case 'S':
-            mfu_copy_opts->sparse = 1;
+            copy_opts->sparse = 1;
             break;
-        case 'P':
+        case 'R':
             mfu_progress_timeout = atoi(optarg);
             break;
         case 'v':
@@ -2958,6 +3048,10 @@ int main(int argc, char **argv)
     mfu_flist flist_tmp_src = mfu_flist_new();
     mfu_flist flist_tmp_dst = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_src_file = mfu_file_new();
+    mfu_file_t* mfu_dst_file = mfu_file_new();
+
     mfu_param_path* linkpath = NULL;
     mfu_flist flist_tmp_link = MFU_FLIST_NULL;     
     if (options.link_dest != NULL) {
@@ -2989,7 +3083,7 @@ int main(int argc, char **argv)
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking source path");
     }
-    mfu_flist_walk_param_paths(1, srcpath, walk_opts, flist_tmp_src);
+    mfu_flist_walk_param_paths(1, srcpath, walk_opts, flist_tmp_src, mfu_src_file);
 
     /* check that we actually got something so that we don't delete
      * an entire target directory because of a typo on the source dir */
@@ -3012,20 +3106,26 @@ int main(int argc, char **argv)
         return 1;
     }
 
-    /* walk destinaton path */
+    /* walk destinaton path.
+     * We never dereference the destination */
+    int tmp_dereference = walk_opts->dereference;
+    walk_opts->dereference = 0;
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking destination path");
     }
-    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist_tmp_dst);
+    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist_tmp_dst, mfu_dst_file);
 
     /* walk link-dest path if we have one */
     if (options.link_dest != NULL) {
         if (rank == 0) {
             MFU_LOG(MFU_LOG_INFO, "Walking link-dest path");
         }
-        mfu_flist_walk_param_paths(1, linkpath, walk_opts, flist_tmp_link);
+        mfu_flist_walk_param_paths(1, linkpath, walk_opts, flist_tmp_link, mfu_dst_file);
     }
 
+    /* reset the dereference flag */
+    walk_opts->dereference = tmp_dereference;
+
     /* store src and dest path strings */
     const char* path_src = srcpath->path;
     const char* path_dst = destpath->path;
@@ -3061,7 +3161,7 @@ int main(int argc, char **argv)
 
     /* compare files in map_src with those in map_dst */
     int tmp_rc = dsync_strmap_compare(flist_src, map_src, flist_dst, map_dst, flist_link, map_link,
-        strlen(path_src), mfu_copy_opts, srcpath, destpath, linkpath);
+        strlen(path_src), copy_opts, srcpath, destpath, linkpath, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = 1;
     }
@@ -3092,14 +3192,18 @@ int main(int argc, char **argv)
         mfu_free(&linkpath);
     }
 
-    /* free the copy options structure */
-    mfu_copy_opts_delete(&mfu_copy_opts);
-
     dsync_option_fini();
 
+    /* free the copy options structure */
+    mfu_copy_opts_delete(&copy_opts);
+
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_src_file);
+    mfu_file_delete(&mfu_dst_file);
+
     /* shut down */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dwalk/dwalk.c b/src/dwalk/dwalk.c
index fe41994..ad5be94 100644
--- a/src/dwalk/dwalk.c
+++ b/src/dwalk/dwalk.c
@@ -309,6 +309,7 @@ static void print_usage(void)
     printf("  -d, --distribution <field>:<separators> \n                          - print distribution by field\n");
     printf("  -f, --file_histogram    - print default size distribution of items\n");
     printf("  -p, --print             - print files to screen\n");
+    printf("  -L, --dereference       - follow symbolic links\n");
     printf("      --progress <N>      - print progress every N seconds\n");
     printf("  -v, --verbose           - verbose output\n");
     printf("  -q, --quiet             - quiet output\n");
@@ -373,7 +374,8 @@ int main(int argc, char** argv)
         {"distribution",   1, 0, 'd'},
         {"file_histogram", 0, 0, 'f'},
         {"print",          0, 0, 'p'},
-        {"progress",       1, 0, 'P'},
+        {"dereference",    0, 0, 'L'},
+        {"progress",       1, 0, 'R'},
         {"verbose",        0, 0, 'v'},
         {"quiet",          0, 0, 'q'},
         {"help",           0, 0, 'h'},
@@ -383,7 +385,7 @@ int main(int argc, char** argv)
     int usage = 0;
     while (1) {
         int c = getopt_long(
-                    argc, argv, "i:o:tls:d:fpvqh",
+                    argc, argv, "i:o:tls:d:fpLvqh",
                     long_options, &option_index
                 );
 
@@ -414,7 +416,10 @@ int main(int argc, char** argv)
             case 'p':
                 print = 1;
                 break;
-            case 'P':
+            case 'L':
+                walk_opts->dereference = 1;
+                break;
+            case 'R':
                 mfu_progress_timeout = atoi(optarg);
                 break;
             case 'v':
@@ -572,9 +577,12 @@ int main(int argc, char** argv)
     /* create an empty file list with default values */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file object */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read data from cache file */
@@ -630,6 +638,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file object */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();
