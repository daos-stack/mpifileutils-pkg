From a059f299c3b0d4f4409a0ce48360a1081645d1b4 Mon Sep 17 00:00:00 2001
From: Danielle Sikich <danielle.sikich@intel.com>
Date: Mon, 27 Apr 2020 21:18:49 -0700
Subject: [PATCH 01/27] dcp: support DAOS

    - Use mfu_file_t struct to wrap fd vs obj
    - create DAOS specific io functions
    - Create mfu_file_* functions that call DAOS backend
    - Add DAOS I/O functions to common library
    - call daos io backend in dcp
    - Add FindCART.cmake and FindDAOS.cmake
    - Add ifdef to DAOS specific code
    - create mfu_file in all tools for walk

Signed-off-by: Danielle Sikich <danielle.sikich@intel.com>
---
 CMakeLists.txt                |  17 +
 cmake/FindCART.cmake          |  38 ++
 cmake/FindDAOS.cmake          |  55 +++
 doc/rst/dcp.1.rst             |  27 +-
 src/common/mfu_flist.h        |  31 +-
 src/common/mfu_flist_copy.c   | 416 ++++++++++++--------
 src/common/mfu_flist_walk.c   |  75 ++--
 src/common/mfu_io.c           | 692 +++++++++++++++++++++++++++++++++-
 src/common/mfu_io.h           |  57 ++-
 src/common/mfu_param_path.c   |  19 +-
 src/common/mfu_param_path.h   |  27 +-
 src/common/mfu_util.c         | 110 +++++-
 src/common/mfu_util.h         |  42 ++-
 src/dchmod/dchmod.c           |   8 +-
 src/dcmp/dcmp.c               |  11 +-
 src/dcp/dcp.c                 | 336 ++++++++++++++++-
 src/ddup/ddup.c               |   8 +-
 src/dfilemaker1/dfilemaker1.c |   8 +-
 src/dfind/dfind.c             |   8 +-
 src/dreln/dreln.c             |   8 +-
 src/drm/drm.c                 |   8 +-
 src/dstripe/dstripe.c         |   9 +-
 src/dsync/dsync.c             |  37 +-
 src/dwalk/dwalk.c             |   8 +-
 24 files changed, 1787 insertions(+), 268 deletions(-)
 create mode 100755 cmake/FindCART.cmake
 create mode 100755 cmake/FindDAOS.cmake

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7c6e085c..4bd03b8f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -85,6 +85,23 @@ FIND_PACKAGE(LibArchive REQUIRED)
 INCLUDE_DIRECTORIES(${LibArchive_INCLUDE_DIRS})
 LIST(APPEND MFU_EXTERNAL_LIBS ${LibArchive_LIBRARIES})
 
+OPTION(ENABLE_DAOS "Enable DAOS support")
+IF(ENABLE_DAOS)
+  SET(CMAKE_EXE_LINKER_FLAGS -luuid)
+  FIND_PACKAGE(CART REQUIRED)
+  INCLUDE_DIRECTORIES(${CART_INCLUDE_DIRS})
+  message(${CART_INCLUDE_DIRS})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${CART_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${GURT_LIBRARIES})
+  FIND_PACKAGE(DAOS REQUIRED)
+  INCLUDE_DIRECTORIES(${DAOS_INCLUDE_DIRS})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DAOS_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DUNS_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DFS_LIBRARIES})
+  LIST(APPEND MFU_EXTERNAL_LIBS ${DAOS_COMMON_LIBRARIES})
+  ADD_DEFINITIONS(-DDAOS_SUPPORT)
+ENDIF(ENABLE_DAOS)
+
 ## LIBCIRCLE
 FIND_PACKAGE(LibCircle REQUIRED)
 INCLUDE_DIRECTORIES(${LibCircle_INCLUDE_DIRS})
diff --git a/cmake/FindCART.cmake b/cmake/FindCART.cmake
new file mode 100755
index 00000000..216c146f
--- /dev/null
+++ b/cmake/FindCART.cmake
@@ -0,0 +1,38 @@
+# - Try to find cart libs 
+# Once done this will define
+#  cart_FOUND - System has libcart
+#  cart_INCLUDE_DIRS - cart include directories
+#  cart_LIBRARIES - The libraries needed to use cart
+#  gurt_LIBRARIES - The libraries needed to use gurt (part of cart)
+
+FIND_PATH(WITH_CART_PREFIX
+    NAMES cart/include
+)
+
+FIND_LIBRARY(CART_LIBRARIES
+    NAMES cart
+    HINTS ${WITH_CART_PREFIX}/lib
+)
+
+FIND_LIBRARY(GURT_LIBRARIES
+    NAMES gurt
+    HINTS ${WITH_CART_PREFIX}/lib
+)
+
+FIND_PATH(CART_INCLUDE_DIRS
+    NAMES cart/types.h
+    HINTS ${WITH_CART_PREFIX}/include
+)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(CART DEFAULT_MSG
+    CART_LIBRARIES
+    CART_INCLUDE_DIRS
+)
+
+# Hide these vars from ccmake GUI
+MARK_AS_ADVANCED(
+	CART_LIBRARIES
+	GURT_LIBRARIES
+	CART_INCLUDE_DIRS
+)
diff --git a/cmake/FindDAOS.cmake b/cmake/FindDAOS.cmake
new file mode 100755
index 00000000..c06ba2c5
--- /dev/null
+++ b/cmake/FindDAOS.cmake
@@ -0,0 +1,55 @@
+# - Try to find daos libs 
+# Once done this will define
+#  daos_FOUND - System has libdaos
+#  daos_INCLUDE_DIRS - daos.h
+#  daos_LIBRARIES - libdaos
+#  DUNS_LIBRARIES - libduns 
+#  DFS_LIBRARIES - libdfs 
+#  COMMON_LIBRARIES - libdaos_common
+
+FIND_PATH(WITH_DAOS_PREFIX
+    NAMES include/daos.h
+)
+
+FIND_LIBRARY(DAOS_LIBRARIES
+    NAMES daos
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_LIBRARY(DUNS_LIBRARIES
+    NAMES duns
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_LIBRARY(DFS_LIBRARIES
+    NAMES dfs
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_LIBRARY(COMMON_LIBRARIES
+    NAMES daos_common
+    HINTS ${WITH_DAOS_PREFIX}/lib
+)
+
+FIND_PATH(DAOS_INCLUDE_DIRS
+    NAMES daos.h
+    HINTS ${WITH_DAOS_PREFIX}/include
+)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(DAOS DEFAULT_MSG
+    DAOS_LIBRARIES
+    DUNS_LIBRARIES
+    DFS_LIBRARIES
+    COMMON_LIBRARIES
+    DAOS_INCLUDE_DIRS
+)
+
+# Hide these vars from ccmake GUI
+MARK_AS_ADVANCED(
+        DAOS_LIBRARIES
+        DUNS_LIBRARIES
+        DFS_LIBRARIES
+        COMMON_LIBRARIES
+        DAOS_INCLUDE_DIRS
+)
diff --git a/doc/rst/dcp.1.rst b/doc/rst/dcp.1.rst
index 3a26356f..599eb0b4 100644
--- a/doc/rst/dcp.1.rst
+++ b/doc/rst/dcp.1.rst
@@ -19,13 +19,38 @@ file system, and it splits large file copies across multiple processes.
 
 OPTIONS
 -------
-
 .. option:: -b, --blocksize SIZE
 
    Set the I/O buffer to be SIZE bytes.  Units like "MB" and "GB" may
    immediately follow the number without spaces (eg. 8MB). The default
    blocksize is 1MB.
 
+.. option:: --daos-src-pool POOL
+
+   Specify the DAOS source pool to be used.
+
+.. option:: --daos-dst-pool POOL
+
+   Specify the DAOS destination pool to be used.
+
+.. option:: --daos-src-cont CONTAINER
+
+   Specify the DAOS source container to be used.
+
+.. option:: --daos-dst-cont CONTAINER
+
+   Specify the DAOS destination container to be used.
+
+.. option:: --daos-svcl SVC
+
+   Specify the DAOS replication level to be used.
+
+.. option:: --daos-prefix PREFIX
+
+   Specify the DAOS prefix to be used. This is only necessary
+   if copying a subset of a POSIX container in DAOS using a
+   Unified Namespace path.
+
 .. option:: -i, --input FILE
 
    Read source list from FILE. FILE must be generated by another tool
diff --git a/src/common/mfu_flist.h b/src/common/mfu_flist.h
index 53dc2d5a..84db5c85 100644
--- a/src/common/mfu_flist.h
+++ b/src/common/mfu_flist.h
@@ -181,7 +181,8 @@ void mfu_flist_free(mfu_flist* flist);
 void mfu_flist_walk_path(
     const char* path,           /* IN  - path to be walked */
     mfu_walk_opts_t* walk_opts, /* IN  - functions to perform during the walk */
-    mfu_flist flist             /* OUT - flist to insert walked items into */
+    mfu_flist flist,            /* OUT - flist to insert walked items into */
+    mfu_file_t* mfu_file        /* IN  - I/O filesystem functions to use during the walk */
 );
 
 /* create file list by walking list of directories */
@@ -189,7 +190,8 @@ void mfu_flist_walk_paths(
     uint64_t num_paths,         /* IN  - number of paths in array */
     const char** paths,         /* IN  - array of paths to be walkted */
     mfu_walk_opts_t* walk_opts, /* IN  - functions to perform during the walk */
-    mfu_flist flist             /* OUT - flist to insert walked items into */
+    mfu_flist flist,            /* OUT - flist to insert walked items into */
+    mfu_file_t* mfu_file        /* IN  - I/O filesystem functions to use during the walk */
 );
 
 /* given a list of param_paths, walk each one and add to flist */
@@ -197,7 +199,8 @@ void mfu_flist_walk_param_paths(
     uint64_t num,                 /* IN  - number of paths in array */
     const mfu_param_path* params, /* IN  - array of paths to be walkted */
     mfu_walk_opts_t* walk_opts,   /* IN  - functions to perform during the walk */
-    mfu_flist flist               /* OUT - flist to insert walked items into */
+    mfu_flist flist,              /* OUT - flist to insert walked items into */
+    mfu_file_t* mfu_file          /* IN  - I/O filesystem functions to use during the walk */
 );
 
 /* skip function pointer: given a path input, along with user-provided
@@ -433,6 +436,13 @@ int mfu_flist_sort(const char* fields, mfu_flist* flist);
  * Functions to create / remove data on file system based on input list
  ****************************************/
 
+/* allocate a new mfu_file_t structure,
+ * and set its fields with default values */
+mfu_file_t* mfu_file_new(void);
+
+/* free object allocated in mfu_file_new */
+void mfu_file_delete(mfu_file_t** mfile);
+
 /* allocate a new mfu_copy_opts structure,
  * and set its fields with default values */
 mfu_copy_opts_t* mfu_copy_opts_new(void);
@@ -448,7 +458,9 @@ int mfu_flist_copy(
     int numpaths,                   /* IN - number of source paths */
     const mfu_param_path* paths,    /* IN - array of source pathts */
     const mfu_param_path* destpath, /* IN - destination path */
-    mfu_copy_opts_t* mfu_copy_opts  /* IN - options to be used during copy */
+    mfu_copy_opts_t* mfu_copy_opts, /* IN - options to be used during copy */
+    mfu_file_t* mfu_src_file,       /* IN - I/O filesystem functions to use for copy of src */
+    mfu_file_t* mfu_dst_file        /* IN - I/O filesystem functions to use for copy of dst */
 );
 
 /* link items in list from source paths to destination,
@@ -458,14 +470,17 @@ int mfu_flist_hardlink(
     mfu_flist src_link_list,         /* IN - flist providing source items */
     const mfu_param_path* srcpath,   /* IN - the source patht */
     const mfu_param_path* destpath,  /* IN - destination path */
-    mfu_copy_opts_t* mfu_copy_opts   /* IN - options to be used during copy */
+    mfu_copy_opts_t* mfu_copy_opts,  /* IN - options to be used during copy */
+    mfu_file_t* mfu_src_file,        /* IN - I/O filesystem functions for src */
+    mfu_file_t* mfu_dst_file         /* IN - I/O filesystem functions for dst */
 );
 
 /* fill files in list with data
  * returns 0 on success -1 on error */
 int mfu_flist_fill(
     mfu_flist list,                 /* IN - flist providing items */
-    mfu_copy_opts_t* mfu_copy_opts  /* IN - options to be used during fill */
+    mfu_copy_opts_t* mfu_copy_opts, /* IN - options to be used during fill */
+    mfu_file_t* mfu_file            /* IN - I/O filesystem functions */
 );
 
 /* allocate a new mfu_walk_opts structure,
@@ -517,7 +532,9 @@ void mfu_flist_chmod(
 
 /* given a source and destination file, update destination metadata
  * to match source if needed, returns 0 on success -1 on error */
-int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist dst_list, uint64_t dst_index);
+int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index,
+                             mfu_flist dst_list, uint64_t dst_index,
+                             mfu_file_t* mfu_file);
 
 /* TODO: integrate this into the file list proper, or otherwise move it to another file */
 /* element structure in linked list returned by mfu_file_chunk_list_alloc */
diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index 8024cbad..d4e133ab 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -42,8 +42,15 @@
 #include <inttypes.h>
 
 #include <libgen.h> /* dirname */
+#include <stdbool.h>
 #include "libcircle.h"
 #include "dtcmp.h"
+
+#ifdef DAOS_SUPPORT
+#include <gurt/common.h>
+#include <gurt/hash.h>
+#endif
+
 #include "mfu.h"
 #include "mfu_flist_internal.h"
 #include "strmap.h"
@@ -76,9 +83,12 @@ typedef struct {
 /* cache open file descriptor to avoid
  * opening / closing the same file */
 typedef struct {
-    char* name; /* name of open file (NULL if none) */
-    int   read; /* whether file is open for read-only (1) or write (0) */
-    int   fd;   /* file descriptor */
+    char* name;    /* name of open file (NULL if none) */
+    int   read;    /* whether file is open for read-only (1) or write (0) */
+    int   fd;      /* file descriptor */
+#ifdef DAOS_SUPPORT
+    dfs_obj_t* obj; /* open object */
+#endif
 } mfu_copy_file_cache_t;
 
 /****************************************
@@ -92,53 +102,56 @@ static mfu_copy_stats_t mfu_copy_stats;
 static mfu_copy_file_cache_t mfu_copy_src_cache;
 static mfu_copy_file_cache_t mfu_copy_dst_cache;
 
-static int mfu_copy_open_file(const char* file, int read_flag,
-        mfu_copy_file_cache_t* cache, mfu_copy_opts_t* mfu_copy_opts)
+static void mfu_copy_open_file(const char* file, int read_flag,
+        mfu_copy_file_cache_t* cache, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_file)
 {
-    int newfd = -1;
-
     /* see if we have a cached file descriptor */
     char* name = cache->name;
     if (name != NULL) {
         /* we have a cached file descriptor */
-        int fd = cache->fd;
+        int fd         = cache->fd;
+#ifdef DAOS_SUPPORT
+        dfs_obj_t* obj = cache->obj;
+#endif
         if (strcmp(name, file) == 0 && cache->read == read_flag) {
             /* the file we're trying to open matches name and read/write mode,
              * so just return the cached descriptor */
-            return fd;
+            return;
         } else {
             /* the file we're trying to open is different,
              * close the old file and delete the name */
-            mfu_close(name, fd);
+            mfu_file_close(name, mfu_file);
             mfu_free(&cache->name);
         }
     }
-
     /* open the new file */
     if (read_flag) {
         int flags = O_RDONLY;
         if (mfu_copy_opts->synchronous) {
             flags |= O_DIRECT;
         }
-        newfd = mfu_open(file, flags);
+        /* set obj or fd here */
+        mfu_file_open(file, flags, mfu_file);
     } else {
         int flags = O_WRONLY | O_CREAT;
         if (mfu_copy_opts->synchronous) {
             flags |= O_DIRECT;
         }
-        newfd = mfu_open(file, flags, DCOPY_DEF_PERMS_FILE);
+        /* set obj or fd here */
+        mfu_file_open(file, flags, mfu_file, DCOPY_DEF_PERMS_FILE);
     }
 
     /* cache the file descriptor */
-    if (newfd != -1) {
+    if (mfu_file->fd != -1 && mfu_file->type == POSIX) {
         cache->name = MFU_STRDUP(file);
-        cache->fd   = newfd;
+        cache->fd   = mfu_file->fd;
         cache->read = read_flag;
 #ifdef LUSTRE_SUPPORT
         /* Zero is an invalid ID for grouplock. */
         if (mfu_copy_opts->grouplock_id != 0) {
             errno = 0;
-            int rc = ioctl(newfd, LL_IOC_GROUP_LOCK, mfu_copy_opts->grouplock_id);
+            int rc = ioctl(mfu_file->fd, LL_IOC_GROUP_LOCK, mfu_copy_opts->grouplock_id);
             if (rc) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to obtain grouplock with ID %d "
                     "on file `%s', ignoring this error (errno=%d %s)",
@@ -146,13 +159,18 @@ static int mfu_copy_open_file(const char* file, int read_flag,
             } else {
                 MFU_LOG(MFU_LOG_INFO, "Obtained grouplock with ID %d "
                     "on file `%s', fd %d", mfu_copy_opts->grouplock_id,
-                    file, newfd);
+                    file, mfu_file->fd);
             }
         }
 #endif
     }
-
-    return newfd;
+#ifdef DAOS_SUPPORT
+    if (mfu_file->obj != NULL && mfu_file->type == DAOS) {
+        cache->name = MFU_STRDUP(file);
+        cache->read = read_flag;
+        cache->obj  = mfu_file->obj;
+    }
+#endif
 }
 
 /* copy all extended attributes from op->operand to dest_path,
@@ -339,7 +357,8 @@ static int mfu_copy_ownership(
 static int mfu_copy_permissions(
     mfu_flist flist,
     uint64_t idx,
-    const char* dest_path)
+    const char* dest_path,
+    mfu_file_t* mfu_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -350,14 +369,12 @@ static int mfu_copy_permissions(
 
     /* change mode */
     if(type != MFU_TYPE_LINK) {
-        if(mfu_chmod(dest_path, mode) != 0) {
+        if(mfu_file_chmod(dest_path, mode, mfu_file) != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to change permissions on `%s' chmod() (errno=%d %s)",
-                dest_path, errno, strerror(errno)
-               );
+                dest_path, errno, strerror(errno));
             rc = -1;
         }
     }
-
     return rc;
 }
 
@@ -381,56 +398,57 @@ static int mfu_copy_acls(
           * We use the opaque method as we are not trying to alter the ACL contents.
           * Note that if the source is not a GPFS file-system, then the call will
           * fail with EINVAL and so we never try to apply this to the dest_path */
-     
+
          /* need the file path to read the existing ACL */
          const char* src_path = mfu_flist_file_get_name(flist, idx);
-     
+
          /* acl param mapped with gpfs_opaque_acl_t structure */
          int aclflags = 0;
          unsigned char acltype = GPFS_ACL_TYPE_ACCESS;
-     
+
          /* initial size of the struct for gpfs_opaque_acl, 512 bytes should
           * be large enough for a fairly large ACL anyway */
          size_t bufsize = 512;
-     
+
          /* gpfs_getacl needs a *void for where it will place the data, so we need
           * to allocate some memory and then place a gpfs_opaque_acl into the
           * memory as aclflags is set to 0 to indicate gpfs_opaque_acl_t */
          void* aclbufmem = MFU_MALLOC(bufsize);
          memset(aclbufmem, 0, bufsize);
-     
+
          /* set fields in structure to define acl query */
          struct gpfs_opaque_acl* aclbuffer = (struct gpfs_opaque_acl*) aclbufmem;
          aclbuffer->acl_buffer_len = (int) (bufsize - sizeof(struct gpfs_opaque_acl));
          aclbuffer->acl_type = acltype;
-     
+
          /* try and get the ACL */
          errno = 0;
          int r = gpfs_getacl(src_path, aclflags, aclbufmem);
-     
+
          /* the buffer may not be big enough, if not, we'll get EONSPC and
           * the first 4 bytes (acl_buffer_len) will tell us how much space we need */
+
          if ((r != 0) && (errno == ENOSPC)) {
            /* make a buffer which is exactly the right size */
            unsigned int len = *(unsigned int*) &(aclbuffer->acl_buffer_len);
            bufsize = len + sizeof(struct gpfs_opaque_acl);
            MFU_LOG(MFU_LOG_DBG, "GPFS ACL buffer too small, needs to be %d",
                    (int) bufsize);
-     
+
            /* free the old buffer, then malloc the new size */
            mfu_free(&aclbufmem);
            aclbufmem = MFU_MALLOC(bufsize);
            memset(aclbufmem, 0, bufsize);
-     
+
            /* set fields in structure to define acl query */
            aclbuffer = (struct gpfs_opaque_acl*) aclbufmem;
            aclbuffer->acl_buffer_len = (int) (bufsize - sizeof(struct gpfs_opaque_acl));
            aclbuffer->acl_type = acltype;
-     
+
            /* once again try and get the ACL */
            r = gpfs_getacl(src_path, aclflags, aclbufmem);
          }
-     
+
          /* check whether we read the ACL successfully */
          if (r == 0) {
            /* Assuming we now have a valid call to an ACL,
@@ -451,10 +469,10 @@ static int mfu_copy_acls(
              rc = -1;
            }
          }
-     
+
          /* free the memory from the buffer */
          mfu_free(&aclbufmem);
-    }
+
 #endif /* GPFS_SUPPORT */
 
     return rc;
@@ -497,7 +515,7 @@ static int mfu_copy_timestamps(
     return rc;
 }
 
-static int mfu_copy_close_file(mfu_copy_file_cache_t* cache)
+static int mfu_copy_close_file(mfu_copy_file_cache_t* cache, mfu_file_t* mfu_file)
 {
     int rc = 0;
 
@@ -505,15 +523,17 @@ static int mfu_copy_close_file(mfu_copy_file_cache_t* cache)
     char* name = cache->name;
     if (name != NULL) {
         int fd = cache->fd;
-
+#ifdef DAOS_SUPPORT
+        dfs_obj_t* obj = cache->obj;
+#endif
         /* if open for write, fsync */
         int read_flag = cache->read;
-        if (! read_flag) {
+        if (! read_flag && mfu_file->type == POSIX) {
             rc = mfu_fsync(name, fd);
         }
 
         /* close the file and delete the name string */
-        rc = mfu_close(name, fd);
+        rc = mfu_file_close(name, mfu_file);
         mfu_free(&cache->name);
     }
 
@@ -560,7 +580,8 @@ static void meta_progress_fn(const uint64_t* vals, int count, int complete, int
  * parent directory */
 static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
         int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -608,7 +629,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
 
             /* get destination name of item */
             char* dest = mfu_param_path_copy_dest(name, numpaths,
-                    paths, destpath, mfu_copy_opts);
+                    paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
             /* No need to copy it */
             if (dest == NULL) {
@@ -623,7 +644,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -639,7 +660,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
             else {
                 /* TODO: set permissions based on source permissons
                  * masked by umask */
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -689,7 +710,8 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
  * parent directory */
 static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists,
         int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -734,7 +756,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
 
             /* get destination name of item */
             char* dest = mfu_param_path_copy_dest(name, numpaths,
-                    paths, destpath, mfu_copy_opts);
+                    paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
             /* No need to copy it */
             if (dest == NULL) {
@@ -755,7 +777,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -771,7 +793,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
             else {
                 /* TODO: set permissions based on source permissons
                  * masked by umask */
-                tmp_rc = mfu_copy_permissions(list, idx, dest);
+                tmp_rc = mfu_copy_permissions(list, idx, dest, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -816,7 +838,8 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
  * returns 0 on success and -1 on error */
 static int mfu_create_directory(mfu_flist list, uint64_t idx,
         int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -826,7 +849,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     char* dest_path = mfu_param_path_copy_dest(name, numpaths, paths,
-            destpath, mfu_copy_opts);
+            destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -855,7 +878,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
 
     /* create the destination directory */
     MFU_LOG(MFU_LOG_DBG, "Creating directory `%s'", dest_path);
-    int mkdir_rc = mfu_mkdir(dest_path, DCOPY_DEF_PERMS_DIR);
+    int mkdir_rc = mfu_file_mkdir(dest_path, DCOPY_DEF_PERMS_DIR, mfu_dst_file);
     if(mkdir_rc < 0) {
         if(errno == EEXIST) {
             MFU_LOG(MFU_LOG_WARN,
@@ -897,7 +920,8 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
  * returns 0 on success and -1 on failure */
 static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
         int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -938,7 +962,7 @@ static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
             if (type == MFU_TYPE_DIR) {
                 /* create the directory */
                 int tmp_rc = mfu_create_directory(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1005,7 +1029,8 @@ static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
  * returns 0 on success and -1 on error */
 static int mfu_create_link(mfu_flist list, uint64_t idx,
         int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1015,7 +1040,7 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, numpaths,
-           paths, destpath, mfu_copy_opts);
+           paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1076,7 +1101,8 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
  * returns 0 on success and -1 on error */
 static int mfu_create_file(mfu_flist list, uint64_t idx,
         int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1086,7 +1112,7 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, numpaths,
-            paths, destpath, mfu_copy_opts);
+            paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1101,12 +1127,11 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
      * see makedev() to create valid dev */
     dev_t dev;
     memset(&dev, 0, sizeof(dev_t));
-    int mknod_rc = mfu_mknod(dest_path, DCOPY_DEF_PERMS_FILE | S_IFREG, dev);
+    int mknod_rc = mfu_file_mknod(dest_path, DCOPY_DEF_PERMS_FILE | S_IFREG, dev, mfu_dst_file);
     if(mknod_rc < 0) {
         if(errno == EEXIST) {
             /* destination already exists, no big deal, but print warning */
-            MFU_LOG(MFU_LOG_WARN,
-                    "Original file exists, skip the creation: `%s' (errno=%d %s)",
+            MFU_LOG(MFU_LOG_WARN, "Original file exists, skip the creation: `%s' (errno=%d %s)",
                     dest_path, errno, strerror(errno));
         } else {
             /* failed to create inode, that's a problem */
@@ -1134,7 +1159,7 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
     if (mfu_copy_opts->sparse) {
         /* truncate destination file to 0 bytes */
         struct stat st;
-        int status = mfu_lstat(dest_path, &st);
+        int status = mfu_file_lstat(dest_path, &st, mfu_dst_file);
         if (status == 0) {
             /* destination exists, truncate it to 0 bytes */
             status = mfu_truncate(dest_path, 0);
@@ -1167,8 +1192,9 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
 /* creates hardlink in destpath for specified file, identifies source path
  * returns 0 on success and -1 on error */
 static int mfu_create_hardlink(mfu_flist list, uint64_t idx,
-        const mfu_param_path* srcpath,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* srcpath, const mfu_param_path* destpath,
+        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file,
+        mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1178,7 +1204,7 @@ static int mfu_create_hardlink(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, 1,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1238,9 +1264,10 @@ static void create_progress_fn(const uint64_t* vals, int count, int complete, in
 
 /* creates file inodes and symlinks,
  * returns 0 on success and -1 on error */
-static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+static int mfu_create_files(int levels, int minlevel,
+        mfu_flist* lists, int numpaths, const mfu_param_path* paths,
+        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     int rc = 0;
 
@@ -1284,7 +1311,7 @@ static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
             if (type == MFU_TYPE_FILE) {
                 /* create inode and copy xattr for regular file */
                 int tmp_rc = mfu_create_file(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1293,7 +1320,7 @@ static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
             } else if (type == MFU_TYPE_LINK) {
                 /* create symlink */
                 int tmp_rc = mfu_create_link(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1360,8 +1387,9 @@ static int mfu_create_files(int levels, int minlevel, mfu_flist* lists,
 /* creates hardlinks,
  * returns 0 on success and -1 on error */
 static int mfu_create_hardlinks(int levels, int minlevel, mfu_flist* lists,
-        const mfu_param_path* srcpath,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        const mfu_param_path* srcpath, const mfu_param_path* destpath,
+        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file,
+        mfu_file_t* mfu_dst_file)
 {
     int rc = 0;
 
@@ -1404,8 +1432,9 @@ static int mfu_create_hardlinks(int levels, int minlevel, mfu_flist* lists,
                 continue;
             }
 
-            int tmp_rc = mfu_create_hardlink(list, idx, srcpath, destpath,
-                                             mfu_copy_opts);
+            int tmp_rc = mfu_create_hardlink(list, idx, srcpath,
+                                             destpath, mfu_copy_opts,
+                                             mfu_src_file, mfu_dst_file);
             if (tmp_rc != 0) {
                 rc = -1;
             }
@@ -1530,12 +1559,12 @@ static int mfu_is_all_null(const char* buf, uint64_t buf_size)
 /* when using sparse files, we need to write the last byte if the
  * hole is adjacent to EOF, so we need to detect whether we're at
  * the end of the file */
-static int mfu_is_eof(const char* file, int fd)
+static int mfu_is_eof(const char* file, mfu_file_t* mfu_file)
 {
     /* read one byte from fd to determine whether this is EOF.
      * This is not efficient, but it is the only reliable way */
     char buf[1];
-    ssize_t num_of_bytes_read = mfu_read(file, fd, buf, 1);
+    ssize_t num_of_bytes_read = mfu_file_read(file, buf, 1, mfu_file);
 
     /* return if we detect EOF */
     if(! num_of_bytes_read) {
@@ -1543,7 +1572,7 @@ static int mfu_is_eof(const char* file, int fd)
     }
 
     /* otherwise, we're not at EOF yet, seek back one byte */
-    if(mfu_lseek(file, fd, -1, SEEK_CUR) == (off_t)-1) {
+    if(mfu_file_lseek(file, mfu_file, -1, SEEK_CUR) == (off_t)-1) {
         MFU_LOG(MFU_LOG_ERR, "Couldn't seek in path `%s' (errno=%d %s)",
                   file, errno, strerror(errno));
         return -1;
@@ -1554,33 +1583,55 @@ static int mfu_is_eof(const char* file, int fd)
 static int mfu_copy_file_normal(
     const char* src,
     const char* dest,
-    const int in_fd,
-    const int out_fd,
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
-    /* hint that we'll read from file sequentially */
-//    posix_fadvise(in_fd, offset, chunk_size, POSIX_FADV_SEQUENTIAL);
-
+    /* There is no equivalent "lseek" in daos, it is part of read, so skip that
+     * for a DAOS path */
     /* seek to offset in source file */
-    if(mfu_lseek(src, in_fd, offset, SEEK_SET) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)",
-            src, errno, strerror(errno));
+    if(mfu_file_lseek(src, mfu_src_file, offset, SEEK_SET) == (off_t)-1) {
+        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)", src, errno, strerror(errno));
         return -1;
     }
 
     /* seek to offset in destination file */
-    if(mfu_lseek(dest, out_fd, offset, SEEK_SET) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
-            dest, errno, strerror(errno));
+    if (mfu_file_lseek(dest, mfu_dst_file, offset, SEEK_SET) == (off_t)-1) {
+        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)", dest, errno, strerror(errno));
         return -1;
     }
 
-    /* get buffer */
+    /* declare daos vars */
+#ifdef DAOS_SUPPORT
+    daos_size_t got_size;
+    d_sg_list_t sgl;
+    d_iov_t     iov;
+#endif
+
+    /* set buffer and buffer size */
     size_t buf_size = mfu_copy_opts->block_size;
-    void* buf = mfu_copy_opts->block_buf1;
+    void* buf       = mfu_copy_opts->block_buf1;
+
+    /* set daos vars and buffers */
+#ifdef DAOS_SUPPORT
+    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
+        sgl.sg_nr = 1;
+        D_ALLOC(buf, buf_size);
+        D_ASSERT(buf != NULL);
+        d_iov_set(&iov, buf, buf_size);
+        sgl.sg_iovs = &iov;
+        sgl.sg_nr_out = 1;
+        if (mfu_src_file->type == DAOS) {
+            mfu_src_file->sgl = &sgl;
+        }
+        if (mfu_dst_file->type == DAOS) {
+            mfu_dst_file->sgl = &sgl;
+        }
+    }
+#endif
 
     /* write data */
     size_t total_bytes = 0;
@@ -1588,16 +1639,18 @@ static int mfu_copy_file_normal(
         /* determine number of bytes that we
          * can read = max(buf size, remaining chunk) */
         size_t left_to_read = (size_t)length - total_bytes;
+        
         if(left_to_read > buf_size) {
             left_to_read = buf_size;
         }
+
         if(mfu_copy_opts->synchronous) {
             /* O_DIRECT requires particular read sizes */
             left_to_read = buf_size;
         }
 
         /* read data from source file */
-        ssize_t num_of_bytes_read = mfu_read(src, in_fd, buf, left_to_read);
+        ssize_t num_of_bytes_read = mfu_file_read(src, buf, left_to_read, mfu_src_file);
 
         /* check for EOF */
         if(! num_of_bytes_read) {
@@ -1628,12 +1681,13 @@ static int mfu_copy_file_normal(
          * because write of next chunk will create one for us.
          * Write only the last byte to create the hole,
          * if the hole is next to EOF. */
+        /* TODO: add code for daos api to support sparse files? */
         ssize_t num_of_bytes_written = (ssize_t)bytes_to_write;
         if (mfu_copy_opts->sparse && mfu_is_all_null(buf, bytes_to_write)) {
             /* TODO: isn't there a better way to know if we're at EOF,
              * e.g., by using file size? */
             /* determine whether we're at the end of the file */
-            int end_of_file = mfu_is_eof(src, in_fd);
+            int end_of_file = mfu_is_eof(src, mfu_src_file);
             if (end_of_file < 0) {
                 /* hit an error while looking for EOF */
                 return -1;
@@ -1644,18 +1698,18 @@ static int mfu_copy_file_normal(
              * ahead without writing anything */
             if (end_of_file) {
                 /* seek to last byte position in file */
-                if(mfu_lseek(dest, out_fd, (off_t)bytes_to_write - 1, SEEK_CUR) == (off_t)-1) {
+                if(mfu_file_lseek(dest, mfu_dst_file, (off_t)bytes_to_write - 1, SEEK_CUR) == (off_t)-1) {
                     MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
                         dest, errno, strerror(errno));
                     return -1;
                 }
 
                 /* write out a single byte */
-                mfu_write(dest, out_fd, buf, 1);
+                mfu_file_write(dest, buf, 1, mfu_dst_file);
             } else {
                 /* this section of the destination file is all 0,
                  * seek past this section */
-                if(mfu_lseek(dest, out_fd, (off_t)bytes_to_write, SEEK_CUR) == (off_t)-1) {
+                if(mfu_file_lseek(dest, mfu_dst_file, (off_t)bytes_to_write, SEEK_CUR) == (off_t)-1) {
                     MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
                         dest, errno, strerror(errno));
                     return -1;
@@ -1663,7 +1717,7 @@ static int mfu_copy_file_normal(
             }
         } else {
             /* write bytes to destination file */
-            num_of_bytes_written = mfu_write(dest, out_fd, buf, bytes_to_write);
+            num_of_bytes_written = mfu_file_write(dest, buf, bytes_to_write, mfu_dst_file);
         }
 
         /* check for an error */
@@ -1680,8 +1734,6 @@ static int mfu_copy_file_normal(
             return -1;
         }
 
-        /* add bytes to our total (use bytes read,
-         * which may be less than number written) */
         total_bytes += (size_t) num_of_bytes_read;
 
         /* update number of bytes we have copied for progress messages */
@@ -1713,28 +1765,34 @@ static int mfu_copy_file_normal(
         /* Use ftruncate() here rather than truncate(), because grouplock
          * of Lustre would cause block to truncate() since the fd is different
          * from the out_fd. */
-        if(mfu_ftruncate(out_fd, file_size_offt) < 0) {
+        if(mfu_file_ftruncate(mfu_dst_file, file_size_offt) < 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to truncate destination file: %s (errno=%d %s)",
                 dest, errno, strerror(errno));
             return -1;
-       }
+        }
     }
 
     /* we don't bother closing the file because our cache does it for us */
 
+#ifdef DAOS_SUPPORT
+    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
+        D_FREE(buf);
+    }
+#endif
+
     return 0;
 }
 
 static int mfu_copy_file_fiemap(
     const char* src,
     const char* dest,
-    const int in_fd,
-    const int out_fd,
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
     bool* normal_copy_required,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     *normal_copy_required = true;
     if (mfu_copy_opts->synchronous) {
@@ -1758,11 +1816,11 @@ static int mfu_copy_file_fiemap(
     fiemap->fm_mapped_extents = 0;
 
     struct stat sb;
-    if (fstat(in_fd, &sb) < 0) {
+    if (fstat(mfu_src_file->fd, &sb) < 0) {
         goto fail_normal_copy;
     }
 
-    if (ioctl(in_fd, FS_IOC_FIEMAP, fiemap) < 0) {
+    if (ioctl(mfu_src_file->fd, FS_IOC_FIEMAP, fiemap) < 0) {
         MFU_LOG(MFU_LOG_ERR, "fiemap ioctl() failed for src `%s'", src);
         goto fail_normal_copy;
     }
@@ -1780,7 +1838,7 @@ static int mfu_copy_file_fiemap(
     fiemap->fm_extent_count   = fiemap->fm_mapped_extents;
     fiemap->fm_mapped_extents = 0;
 
-    if (ioctl(in_fd, FS_IOC_FIEMAP, fiemap) < 0) {
+    if (ioctl(mfu_src_file->fd, FS_IOC_FIEMAP, fiemap) < 0) {
         MFU_LOG(MFU_LOG_ERR, "fiemap ioctl() failed for src `%s'", src);
         goto fail_normal_copy;
     }
@@ -1806,14 +1864,14 @@ static int mfu_copy_file_fiemap(
     *normal_copy_required = false;
 
     /* seek to offset in source file */
-    if (mfu_lseek(src, in_fd, (off_t)last_ext_start, SEEK_SET) < 0) {
+    if (mfu_file_lseek(src, mfu_src_file, (off_t)last_ext_start, SEEK_SET) < 0) {
         MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)",
             src, errno, strerror(errno));
         goto fail;
     }
 
     /* seek to offset in destination file */
-    if (mfu_lseek(dest, out_fd, (off_t)last_ext_start, SEEK_SET) < 0) {
+    if (mfu_file_lseek(dest, mfu_dst_file, (off_t)last_ext_start, SEEK_SET) < 0) {
         MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
             dest, errno, strerror(errno));
         goto fail;
@@ -1833,12 +1891,12 @@ static int mfu_copy_file_fiemap(
         ext_hole_size = ext_start - (last_ext_start + last_ext_len);
 
         if (ext_hole_size) {
-            if (mfu_lseek(src, in_fd, (off_t)ext_start, SEEK_SET) < 0) {
+            if (mfu_file_lseek(src, mfu_src_file, (off_t)ext_start, SEEK_SET) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)",
                     src, errno, strerror(errno));
                 goto fail;
             }
-            if (mfu_lseek(dest, out_fd, (off_t)ext_hole_size, SEEK_CUR) < 0) {
+            if (mfu_file_lseek(dest, mfu_dst_file, (off_t)ext_hole_size, SEEK_CUR) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
                     dest, errno, strerror(errno));
                 goto fail;
@@ -1849,12 +1907,11 @@ static int mfu_copy_file_fiemap(
         last_ext_len = ext_len;
 
         while (ext_len) {
-            ssize_t num_read = mfu_read(src, in_fd, buf, MIN(ext_len, buf_size));
+            ssize_t num_read = mfu_file_read(src, buf, MIN(ext_len, buf_size), mfu_src_file);
 
             if (!num_read)
                 break;
-
-            ssize_t num_written = mfu_write(dest, out_fd, buf, (size_t)num_read);
+            ssize_t num_written = mfu_file_write(dest, buf, (size_t)num_read, mfu_dst_file);
 
             if (num_written < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s' (errno=%d %s)",
@@ -1878,7 +1935,7 @@ static int mfu_copy_file_fiemap(
         /* Use ftruncate() here rather than truncate(), because grouplock
          * of Lustre would cause block to truncate() since the fd is different
          * from the out_fd. */
-        if (mfu_ftruncate(out_fd, file_size_offt) < 0) {
+        if (mfu_file_ftruncate(mfu_dst_file, file_size_offt) < 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to truncate destination file: %s (errno=%d %s)",
                 dest, errno, strerror(errno));
             goto fail;
@@ -1907,38 +1964,42 @@ static int mfu_copy_file(
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     int ret;
     bool normal_copy_required;
 
+    
     /* open the input file */
-    int in_fd = mfu_copy_open_file(src, 1, &mfu_copy_src_cache, mfu_copy_opts);
-    if (in_fd < 0) {
+    mfu_copy_open_file(src, 1, &mfu_copy_src_cache,
+                       mfu_copy_opts, mfu_src_file);
+    if (mfu_src_file->fd < 0 && mfu_src_file->type != DAOS) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open input file `%s' (errno=%d %s)",
             src, errno, strerror(errno));
         return -1;
     }
 
     /* open the output file */
-    int out_fd = mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, mfu_copy_opts);
-    if (out_fd < 0) {
-        MFU_LOG(MFU_LOG_ERR, "Failed to open output file `%s' (errno=%d %s)",
-            dest, errno, strerror(errno));
+    mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache,
+                       mfu_copy_opts, mfu_dst_file);
+    if (mfu_dst_file->fd < 0 && mfu_dst_file->type != DAOS) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to open output file `%s' (errno=%d %s)", dest, errno, strerror(errno));
         return -1;
     }
 
     if (mfu_copy_opts->sparse) {
-        ret = mfu_copy_file_fiemap(src, dest, in_fd, out_fd, offset,
-                               length, file_size,
-                               &normal_copy_required, mfu_copy_opts);
+        ret = mfu_copy_file_fiemap(src, dest, offset, length, file_size,
+                               &normal_copy_required, mfu_copy_opts,
+                               mfu_src_file, mfu_dst_file);
         if (!ret || !normal_copy_required) {
             return ret;
         }
     }
 
-    ret = mfu_copy_file_normal(src, dest, in_fd, out_fd,
-            offset, length, file_size, mfu_copy_opts);
+    ret = mfu_copy_file_normal(src, dest, offset, length, file_size,
+                               mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
     return ret;
 }
@@ -1947,8 +2008,8 @@ static int mfu_copy_file(
  * chunks, and copies data from source to destination file,
  * returns 0 on success and -1 on error */
 static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts)
+        int numpaths, const mfu_param_path* paths, const mfu_param_path* destpath,
+        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1998,7 +2059,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
 
         /* get name of destination file */
         char* dest = mfu_param_path_copy_dest(p->name, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
         if (dest == NULL) {
             /* No need to copy it */
             p = p->next;
@@ -2011,7 +2072,8 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
         /* copy portion of file corresponding to this chunk,
          * and record whether copy operation succeeded */
         int copy_rc = mfu_copy_file(p->name, dest, (uint64_t)p->offset,
-                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts);
+                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts,
+                mfu_src_file, mfu_dst_file);
         if (copy_rc < 0) {
             /* error copying file */
             vals[i] = 1;
@@ -2025,8 +2087,8 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
     }
 
     /* close files */
-    mfu_copy_close_file(&mfu_copy_src_cache);
-    mfu_copy_close_file(&mfu_copy_dst_cache);
+    mfu_copy_close_file(&mfu_copy_src_cache, mfu_src_file);
+    mfu_copy_close_file(&mfu_copy_dst_cache, mfu_dst_file);
 
     /* barrier to ensure all files are closed,
      * may try to unlink bad destination files below */
@@ -2052,7 +2114,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
              * compute destination name and delete it */
             const char* name = mfu_flist_file_get_name(list, i);
             const char* dest = mfu_param_path_copy_dest(name, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
             if (dest != NULL) {
                 /* sanity check to ensure we don't * delete the source file */
                 if (strcmp(dest, name) != 0) {
@@ -2245,11 +2307,18 @@ static void print_summary(mfu_flist flist)
 
 int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
         const mfu_param_path* paths, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts)
+        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
 
+    /* DAOS only supports using one source path */
+    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
+        if (numpaths != 1) {
+            MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
+        }
+    }
+
     /* get our rank */
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
@@ -2268,6 +2337,9 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
     /* TODO: consider file system striping params here */
     /* hard code some configurables for now */
 
+    /* Set default block size */
+    mfu_copy_opts->block_size = FD_BLOCK_SIZE;
+
     /* allocate buffer to read/write files, aligned on 1MB boundaraies */
     size_t alignment = 1024*1024;
     mfu_copy_opts->block_buf1 = (char*) MFU_MEMALIGN(mfu_copy_opts->block_size, alignment);
@@ -2298,7 +2370,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
     /* create directories, from top down */
     int tmp_rc = mfu_create_directories(levels, minlevel, lists, numpaths,
-            paths, destpath, mfu_copy_opts);
+            paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
@@ -2361,14 +2433,14 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
                 /* create files and links */
                 tmp_rc = mfu_create_files(levels2, minlevel2, lists2, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
 
                 /* copy data */
                 tmp_rc = mfu_copy_files(spreadlist, mfu_copy_opts->chunk_size,
-                        numpaths, paths, destpath, mfu_copy_opts);
+                        numpaths, paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -2379,7 +2451,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
                 /* set permissions, ownership, and timestamps if needed */
                 mfu_copy_set_metadata(levels2, minlevel2, lists2, numpaths,
-                        paths, destpath, mfu_copy_opts);
+                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
                 /* free our lists of levels */
                 mfu_flist_array_free(levels2, &lists2);
@@ -2466,7 +2538,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* set permissions, ownership, and timestamps if needed */
         mfu_copy_set_metadata_dirs(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
         /* force updates to disk */
         mfu_sync_all("Syncing directory updates to disk.");
@@ -2475,14 +2547,14 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* create files and links */
         tmp_rc = mfu_create_files(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
 
         /* copy data */
         tmp_rc = mfu_copy_files(src_cp_list, mfu_copy_opts->chunk_size,
-                numpaths, paths, destpath, mfu_copy_opts);
+                numpaths, paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -2493,7 +2565,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* set permissions, ownership, and timestamps if needed */
         mfu_copy_set_metadata(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts);
+                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
         /* force updates to disk */
         mfu_sync_all("Syncing directory updates to disk.");
@@ -2642,12 +2714,14 @@ static int mfu_fill_file(
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts)
+    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_file_t* mfu_file)
 {
     int ret;
 
     /* open the file */
-    int out_fd = mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, mfu_copy_opts);
+    mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, mfu_copy_opts, mfu_file);
+    int out_fd = mfu_file->fd; 
     if (out_fd < 0) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open output file `%s' (errno=%d %s)",
             dest, errno, strerror(errno));
@@ -2715,7 +2789,6 @@ static int mfu_fill_file(
     /* Increment the global counter. */
     //mfu_copy_stats.total_size += (int64_t) total_bytes;
     //mfu_copy_stats.total_bytes_copied += (int64_t) total_bytes;
-
 #if 0
     /* force data to file system */
     if(total_bytes > 0) {
@@ -2742,7 +2815,7 @@ static int mfu_fill_file(
     return ret;
 }
 
-int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
+int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_file)
 {
     int rc = MFU_SUCCESS;
 
@@ -2807,7 +2880,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
         /* copy portion of file corresponding to this chunk,
          * and record whether copy operation succeeded */
         int copy_rc = mfu_fill_file(p->name, (uint64_t)p->offset,
-                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts);
+                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts, mfu_file);
         if (copy_rc < 0) {
             /* error copying file */
             vals[i] = 1;
@@ -2818,7 +2891,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
     }
 
     /* close files */
-    mfu_copy_close_file(&mfu_copy_dst_cache);
+    mfu_copy_close_file(&mfu_copy_dst_cache, mfu_file);
 
     /* barrier to ensure all files are closed,
      * may try to unlink bad destination files below */
@@ -2893,7 +2966,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
     }
 
     /* force data to backend to avoid the following metadata
-      * setting mismatch, which may happen on lustre */
+     * setting mismatch, which may happen on lustre */
      mfu_sync_all("Syncing data to disk.");
 
     /* determine whether any process reported an error,
@@ -2901,13 +2974,12 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts)
     int all_rc;
     MPI_Allreduce(&rc, &all_rc, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD);
     rc = all_rc;
-
     return rc;
 }
 
 int mfu_flist_hardlink(mfu_flist src_link_list,
         const mfu_param_path* srcpath, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts)
+        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -2952,7 +3024,7 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
 
     /* create directories, from top down */
     int tmp_rc = mfu_create_directories(levels, minlevel, lists, 1,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
@@ -2964,14 +3036,14 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
      * has better idea for it. */
     /* create hard links */
     tmp_rc = mfu_create_hardlinks(levels, minlevel, lists,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
 
     /* set permissions, ownership, and timestamps if needed */
     mfu_copy_set_metadata(levels, minlevel, lists, 1,
-            srcpath, destpath, mfu_copy_opts);
+            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
 
     /* force updates to disk */
     mfu_sync_all("Syncing directory updates to disk.");
@@ -3037,7 +3109,9 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
     return rc;
 }
 
-int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist dst_list, uint64_t dst_index)
+int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index,
+                             mfu_flist dst_list, uint64_t dst_index,
+                             mfu_file_t* mfu_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -3065,19 +3139,13 @@ int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist d
     mode_t src_mode = (mode_t) mfu_flist_file_get_mode(src_list, src_index);
     mode_t dst_mode = (mode_t) mfu_flist_file_get_mode(dst_list, dst_index);
     if (src_mode != dst_mode) {
-        tmp_rc = mfu_copy_permissions(src_list, src_index, dest_path);
+        tmp_rc = mfu_copy_permissions(src_list, src_index, dest_path, mfu_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
     }
 
     /* TODO: test ACLs and update if different */
-    /* 
-    tmp_rc = mfu_copy_acls(src_list, src_index, dest_path);
-    if (tmp_rc < 0) {
-        rc = -1;
-    }
-    */
 
     /* get atime seconds and nsecs */
     uint64_t src_atime      = mfu_flist_file_get_atime(src_list, src_index);
@@ -3104,6 +3172,28 @@ int mfu_flist_file_sync_meta(mfu_flist src_list, uint64_t src_index, mfu_flist d
     return rc;
 }
 
+/* return a newly allocated mfu_file structure, set default values on its fields */
+mfu_file_t* mfu_file_new(void)
+{
+    mfu_file_t* mfile = (mfu_file_t*) MFU_MALLOC(sizeof(mfu_file_t));
+    mfile->type       = POSIX;
+    mfile->fd         = -1;
+    mfile->only_daos  = false;
+#ifdef DAOS_SUPPORT
+    mfile->obj        = NULL;
+    mfile->dfs        = NULL;
+#endif
+    return mfile;
+}
+
+void mfu_file_delete(mfu_file_t** pfile)
+{
+  if (pfile != NULL) {
+    mfu_file_t* mfile = *pfile;
+    mfu_free(pfile);
+  }
+}
+
 /* return a newly allocated copy_opts structure, set default values on its fields */
 mfu_copy_opts_t* mfu_copy_opts_new(void)
 {
diff --git a/src/common/mfu_flist_walk.c b/src/common/mfu_flist_walk.c
index 264bf2a7..c068f295 100644
--- a/src/common/mfu_flist_walk.c
+++ b/src/common/mfu_flist_walk.c
@@ -50,6 +50,7 @@ static const char** CURRENT_DIRS;
 static flist_t* CURRENT_LIST;
 static int SET_DIR_PERMS;
 static int REMOVE_FILES;
+static mfu_file_t** CURRENT_PFILE;
 
 /****************************************
  * Global counter and callbacks for LIBCIRCLE reductions
@@ -152,8 +153,9 @@ static void walk_getdents_process_dir(const char* dir, CIRCLE_handle* handle)
     char buf[BUF_SIZE];
 
     /* TODO: may need to try these functions multiple times */
-    int fd = mfu_open(dir, O_RDONLY | O_DIRECTORY);
-    if (fd == -1) {
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
+    mfu_file_open(dir, O_RDONLY | O_DIRECTORY, mfu_file);
+    if (mfu_file->fd == -1) {
         /* print error */
         MFU_LOG(MFU_LOG_ERR, "Failed to open directory for reading: `%s' (errno=%d %s)", dir, errno, strerror(errno));
         return;
@@ -162,7 +164,7 @@ static void walk_getdents_process_dir(const char* dir, CIRCLE_handle* handle)
     /* Read all directory entries */
     while (1) {
         /* execute system call to get block of directory entries */
-        int nread = syscall(SYS_getdents, fd, buf, (int) BUF_SIZE);
+        int nread = syscall(SYS_getdents, mfu_file->fd, buf, (int) BUF_SIZE);
         if (nread == -1) {
             MFU_LOG(MFU_LOG_ERR, "syscall to getdents failed when reading `%s' (errno=%d %s)", dir, errno, strerror(errno));
             break;
@@ -243,7 +245,7 @@ static void walk_getdents_process_dir(const char* dir, CIRCLE_handle* handle)
         }
     }
 
-    mfu_close(dir, fd);
+    mfu_file_close(dir, mfu_file);
 
     return;
 }
@@ -257,7 +259,8 @@ static void walk_getdents_create(CIRCLE_handle* handle)
 
         /* stat top level item */
         struct stat st;
-        int status = mfu_lstat(path, &st);
+        mfu_file_t* mfu_file = *CURRENT_PFILE;
+        int status = mfu_file_lstat(path, &st, mfu_file);
         if (status != 0) {
             /* TODO: print error */
             return;
@@ -296,19 +299,21 @@ static void walk_getdents_process(CIRCLE_handle* handle)
 static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
 {
     /* TODO: may need to try these functions multiple times */
-    DIR* dirp = mfu_opendir(dir);
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
+    DIR* dirp = mfu_file_opendir(dir, mfu_file);
 
     /* if there is a permissions error and the usr read & execute are being turned
      * on when walk_stat=0 then catch the permissions error and turn the bits on */
     if (dirp == NULL) {
         if (errno == EACCES && SET_DIR_PERMS) {
             struct stat st;
-            mfu_lstat(dir, &st);
+            mfu_file_t* mfu_file = *CURRENT_PFILE;
+            int status = mfu_file_lstat(dir, &st, mfu_file);
             // turn on the usr read & execute bits
             st.st_mode |= S_IRUSR;
             st.st_mode |= S_IXUSR;
-            mfu_chmod(dir, st.st_mode);
-            dirp = mfu_opendir(dir);
+            mfu_file_chmod(dir, st.st_mode, mfu_file);
+            dirp = mfu_file_opendir(dir, mfu_file);
             if (dirp == NULL) {
                 if (errno == EACCES) {
                     MFU_LOG(MFU_LOG_ERR, "Failed to open directory with opendir: `%s' (errno=%d %s)", dir, errno, strerror(errno));
@@ -324,7 +329,7 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
         /* Read all directory entries */
         while (1) {
             /* read next directory entry */
-            struct dirent* entry = mfu_readdir(dirp);
+            struct dirent* entry = mfu_file_readdir(dirp, mfu_file);
             if (entry == NULL) {
                 break;
             }
@@ -360,7 +365,7 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
                     else {
                         /* type is unknown, we need to stat it */
                         struct stat st;
-                        int status = mfu_lstat(newpath, &st);
+                        int status = mfu_file_lstat(newpath, &st, mfu_file);
                         if (status == 0) {
                             have_mode = 1;
                             mode = st.st_mode;
@@ -395,7 +400,7 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
         }
     }
 
-    mfu_closedir(dirp);
+    mfu_file_closedir(dirp, mfu_file);
 
     return;
 }
@@ -409,7 +414,8 @@ static void walk_readdir_create(CIRCLE_handle* handle)
 
         /* stat top level item */
         struct stat st;
-        int status = mfu_lstat(path, &st);
+        mfu_file_t* mfu_file = *CURRENT_PFILE;
+        int status = mfu_file_lstat(path, &st, mfu_file);
         if (status != 0) {
             /* TODO: print error */
             return;
@@ -448,7 +454,8 @@ static void walk_readdir_process(CIRCLE_handle* handle)
 static void walk_stat_process_dir(char* dir, CIRCLE_handle* handle)
 {
     /* TODO: may need to try these functions multiple times */
-    DIR* dirp = mfu_opendir(dir);
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
+    DIR* dirp = mfu_file_opendir(dir, mfu_file);
 
     if (! dirp) {
         /* TODO: print error */
@@ -456,7 +463,7 @@ static void walk_stat_process_dir(char* dir, CIRCLE_handle* handle)
     else {
         while (1) {
             /* read next directory entry */
-            struct dirent* entry = mfu_readdir(dirp);
+            struct dirent* entry = mfu_file_readdir(dirp, mfu_file);
             if (entry == NULL) {
                 break;
             }
@@ -483,9 +490,7 @@ static void walk_stat_process_dir(char* dir, CIRCLE_handle* handle)
             }
         }
     }
-
-    mfu_closedir(dirp);
-
+    mfu_file_closedir(dirp, mfu_file);
     return;
 }
 
@@ -506,10 +511,11 @@ static void walk_stat_process(CIRCLE_handle* handle)
     /* get path from queue */
     char path[CIRCLE_MAX_STRING_LEN];
     handle->dequeue(path);
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
 
     /* stat item */
     struct stat st;
-    int status = mfu_lstat(path, &st);
+    int status = mfu_file_lstat(path, &st, mfu_file);
     if (status != 0) {
         /* print error */
         return;
@@ -539,28 +545,29 @@ static void walk_stat_process(CIRCLE_handle* handle)
             if (!((usr_r_mask & st.st_mode) && (usr_x_mask & st.st_mode))) {
                 st.st_mode |= S_IRUSR;
                 st.st_mode |= S_IXUSR;
-                mfu_chmod(path, st.st_mode);
+                mfu_file_chmod(path, st.st_mode, mfu_file);
             }
         }
-
         /* TODO: check that we can recurse into directory */
         walk_stat_process_dir(path, handle);
     }
-
     return;
 }
 
 /* Set up and execute directory walk */
-void mfu_flist_walk_path(const char* dirpath, mfu_walk_opts_t* walk_opts,
-                         mfu_flist bflist)
+void mfu_flist_walk_path(const char* dirpath,
+                         mfu_walk_opts_t* walk_opts,
+                         mfu_flist bflist,
+                         mfu_file_t* mfu_file)
 {
-    mfu_flist_walk_paths(1, &dirpath, walk_opts, bflist);
+    mfu_flist_walk_paths(1, &dirpath, walk_opts, bflist, mfu_file);
     return;
 }
 
 /* Set up and execute directory walk */
 void mfu_flist_walk_paths(uint64_t num_paths, const char** paths,
-                          mfu_walk_opts_t* walk_opts, mfu_flist bflist)
+                          mfu_walk_opts_t* walk_opts, mfu_flist bflist,
+                          mfu_file_t* mfu_file)
 {
     /* report walk count, time, and rate */
     double start_walk = MPI_Wtime();
@@ -622,6 +629,7 @@ void mfu_flist_walk_paths(uint64_t num_paths, const char** paths,
     }
 
     /* register callbacks */
+    CURRENT_PFILE = &mfu_file;
     if (walk_opts->use_stat) {
         /* walk directories by calling stat on every item */
         CIRCLE_cb_create(&walk_stat_create);
@@ -681,11 +689,19 @@ void mfu_flist_walk_paths(uint64_t num_paths, const char** paths,
 void mfu_flist_walk_param_paths(uint64_t num,
                                 const mfu_param_path* params,
                                 mfu_walk_opts_t* walk_opts,
-                                mfu_flist flist)
+                                mfu_flist flist,
+                                mfu_file_t* mfu_file)
 {
     /* allocate memory to hold a list of paths */
     const char** path_list = (const char**) MFU_MALLOC(num * sizeof(char*));
 
+    /* DAOS only supports using one source path */
+    if (mfu_file->type == DAOS) {
+        if (num != 1) {
+            MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
+        }
+    }
+
     /* fill list of paths and print each one */
     uint64_t i;
     for (i = 0; i < num; i++) {
@@ -694,7 +710,7 @@ void mfu_flist_walk_param_paths(uint64_t num,
     }
 
     /* walk file tree and record stat data for each file */
-    mfu_flist_walk_paths((uint64_t) num, path_list, walk_opts, flist);
+    mfu_flist_walk_paths((uint64_t) num, path_list, walk_opts, flist, mfu_file);
 
     /* free the list */
     mfu_free(&path_list);
@@ -729,6 +745,7 @@ void mfu_flist_stat(
     /* step through each item in input list and stat it */
     uint64_t idx;
     uint64_t size = mfu_flist_size(input_flist);
+    mfu_file_t* mfu_file = *CURRENT_PFILE;
     for (idx = 0; idx < size; idx++) {
         /* get name of item */
         const char* name = mfu_flist_file_get_name(input_flist, idx);
@@ -742,7 +759,7 @@ void mfu_flist_stat(
 
         /* stat the item */
         struct stat st;
-        int status = mfu_lstat(name, &st);
+        int status = mfu_file_lstat(name, &st, mfu_file);
         if (status != 0) {
             MFU_LOG(MFU_LOG_ERR, "mfu_lstat() failed: `%s' rc=%d (errno=%d %s)", name, status, errno, strerror(errno));
             continue;
diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 0ec97dae..ad730ee8 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -9,13 +9,204 @@
 #include <string.h>
 #include <errno.h>
 #include <stdarg.h>
+#include <assert.h>
+#include <libgen.h>
+
+#ifdef DAOS_SUPPORT
+#include <gurt/common.h>
+#include <gurt/hash.h>
+#endif
 
 #include "mfu.h"
 
 #define MFU_IO_TRIES  (5)
 #define MFU_IO_USLEEP (100)
 
+static int mpi_rank;
+
+#ifdef DAOS_SUPPORT
+struct d_hash_table *dir_hash;
+
+struct mfu_dir_hdl {
+        d_list_t	entry;
+        dfs_obj_t	*oh;
+        char		name[PATH_MAX];
+};
+
+static inline struct mfu_dir_hdl* hdl_obj(d_list_t *rlink)
+{
+        return container_of(rlink, struct mfu_dir_hdl, entry);
+}
+
+static bool key_cmp(struct d_hash_table *htable, d_list_t *rlink,
+	const void *key, unsigned int ksize)
+{
+        struct mfu_dir_hdl *hdl = hdl_obj(rlink);
+
+        return (strcmp(hdl->name, (const char *)key) == 0);
+}
+
+static void rec_free(struct d_hash_table *htable, d_list_t *rlink)
+{
+        struct mfu_dir_hdl *hdl = hdl_obj(rlink);
+
+        assert(d_hash_rec_unlinked(&hdl->entry));
+        dfs_release(hdl->oh);
+        free(hdl);
+}
+
+static d_hash_table_ops_t hdl_hash_ops = {
+        .hop_key_cmp	= key_cmp,
+        .hop_rec_free	= rec_free
+};
+
+static dfs_obj_t* lookup_insert_dir(const char *name, mfu_file_t* mfu_file)
+{
+        struct mfu_dir_hdl *hdl;
+        d_list_t *rlink;
+        int rc;
+
+	if (dir_hash == NULL) {
+	    rc = d_hash_table_create(0, 16, NULL, &hdl_hash_ops, &dir_hash);
+	    if (rc) {
+		    fprintf(stderr, "Failed to initialize dir hashtable");
+		    return NULL;
+	    }
+	}
+
+        rlink = d_hash_rec_find(dir_hash, name, strlen(name));
+        if (rlink != NULL) {
+                hdl = hdl_obj(rlink);
+                return hdl->oh;
+        }
+
+        hdl = calloc(1, sizeof(struct mfu_dir_hdl));
+        if (hdl == NULL)
+		return NULL;
+
+        strncpy(hdl->name, name, PATH_MAX-1);
+        hdl->name[PATH_MAX-1] = '\0';
+
+        rc = dfs_lookup(mfu_file->dfs, name, O_RDWR, &hdl->oh, NULL, NULL);
+	if (rc) {
+		fprintf(stderr, "dfs_lookup() of %s Failed", name);
+		return NULL;
+	}
+
+        rc = d_hash_rec_insert(dir_hash, hdl->name, strlen(hdl->name),
+                               &hdl->entry, true);
+	if (rc)
+		return NULL;
+
+        return hdl->oh;
+}
+
+static int parse_filename(const char* path, char** _obj_name, char** _cont_name)
+{
+	char *f1 = NULL;
+	char *f2 = NULL;
+	char *fname = NULL;
+	char *cont_name = NULL;
+	int rc = 0;
+
+	if (path == NULL || _obj_name == NULL || _cont_name == NULL)
+		return -EINVAL;
+
+	if (strcmp(path, "/") == 0) {
+		*_cont_name = strdup("/");
+		if (*_cont_name == NULL)
+			return -ENOMEM;
+		*_obj_name = NULL;
+		return 0;
+	}
+
+	f1 = strdup(path);
+	if (f1 == NULL) {
+                rc = -ENOMEM;
+                goto out;
+        }
+
+	f2 = strdup(path);
+	if (f2 == NULL) {
+                rc = -ENOMEM;
+                goto out;
+        }
+
+	fname = basename(f1);
+	cont_name = dirname(f2);
+
+	if (cont_name[0] == '.' || cont_name[0] != '/') {
+		char cwd[1024];
+
+		if (getcwd(cwd, 1024) == NULL) {
+                        rc = -ENOMEM;
+                        goto out;
+                }
+
+		if (strcmp(cont_name, ".") == 0) {
+			cont_name = strdup(cwd);
+			if (cont_name == NULL) {
+                                rc = -ENOMEM;
+                                goto out;
+                        }
+		} else {
+			char *new_dir = calloc(strlen(cwd) + strlen(cont_name)
+					       + 1, sizeof(char));
+			if (new_dir == NULL) {
+                                rc = -ENOMEM;
+                                goto out;
+                        }
+
+			strcpy(new_dir, cwd);
+			if (cont_name[0] == '.') {
+				strcat(new_dir, &cont_name[1]);
+			} else {
+				strcat(new_dir, "/");
+				strcat(new_dir, cont_name);
+			}
+			cont_name = new_dir;
+		}
+		*_cont_name = cont_name;
+	} else {
+		*_cont_name = strdup(cont_name);
+		if (*_cont_name == NULL) {
+                        rc = -ENOMEM;
+                        goto out;
+                }
+	}
+
+	*_obj_name = strdup(fname);
+	if (*_obj_name == NULL) {
+		free(*_cont_name);
+		*_cont_name = NULL;
+                rc = -ENOMEM;
+                goto out;
+	}
+
+out:
+	if (f1)
+		free(f1);
+	if (f2)
+		free(f2);
+	return rc;
+}
+#endif
+
 /* calls access, and retries a few times if we get EIO or EINTR */
+int mfu_file_access(const char* path, int amode, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_access(path, amode);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_access(path, amode);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 int mfu_access(const char* path, int amode)
 {
     int rc;
@@ -36,6 +227,14 @@ int mfu_access(const char* path, int amode)
     return rc;
 }
 
+int daos_access(const char* path, int amode)
+{
+#ifdef DAOS_SUPPORT
+    /* noop becuase daos have an access call */
+    return 0;
+#endif
+}
+
 /* calls lchown, and retries a few times if we get EIO or EINTR */
 int mfu_lchown(const char* path, uid_t owner, gid_t group)
 {
@@ -57,7 +256,33 @@ int mfu_lchown(const char* path, uid_t owner, gid_t group)
     return rc;
 }
 
-/* calls chmod, and retries a few times if we get EIO or EINTR */
+int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    dfs_obj_t *parent = NULL;
+    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    if (parent != NULL) {
+        rc = dfs_chmod(mfu_file->dfs, parent, name, mode);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_chmod %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        }
+    } else {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+        errno = ENOENT;
+        rc = -1;
+    }
+    return rc;
+#endif
+}
+
 int mfu_chmod(const char* path, mode_t mode)
 {
     int rc;
@@ -78,6 +303,21 @@ int mfu_chmod(const char* path, mode_t mode)
     return rc;
 }
 
+/* calls chmod, and retries a few times if we get EIO or EINTR */
+int mfu_file_chmod(const char* path, mode_t mode, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_chmod(path, mode);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_chmod(path, mode, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 /* calls utimensat, and retries a few times if we get EIO or EINTR */
 int mfu_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags)
 {
@@ -99,9 +339,37 @@ int mfu_utimensat(int dirfd, const char *pathname, const struct timespec times[2
     return rc;
 }
 
-/* calls lstat, and retries a few times if we get EIO or EINTR */
-int mfu_lstat(const char* path, struct stat* buf)
-{
+int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file) {
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    dfs_obj_t *parent = NULL;
+    int rc;
+    if (mfu_file->only_daos) {
+        rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+            errno = ENOENT;
+            rc = -1;
+        }
+    } else {
+        parent = lookup_insert_dir(dir_name, mfu_file);
+    }
+    rc = dfs_stat(mfu_file->dfs, parent, name, buf);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_stat %s failed (%d %s)",
+                name, rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    return rc;
+#endif
+}
+
+int mfu_lstat(const char* path, struct stat* buf) {
     int rc;
     int tries = MFU_IO_TRIES;
 retry:
@@ -120,6 +388,21 @@ int mfu_lstat(const char* path, struct stat* buf)
     return rc;
 }
 
+/* calls lstat, and retries a few times if we get EIO or EINTR */
+int mfu_file_lstat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_lstat(path, buf);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_stat(path, buf, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 /* calls lstat64, and retries a few times if we get EIO or EINTR */
 int mfu_lstat64(const char* path, struct stat64* buf)
 {
@@ -141,7 +424,12 @@ int mfu_lstat64(const char* path, struct stat64* buf)
     return rc;
 }
 
-/* call mknod, retry a few times on EINTR or EIO */
+/* use a noop, daos does not have a mknod function */
+int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
+{
+    return 0;
+}
+
 int mfu_mknod(const char* path, mode_t mode, dev_t dev)
 {
     int rc;
@@ -162,6 +450,21 @@ int mfu_mknod(const char* path, mode_t mode, dev_t dev)
     return rc;
 }
 
+/* call mknod, retry a few times on EINTR or EIO */
+int mfu_file_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_mknod(path, mode, dev);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_mknod(path, mode, dev, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  path, mfu_file->type);
+    }
+}
+
 /* call remove, retry a few times on EINTR or EIO */
 int mfu_remove(const char* path)
 {
@@ -253,6 +556,33 @@ int mfu_hardlink(const char* oldpath, const char* newpath)
 /*****************************
  * Files
  ****************************/
+void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(file, &name, &dir_name);
+    assert(dir_name);
+
+    dfs_obj_t *parent = NULL;
+    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    if (parent != NULL) {
+        rc = dfs_open(mfu_file->dfs, parent, name,
+                      S_IFREG | mode, flags,
+                      0, 0, NULL, &(mfu_file->obj));
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_open %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        }
+    } else {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+        errno = ENOENT;
+        rc = -1;
+    }
+#endif
+}
 
 /* open file with specified flags and mode, retry open a few times on failure */
 int mfu_open(const char* file, int flags, ...)
@@ -297,13 +627,54 @@ int mfu_open(const char* file, int flags, ...)
             tries--;
         }
 
-        /* if we still don't have a valid file, consider it an error */
-        if (fd < 0) {
-            /* we could abort, but probably don't want to here */
+         /* if we still don't have a valid file, consider it an error */
+         if (fd < 0) {
+             /* we could abort, but probably don't want to here */
+         }
+    }
+    return fd;
+}
+
+void mfu_file_open(const char* file, int flags, mfu_file_t* mfu_file, ...)
+{
+    /* extract the mode (see man 2 open) */
+    int mode_set = 0;
+    mode_t mode  = 0;
+    if (flags & O_CREAT) {
+        va_list ap;
+        va_start(ap, mfu_file);
+        mode = va_arg(ap, mode_t);
+        va_end(ap);
+        mode_set = 1;
+    }
+
+    if (mfu_file->type == POSIX) {
+        if (mode_set) {
+            mfu_file->fd = mfu_open(file, flags, mode);
+        } else {
+            mfu_file->fd = mfu_open(file, flags);
         }
+    } else if (mfu_file->type == DAOS) {
+        daos_open(file, flags, mode, mfu_file);
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
     }
+}
 
-    return fd;
+/* release an open object */
+int daos_close(const char* file, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    int rc = dfs_release(mfu_file->obj);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_close %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    return rc;
+#endif
 }
 
 /* close file */
@@ -326,6 +697,40 @@ int mfu_close(const char* file, int fd)
     return rc;
 }
 
+int mfu_file_close(const char* file, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_close(file, mfu_file->fd);
+        if (rc == 0) {
+            mfu_file->fd = -1;
+        }
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_close(file, mfu_file);
+#ifdef DAOS_SUPPORT
+        if (rc == 0) {
+            mfu_file->obj = NULL;
+        }
+#endif
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
+int daos_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence)
+{
+#ifdef DAOS_SUPPORT
+    if (whence == SEEK_SET) {
+        mfu_file->offset = (daos_off_t)pos;
+    } else {
+        MFU_ABORT(-1, "daos_lseek whence type not known: %d", whence);
+    }
+    return 0;
+#endif
+}
+
 /* seek file descriptor to specified position */
 off_t mfu_lseek(const char* file, int fd, off_t pos, int whence)
 {
@@ -346,7 +751,52 @@ off_t mfu_lseek(const char* file, int fd, off_t pos, int whence)
     return rc;
 }
 
+off_t mfu_file_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence)
+{
+    if (mfu_file->type == POSIX) {
+        off_t rc = mfu_lseek(file, mfu_file->fd, pos, whence);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        off_t rc = daos_lseek(file, mfu_file, pos, whence);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
 /* reliable read from file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t got_size = mfu_read(file, mfu_file->fd, buf, size);
+        return got_size;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t got_size = daos_read(file, buf, size, mfu_file);
+        return got_size;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
+ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    daos_size_t got_size;
+    mfu_file->sgl->sg_iovs[0].iov_len = size;
+    int rc = dfs_read(mfu_file->dfs, mfu_file->obj, mfu_file->sgl, mfu_file->offset, &got_size, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_read %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    mfu_file->offset += (daos_off_t)got_size;
+    return (ssize_t)got_size;
+#endif
+}
+
 ssize_t mfu_read(const char* file, int fd, void* buf, size_t size)
 {
     int tries = MFU_IO_TRIES;
@@ -384,6 +834,20 @@ ssize_t mfu_read(const char* file, int fd, void* buf, size_t size)
 }
 
 /* reliable write to file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t num_bytes_written = mfu_write(file, mfu_file->fd, buf, size);
+        return num_bytes_written;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t num_bytes_written = daos_write(file, buf, size, mfu_file);
+        return num_bytes_written;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  file, mfu_file->type);
+    }
+}
+
 ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size)
 {
     int tries = 10;
@@ -419,6 +883,22 @@ ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size)
     return n;
 }
 
+ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    mfu_file->sgl->sg_iovs[0].iov_len = size;
+    int rc = dfs_write(mfu_file->dfs, mfu_file->obj, mfu_file->sgl, mfu_file->offset, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_write %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    mfu_file->offset += (daos_off_t)size;
+    return (ssize_t)size;
+#endif
+}
+
 /* truncate a file */
 int mfu_truncate(const char* file, off_t length)
 {
@@ -440,7 +920,22 @@ int mfu_truncate(const char* file, off_t length)
     return rc;
 }
 
-/* ftruncate a file */
+/* TODO: need to fix this function for dfs */
+int daos_ftruncate(mfu_file_t* mfu_file, off_t length)
+{
+#ifdef DAOS_SUPPORT
+    daos_off_t offset = (daos_off_t) length;
+    int rc = dfs_punch(mfu_file->dfs, mfu_file->obj, offset, DFS_MAX_FSIZE);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_punch failed (%d)",
+                rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    return rc;
+#endif
+}
+
 int mfu_ftruncate(int fd, off_t length)
 {
     int rc;
@@ -461,6 +956,21 @@ int mfu_ftruncate(int fd, off_t length)
     return rc;
 }
 
+/* ftruncate a file */
+int mfu_file_ftruncate(mfu_file_t* mfu_file, off_t length)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_ftruncate(mfu_file->fd, length);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_ftruncate(mfu_file, length);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
 /* delete a file */
 int mfu_unlink(const char* file)
 {
@@ -519,7 +1029,31 @@ void mfu_getcwd(char* buf, size_t size)
     }
 }
 
-/* create directory, retry a few times on EINTR or EIO */
+int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file) {
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(dir, &name, &dir_name);
+    assert(dir_name);
+
+    /* Need to lookup parent directory in DFS */
+    dfs_obj_t *parent = NULL;
+    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+
+    /* only call mkdir if the dir_name is not the root DFS directory */
+    if (strcmp(dir_name, "/") != 0) {
+        rc = dfs_mkdir(mfu_file->dfs, parent, name, S_IRWXU, 0);
+    }
+
+    if (rc) {
+        errno = rc;
+        rc = -1;
+    }
+
+    return rc;
+#endif
+}
+
 int mfu_mkdir(const char* dir, mode_t mode)
 {
     int rc;
@@ -540,6 +1074,21 @@ int mfu_mkdir(const char* dir, mode_t mode)
     return rc;
 }
 
+/* create directory, retry a few times on EINTR or EIO */
+int mfu_file_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_mkdir(dir, mode);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_mkdir(dir, mode, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  dir, mfu_file->type);
+    }
+}
+
 /* remove directory, retry a few times on EINTR or EIO */
 int mfu_rmdir(const char* dir)
 {
@@ -561,6 +1110,36 @@ int mfu_rmdir(const char* dir)
     return rc;
 }
 
+#define NUM_DIRENTS 24
+
+#ifdef DAOS_SUPPORT
+struct dfs_mfu_t {
+    dfs_obj_t *dir;
+    struct dirent ents[NUM_DIRENTS];
+    daos_anchor_t anchor;
+    int num_ents;
+};
+#endif
+
+DIR* daos_opendir(const char* dir, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    struct dfs_mfu_t* dirp = calloc(1, sizeof(*dirp));
+    if (dirp == NULL) {
+        errno = ENOMEM;
+        return NULL;
+    }
+    int rc = dfs_lookup(mfu_file->dfs, dir, O_RDWR, &dirp->dir, NULL, NULL);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir);
+        errno = ENOENT;
+        free(dirp);
+        return NULL;
+    }
+    return (DIR *)dirp;
+#endif
+}
+
 /* open directory, retry a few times on EINTR or EIO */
 DIR* mfu_opendir(const char* dir)
 {
@@ -582,6 +1161,37 @@ DIR* mfu_opendir(const char* dir)
     return dirp;
 }
 
+/* open directory, retry a few times on EINTR or EIO */
+DIR* mfu_file_opendir(const char* dir, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        DIR* dirp = mfu_opendir(dir);
+        return dirp;
+    } else if (mfu_file->type == DAOS) {
+        DIR* dirp = daos_opendir(dir, mfu_file);
+        return dirp;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+                  dir, mfu_file->type);
+    }
+}
+
+int daos_closedir(DIR* _dirp, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    struct dfs_mfu_t *dirp = (struct dfs_mfu_t *)_dirp;
+    int rc = dfs_release(dirp->dir);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d)",
+                rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    free(dirp);
+    return rc;
+#endif
+}
+
 /* close directory, retry a few times on EINTR or EIO */
 int mfu_closedir(DIR* dirp)
 {
@@ -603,6 +1213,52 @@ int mfu_closedir(DIR* dirp)
     return rc;
 }
 
+int mfu_file_closedir(DIR* dirp, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_closedir(dirp);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_closedir(dirp, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
+
+struct dirent* daos_readdir(DIR* _dirp, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    struct dfs_mfu_t *dirp = (struct dfs_mfu_t *)_dirp;
+    if (dirp->num_ents) {
+        goto ret;
+    }
+    dirp->num_ents = NUM_DIRENTS;
+    int rc;
+    while (!daos_anchor_is_eof(&dirp->anchor)) {
+        rc = dfs_readdir(mfu_file->dfs, dirp->dir,
+                         &dirp->anchor, &dirp->num_ents,
+	                 dirp->ents);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_readdir failed (%d %s)", rc, strerror(rc));
+            dirp->num_ents = 0;
+            errno = ENOENT;
+            return NULL;
+        }
+        if (dirp->num_ents == 0) {
+	    continue;
+        }
+	goto ret;
+    }
+    assert(daos_anchor_is_eof(&dirp->anchor));
+    return NULL;
+ret:
+    dirp->num_ents--;
+    return &dirp->ents[dirp->num_ents];
+#endif
+}
+
 /* read directory entry, retry a few times on ENOENT, EIO, or EINTR */
 struct dirent* mfu_readdir(DIR* dirp)
 {
@@ -624,3 +1280,17 @@ struct dirent* mfu_readdir(DIR* dirp)
     }
     return entry;
 }
+
+struct dirent* mfu_file_readdir(DIR* dirp, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        struct dirent* entry = mfu_readdir(dirp);
+        return entry;
+    } else if (mfu_file->type == DAOS) {
+        struct dirent* entry = daos_readdir(dirp, mfu_file);
+        return entry;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    }
+}
diff --git a/src/common/mfu_io.h b/src/common/mfu_io.h
index cbbf1c18..96543320 100644
--- a/src/common/mfu_io.h
+++ b/src/common/mfu_io.h
@@ -34,6 +34,13 @@ extern "C" {
 #include <fcntl.h>
 #include <dirent.h>
 
+#ifdef DAOS_SUPPORT
+#include <daos.h>
+#include <daos_fs.h>
+#endif
+
+#include "mfu_param_path.h"
+
 /* Intent is to wrap all POSIX I/O routines used by mfu tools.  May
  * abort on fatal conditions to avoid checking condition at every call.
  * May also automatically retry on things like EINTR. */
@@ -47,29 +54,47 @@ struct stat64;
  ****************************/
 
 /* calls access, and retries a few times if we get EIO or EINTR */
+int mfu_file_access(const char* path, int amode, mfu_file_t* mfu_file);
 int mfu_access(const char* path, int amode);
+int daos_access(const char* path, int amode);
 
 /* calls lchown, and retries a few times if we get EIO or EINTR */
 int mfu_lchown(const char* path, uid_t owner, gid_t group);
 
 /* calls chmod, and retries a few times if we get EIO or EINTR */
+int daos_chmod(const char* path, mode_t mode, mfu_file_t* mfu_file);
 int mfu_chmod(const char* path, mode_t mode);
+int mfu_file_chmod(const char* path, mode_t mode, mfu_file_t* mfu_file);
 
 /* calls utimensat, and retries a few times if we get EIO or EINTR */
 int mfu_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags);
 
 /* calls lstat, and retries a few times if we get EIO or EINTR */
-int mfu_lstat(const char* path, struct stat* buf);
+int mfu_file_lstat(const char* path, struct stat* buf, mfu_file_t* mfu_file);
 
-/* calls lstat, and retries a few times if we get EIO or EINTR */
+/* only dcp1 calls mfu_lstat64, is it necessary? */
 int mfu_lstat64(const char* path, struct stat64* buf);
 
+/* posix version of stat */
+int mfu_lstat(const char* path, struct stat* buf);
+
+/* daos version of stat */
+int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file);
+
 /* call mknod, retry a few times on EINTR or EIO */
+int mfu_file_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file);
+/* just a noop, since there is no daos_mknod */
+int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file);
 int mfu_mknod(const char* path, mode_t mode, dev_t dev);
 
 /* call remove, retry a few times on EINTR or EIO */
 int mfu_remove(const char* path);
 
+/* read directory entry, retry a few times on ENOENT, EIO, or EINTR */
+struct dirent* mfu_file_readdir(DIR* dirp, mfu_file_t* mfu_file);
+struct dirent* mfu_readdir(DIR* dirp);
+struct dirent* daos_readdir(DIR* dirp, mfu_file_t* mfu_file);
+
 /*****************************
  * Links
  ****************************/
@@ -77,35 +102,48 @@ int mfu_remove(const char* path);
 /* call readlink, retry a few times on EINTR or EIO */
 ssize_t mfu_readlink(const char* path, char* buf, size_t bufsize);
 
-/* call symlink, retry a few times on EINTR or EIO */
-int mfu_symlink(const char* oldpath, const char* newpath);
-
 /* call hardlink, retry a few times on EINTR or EIO */
 int mfu_hardlink(const char* oldpath, const char* newpath);
 
+/* call symlink, retry a few times on EINTR or EIO */
+int mfu_symlink(const char* oldpath, const char* newpath);
+
 /*****************************
  * Files
  ****************************/
 
 /* open file with specified flags and mode, retry open a few times on failure */
+void mfu_file_open(const char* file, int flags, mfu_file_t* mfu_file, ...);
+void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file);
 int mfu_open(const char* file, int flags, ...);
 
 /* close file */
+int mfu_file_close(const char* file, mfu_file_t* mfu_file);
+int daos_close(const char* file, mfu_file_t* mfu_file);
 int mfu_close(const char* file, int fd);
 
 /* seek file descriptor to specified position */
+off_t mfu_file_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence);
+/* actually a noop since daos doesn't have an lseek */
+int daos_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence);
 off_t mfu_lseek(const char* file, int fd, off_t pos, int whence);
 
 /* reliable read from opened file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file);
+ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file);
 ssize_t mfu_read(const char* file, int fd, void* buf, size_t size);
 
 /* reliable write to opened file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file);
+ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file);
 ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size);
 
 /* truncate a file */
 int mfu_truncate(const char* file, off_t length);
 
 /* ftruncate a file */
+int mfu_file_ftruncate(mfu_file_t* mfu_file, off_t length);
+int daos_ftruncate(mfu_file_t* mfu_file, off_t length);
 int mfu_ftruncate(int fd, off_t length);
 
 /* delete a file */
@@ -122,19 +160,22 @@ int mfu_fsync(const char* file, int fd);
 void mfu_getcwd(char* buf, size_t size);
 
 /* create directory, retry a few times on EINTR or EIO */
+int mfu_file_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file);
 int mfu_mkdir(const char* dir, mode_t mode);
+int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file);
 
 /* remove directory, retry a few times on EINTR or EIO */
 int mfu_rmdir(const char* dir);
 
 /* open directory, retry a few times on EINTR or EIO */
+DIR* mfu_file_opendir(const char* dir, mfu_file_t* mfu_file);
 DIR* mfu_opendir(const char* dir);
+DIR* daos_opendir(const char* dir, mfu_file_t* mfu_file);
 
 /* close directory, retry a few times on EINTR or EIO */
+int mfu_file_closedir(DIR* dirp, mfu_file_t* mfu_file);
 int mfu_closedir(DIR* dirp);
-
-/* read directory entry, retry a few times on ENOENT, EIO, or EINTR */
-struct dirent* mfu_readdir(DIR* dirp);
+int daos_closedir(DIR* dirp, mfu_file_t* mfu_file);
 
 #endif /* MFU_IO_H */
 
diff --git a/src/common/mfu_param_path.c b/src/common/mfu_param_path.c
index d4c6a48b..96bb28ea 100644
--- a/src/common/mfu_param_path.c
+++ b/src/common/mfu_param_path.c
@@ -329,7 +329,8 @@ static void mfu_unpack_param(const char** pptr, mfu_param_path* param)
  * path to this item and then prepend destination prefix. */
 char* mfu_param_path_copy_dest(const char* name, int numpaths,
         const mfu_param_path* paths, const mfu_param_path* destpath, 
-        mfu_copy_opts_t* mfu_copy_opts)
+        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file,
+        mfu_file_t* mfu_dst_file)
 {
     /* identify which source directory this came from */
     int i;
@@ -397,12 +398,20 @@ char* mfu_param_path_copy_dest(const char* name, int numpaths,
 
 /* check that source and destination paths are valid */
 void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths, 
-        const mfu_param_path* destpath, int* flag_valid, int* flag_copy_into_dir)
+        const mfu_param_path* destpath, mfu_file_t* mfu_src_file,
+        mfu_file_t* mfu_dst_file, int* flag_valid,
+        int* flag_copy_into_dir)
 {
     /* initialize output params */
     *flag_valid = 0;
     *flag_copy_into_dir = 0;
 
+    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
+        if (num != 1) {
+            MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
+        }
+    }
+
     /* need at least two paths to have a shot at being valid */
     if (num < 1 || paths == NULL || destpath == NULL) {
         return;
@@ -422,7 +431,7 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
         int num_readable = 0;
         for(i = 0; i < num; i++) {
             const char* path = paths[i].path;
-            if(mfu_access(path, R_OK) == 0) {
+            if(mfu_file_access(path, R_OK, mfu_src_file) == 0) {
                 num_readable++;
             }
             else {
@@ -507,7 +516,7 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
             }
 
             /* check that dest is writable */
-            if(mfu_access(destpath->path, W_OK) < 0) {
+            if(mfu_file_access(destpath->path, W_OK, mfu_dst_file) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Destination is not writable `%s'",
                     destpath->path);
                 valid = 0;
@@ -525,7 +534,7 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
             mfu_path_delete(&parent);
 
             /* check that parent is writable */
-            if(mfu_access(parent_str, W_OK) < 0) {
+            if(mfu_file_access(parent_str, W_OK, mfu_dst_file) < 0) {
                 MFU_LOG(MFU_LOG_ERR, "Destination parent directory is not writable `%s'",
                     parent_str);
                 valid = 0;
diff --git a/src/common/mfu_param_path.h b/src/common/mfu_param_path.h
index 9e6f4edb..ad71b964 100644
--- a/src/common/mfu_param_path.h
+++ b/src/common/mfu_param_path.h
@@ -14,6 +14,7 @@ extern "C" {
 #include <stdbool.h>
 #include <stdint.h>
 #include "mpi.h"
+#include "mfu_io.h"
 
 /* for struct stat */
 #include <sys/types.h>
@@ -51,6 +52,20 @@ typedef struct mfu_param_path_t {
     struct stat target_stat; /* stat of target path */
 } mfu_param_path;
 
+/* options passed to I/O functions that tell them which backend filesystem to use */
+typedef struct {
+    enum        {POSIX, DAOS} type;
+    int         fd;
+    bool        only_daos;
+#ifdef DAOS_SUPPORT
+    /* DAOS specific variables for I/O */
+    d_sg_list_t* sgl;
+    daos_off_t   offset;
+    dfs_obj_t*   obj;
+    dfs_t*       dfs;
+#endif
+} mfu_file_t;
+
 /* set fields in param according to path */
 void mfu_param_path_set(const char* path, mfu_param_path* param);
 
@@ -75,15 +90,17 @@ void mfu_param_path_check_copy(
     uint64_t num,                   /* IN  - number of source paths */
     const mfu_param_path* paths,    /* IN  - array of source param paths */
     const mfu_param_path* destpath, /* IN  - dest param path */
+    mfu_file_t* mfu_src_file,       /* IN  - mfu_file for source that specifies which I/O calls to make */
+    mfu_file_t* mfu_dst_file,       /* IN  - mfu_file for destination that specifies which I/O calls to make */
     int* flag_valid,                /* OUT - flag indicating whether combination of source and dest param paths are valid (1) or not (0) */
     int* flag_copy_into_dir         /* OUT - flag indicating whether source items should be copied into destination directory (1) or not (0) */
 );
 
 /* options passed to walk that effect how the walk is executed */
 typedef struct {
-    int    dir_perms;    /* flag option to update dir perms during walk */
-    int    remove;       /* flag option to remove files during walk */
-    int    use_stat;     /* flag option on whether or not to stat files during walk */
+    int    dir_perms;          /* flag option to update dir perms during walk */
+    int    remove;             /* flag option to remove files during walk */
+    int    use_stat;           /* flag option on whether or not to stat files during walk */
 } mfu_walk_opts_t;
 
 /* options passed to mfu_ */
@@ -114,7 +131,9 @@ char* mfu_param_path_copy_dest(
     int numpaths,                   /* IN  - number of source paths */
     const mfu_param_path* paths,    /* IN  - array of source param paths */
     const mfu_param_path* destpath, /* IN  - dest param path */
-    mfu_copy_opts_t* mfu_copy_opts  /* IN  - options to be used during copy */
+    mfu_copy_opts_t* mfu_copy_opts, /* IN  - options to be used during copy */
+    mfu_file_t* mfu_src_file,       /* IN  - I/O filesystem functions to use for copy of src */
+    mfu_file_t* mfu_dst_file        /* IN  - I/O filesystem functions to use for copy of dst */
 );
 
 #endif /* MFU_PARAM_PATH_H */
diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index edd8703f..4499d5cc 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -36,6 +36,114 @@ mfu_loglevel mfu_debug_level = MFU_LOG_ERR;
 /* default progress message timeout in seconds */
 int mfu_progress_timeout = 10;
 
+/***** DAOS utility functions ******/
+#ifdef DAOS_SUPPORT
+bool daos_uuid_valid(const uuid_t uuid)
+{
+	return uuid && !uuid_is_null(uuid);
+}
+
+/* Distribute process 0's pool or container handle to others. */
+void HandleDistribute(int rank, daos_handle_t *handle,
+                      daos_handle_t* poh, enum handleType type)
+{
+        d_iov_t global;
+        int        rc;
+
+        global.iov_buf = NULL;
+        global.iov_buf_len = 0;
+        global.iov_len = 0;
+
+        if (rank == 0) {
+                /* Get the global handle size. */
+                if (type == POOL_HANDLE) {
+                    rc = daos_pool_local2global(*handle, &global);
+                } else {
+                    rc = daos_cont_local2global(*handle, &global);
+                }
+                if (rc != 0) {
+                    MFU_LOG(MFU_LOG_INFO, "Failed to get global handle size");
+                }
+        }
+
+        MPI_Bcast(&global.iov_buf_len, 1, MPI_UINT64_T, 0, MPI_COMM_WORLD);
+ 
+        global.iov_len = global.iov_buf_len;
+        global.iov_buf = malloc(global.iov_buf_len);
+        if (global.iov_buf == NULL) {
+            MPI_Abort(MPI_COMM_WORLD, -1);
+        }
+
+        if (rank == 0) {
+                if (type == POOL_HANDLE) {
+                    rc = daos_pool_local2global(*handle, &global);
+                } else {
+                    rc = daos_cont_local2global(*handle, &global);
+                }
+                if (rc != 0) {
+                    MFU_LOG(MFU_LOG_INFO, "Failed to create global handle");
+                }
+        }
+
+        MPI_Bcast(global.iov_buf, global.iov_buf_len, MPI_BYTE, 0, MPI_COMM_WORLD);
+
+        if (rank != 0) {
+                if (type == POOL_HANDLE) {
+                    rc = daos_pool_global2local(global, handle);
+                } else {
+                    rc = daos_cont_global2local(*poh, global, handle);
+                }
+                if (rc != 0) {
+                    MFU_LOG(MFU_LOG_INFO, "Failed to get local handle");
+                }
+        }
+
+        free(global.iov_buf);
+}
+
+void daos_connect(int* rank, daos_handle_t* poh, daos_handle_t* coh,
+                  uuid_t* pool_uuid, uuid_t* cont_uuid, char* svc)
+{ 
+    /* TODO: if src daos path and dst daos path are false 
+    *  skip connecting to daos pool */
+    int rc = 0;
+    if (*rank == 0) {
+        d_rank_list_t *svcl = NULL;
+        daos_pool_info_t pool_info;
+        daos_cont_info_t co_info;
+
+        svcl = daos_rank_list_parse(svc, ":");
+        if (svcl == NULL) {
+ 	    MPI_Abort(MPI_COMM_WORLD, -1);
+        }
+
+        /** Connect to DAOS pool */
+        rc = daos_pool_connect(*pool_uuid, NULL, svcl, DAOS_PC_RW,
+                               poh, &pool_info, NULL);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to connect to pool");
+        }
+        d_rank_list_free(svcl);
+
+        rc = daos_cont_open(*poh, *cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+        /* If NOEXIST we create it */
+        if (rc != 0) {
+            uuid_t cuuid;
+            rc = dfs_cont_create(*poh, cuuid, NULL, NULL, NULL);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to create DFS container");
+            }
+            rc = daos_cont_open(*poh, cuuid, DAOS_COO_RW, coh, &co_info, NULL);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
+            }
+        }
+    }
+    HandleDistribute(*rank, poh, poh, POOL_HANDLE);
+    HandleDistribute(*rank, coh, poh, CONT_HANDLE);
+}
+#endif
+
 /* initialize mfu library,
  * reference counting allows for multiple init/finalize pairs */
 int mfu_init()
@@ -44,10 +152,10 @@ int mfu_init()
         /* set globals */
         MPI_Comm_rank(MPI_COMM_WORLD, &mfu_rank);
         mfu_debug_stream = stdout;
-
         DTCMP_Init();
         mfu_initialized++;
     }
+
     return MFU_SUCCESS;
 }
 
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index f18d09e9..d956e21d 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -33,6 +33,8 @@ extern "C" {
 
 #include "mfu_progress.h"
 
+#include "mfu_io.h"
+
 #if __BYTE_ORDER == __LITTLE_ENDIAN
 #ifdef HAVE_BYTESWAP_H
 # define mfu_ntoh16(x) bswap_16(x)
@@ -68,6 +70,14 @@ typedef enum {
     MFU_LOG_DBG     = 6
 } mfu_loglevel;
 
+#ifdef DAOS_SUPPORT
+enum handleType {
+        POOL_HANDLE,
+        CONT_HANDLE,
+        ARRAY_HANDLE
+};
+#endif
+
 extern int mfu_initialized;
 
 /* set during mfu_init, used in MFU_LOG */
@@ -103,6 +113,20 @@ extern int mfu_progress_timeout;
         } \
     } while (0)
 
+/******** DAOS utility functions ********/
+#ifdef DAOS_SUPPORT
+bool daos_uuid_valid(const uuid_t uuid);
+
+/* Distribute process 0's pool or container handle to others. */
+void HandleDistribute(int rank, daos_handle_t *handle,
+                      daos_handle_t* poh, enum handleType type);
+
+/* connect to DAOS pool, and then open container */
+void daos_connect(int* rank, daos_handle_t* poh,
+                  daos_handle_t* coh, uuid_t* pool_uuid,
+                  uuid_t* cont_uuid, char* svc);
+#endif
+
 /* initialize mfu library,
  * reference counting allows for multiple init/finalize pairs */
 int mfu_init(void);
@@ -234,15 +258,15 @@ void mfu_stat_set_ctimes(struct stat* sb, uint64_t secs, uint64_t nsecs);
 /* compares contents of two files and optionally overwrite dest with source,
  * returns -1 on error, 0 if equal, 1 if different */
 int mfu_compare_contents(
-    const char* src,         /* IN  - path name to souce file */
-    const char* dst,         /* IN  - path name to destination file */
-    off_t offset,            /* IN  - offset with file to start comparison */
-    off_t length,            /* IN  - number of bytes to be compared */
-    size_t bufsize,          /* IN  - size of I/O buffer to be used during compare */
-    int overwrite,           /* IN  - whether to replace dest with source contents (1) or not (0) */
-    uint64_t* bytes_read,    /* OUT - number of bytes read (src + dest) */
-    uint64_t* bytes_written, /* OUT - number of bytes written to dest */
-    mfu_progress* prg        /* IN  - progress message structure */
+    const char* src,          /* IN  - path name to souce file */
+    const char* dst,          /* IN  - path name to destination file */
+    off_t offset,             /* IN  - offset with file to start comparison */
+    off_t length,             /* IN  - number of bytes to be compared */
+    size_t bufsize,           /* IN  - size of I/O buffer to be used during compare */
+    int overwrite,            /* IN  - whether to replace dest with source contents (1) or not (0) */
+    uint64_t* bytes_read,     /* OUT - number of bytes read (src + dest) */
+    uint64_t* bytes_written,  /* OUT - number of bytes written to dest */
+    mfu_progress* prg         /* IN  - progress message structure */
 );
 
 /* uses the lustre api to obtain stripe count and stripe size of a file */
diff --git a/src/dchmod/dchmod.c b/src/dchmod/dchmod.c
index 7f81beee..bcb905a3 100644
--- a/src/dchmod/dchmod.c
+++ b/src/dchmod/dchmod.c
@@ -229,6 +229,9 @@ int main(int argc, char** argv)
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file object */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* flag used to check if permissions need to be
      * set on the walk */
     if (head != NULL) {
@@ -245,7 +248,7 @@ int main(int argc, char** argv)
         }
 
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read list from file */
@@ -306,6 +309,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dcmp/dcmp.c b/src/dcmp/dcmp.c
index fda14f36..b254f5d5 100644
--- a/src/dcmp/dcmp.c
+++ b/src/dcmp/dcmp.c
@@ -2191,16 +2191,19 @@ int main(int argc, char **argv)
     mfu_flist flist1 = mfu_flist_new();
     mfu_flist flist2 = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_src_file = mfu_file_new();
+    mfu_file_t* mfu_dst_file = mfu_file_new();
 
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking source path");
     }
-    mfu_flist_walk_param_paths(1,  srcpath, walk_opts, flist1);
+    mfu_flist_walk_param_paths(1,  srcpath, walk_opts, flist1, mfu_src_file);
 
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking destination path");
     }
-    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist2);
+    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist2, mfu_dst_file);
 
     /* store src and dest path strings */
     const char* path1 = srcpath->path;
@@ -2239,6 +2242,10 @@ int main(int argc, char **argv)
     mfu_flist_free(&flist3);
     mfu_flist_free(&flist4);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_src_file);
+    mfu_file_delete(&mfu_dst_file);
+
     /* free all param paths */
     mfu_param_path_free_all(numargs, paths);
 
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 823845af..6c963375 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -8,10 +8,93 @@
 #include <errno.h>
 #include <stdbool.h>
 
+/* for daos */
+#ifdef DAOS_SUPPORT
+#include <uuid/uuid.h>
+#include <gurt/common.h>
+#include <gurt/hash.h>
+#include <daos.h>
+#include <daos_fs.h>
+#include <daos_uns.h>
+#endif
+
 #include "mpi.h"
 #include "libcircle.h"
 #include "mfu.h"
 
+#ifdef DAOS_SUPPORT
+static void daos_set_paths(int* rank, char** argpaths, uuid_t* src_pool_uuid,
+			   uuid_t* src_cont_uuid, uuid_t* dst_pool_uuid, uuid_t* dst_cont_uuid,
+                           char* dfs_prefix, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+{
+    /* find out if a dfs_prefix is being used,
+     * if so, then that means that the container
+     * is not being copied from the root of the
+     * UNS path  */
+    int rc = 0;
+    struct duns_attr_t dattr  = {0}; 
+    struct duns_attr_t ddattr = {0}; 
+    char* src_path            = argpaths[0];
+    char* dst_path            = argpaths[1];
+
+    /* assume both are daos paths for UNS, if resolve path
+     * doesn't succeed then set accordingly */
+    int src_rc = -1;
+    int dst_rc = -1;
+    if (dfs_prefix == NULL) {
+        src_rc = duns_resolve_path(src_path, &dattr);
+        dst_rc = duns_resolve_path(dst_path, &ddattr);
+        /* Forward slash is "root" of container to walk
+         * in daos. Cannot walk from Unified namespace
+         * path given /tmp/dsikich/dfs, it is only used
+         * to lookup pool/cont uuids, and tells you
+         * if that path is mapped to pool/cont uuid in
+         * DAOS */
+        if (src_rc == 0 && dst_rc == 0) {
+            mfu_src_file->type = DAOS;
+            mfu_dst_file->type = DAOS;
+            uuid_copy(*src_pool_uuid, dattr.da_puuid);
+            uuid_copy(*src_cont_uuid, dattr.da_cuuid);
+            uuid_copy(*dst_pool_uuid, ddattr.da_puuid);
+            uuid_copy(*dst_cont_uuid, ddattr.da_cuuid);
+            argpaths[0]  = "/";
+            argpaths[1] = "/";
+        } else if (src_rc == 0) { 
+            mfu_src_file->type = DAOS;
+            uuid_copy(*src_pool_uuid, dattr.da_puuid);
+            uuid_copy(*src_cont_uuid, dattr.da_cuuid);
+            argpaths[0]  = "/";
+        } else if (dst_rc == 0) {
+            mfu_dst_file->type = DAOS;
+            uuid_copy(*dst_pool_uuid, ddattr.da_puuid);
+            uuid_copy(*dst_cont_uuid, ddattr.da_cuuid);
+            argpaths[1]  = "/";
+        }
+        /* set daos io functions for src/dst paths */
+    } else {
+        rc = duns_resolve_path(dfs_prefix, &dattr);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS UNS path");
+        }
+        /* figure out if prefix is on dst or src for 
+         * for copying container subsets */
+        char* src_ret;
+        src_ret = strstr(src_path, dfs_prefix);
+        if (src_ret != NULL) {
+            mfu_src_file->type = DAOS;
+            uuid_copy(*src_pool_uuid, dattr.da_puuid);
+            uuid_copy(*src_cont_uuid, dattr.da_cuuid);
+            argpaths[0] = src_path + strlen(dfs_prefix);
+        } else {
+            mfu_dst_file->type = DAOS;
+            uuid_copy(*dst_pool_uuid, dattr.da_puuid);
+            uuid_copy(*dst_cont_uuid, dattr.da_cuuid);
+            argpaths[1] = dst_path + strlen(dfs_prefix);
+        }
+    }
+}
+#endif 
+
 static int input_flist_skip(const char* name, void *args)
 {
     /* nothing to do if args are NULL */
@@ -38,7 +121,7 @@ static int input_flist_skip(const char* name, void *args)
         mfu_path_result result = mfu_path_cmp(path, src_path);
         if (result == MFU_PATH_SRC_CHILD || result == MFU_PATH_EQUAL) {
             MFU_LOG(MFU_LOG_INFO, "Need to copy %s because of %s.",
-               name, src_name);
+                    name, src_name);
             mfu_path_delete(&src_path);
             mfu_path_delete(&path);
             return 0;
@@ -66,6 +149,12 @@ void print_usage(void)
     /* printf("  -g, --grouplock <id> - use Lustre grouplock when reading/writing file\n"); */
 #endif
     printf("  -b, --blocksize     - IO buffer size in bytes (default 1MB)\n");
+    printf("      --daos-src-pool      - DAOS source pool \n");
+    printf("      --daos-dst-pool      - DAOS destination pool \n");
+    printf("      --daos-src-cont      - DAOS source container \n");
+    printf("      --daos-dst-cont      - DAOS destination container \n");
+    printf("      --daos-svcl          - DAOS service level \n");
+    printf("      --daos-prefix        - DAOS prefix for unified namespace path \n");
     printf("  -i, --input <file>  - read source list from file\n");
     printf("  -k, --chunksize     - work size per task in bytes (default 1MB)\n");
     printf("  -p, --preserve      - preserve permissions, ownership, timestamps, extended attributes\n");
@@ -93,6 +182,10 @@ int main(int argc, char** argv)
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
+    /* pointer to mfu_file src and dest objects */
+    mfu_file_t* mfu_src_file = mfu_file_new();
+    mfu_file_t* mfu_dst_file = mfu_file_new();
+
     /* pointer to mfu_copy opts */
     mfu_copy_opts_t* mfu_copy_opts = mfu_copy_opts_new();
 
@@ -109,11 +202,39 @@ int main(int argc, char** argv)
     /* By default, don't have iput file. */
     char* inputname = NULL;
 
+#ifdef DAOS_SUPPORT
+    /* DAOS vars */ 
+    daos_handle_t src_poh = DAOS_HDL_INVAL;
+    daos_handle_t dst_poh = DAOS_HDL_INVAL;
+    daos_handle_t src_coh = DAOS_HDL_INVAL;
+    daos_handle_t dst_coh = DAOS_HDL_INVAL;
+    dfs_t *dfs1           = NULL;
+    dfs_t *dfs2           = NULL;
+    char* svc             = NULL;
+    char* dfs_prefix      = NULL;
+
+    /* initalize value of DAOS UUID's to NULL with uuid_clear */
+    uuid_t src_pool_uuid;
+    uuid_t dst_pool_uuid;
+    uuid_t src_cont_uuid;
+    uuid_t dst_cont_uuid;
+    uuid_clear(src_pool_uuid);
+    uuid_clear(dst_pool_uuid);
+    uuid_clear(src_cont_uuid);
+    uuid_clear(dst_cont_uuid);
+#endif
+
     int option_index = 0;
     static struct option long_options[] = {
         {"blocksize"            , required_argument, 0, 'b'},
         {"debug"                , required_argument, 0, 'd'}, // undocumented
         {"grouplock"            , required_argument, 0, 'g'}, // untested
+        {"daos-src-pool"        , required_argument, 0, 'x'},
+        {"daos-dst-pool"        , required_argument, 0, 'D'},
+        {"daos-src-cont"        , required_argument, 0, 'y'},
+        {"daos-dst-cont"        , required_argument, 0, 'Y'},
+        {"daos-svcl"            , required_argument, 0, 'z'},
+        {"daos-prefix"          , required_argument, 0, 'X'},
         {"input"                , required_argument, 0, 'i'},
         {"chunksize"            , required_argument, 0, 'k'},
         {"preserve"             , no_argument      , 0, 'p'},
@@ -202,6 +323,52 @@ int main(int argc, char** argv)
                         mfu_copy_opts->grouplock_id);
                 }
                 break;
+#endif
+#ifdef DAOS_SUPPORT
+            case 'x':
+	        rc = uuid_parse(optarg, src_pool_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse source pool uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+    	        break;
+            case 'D':
+	        rc = uuid_parse(optarg, dst_pool_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse dst pool uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+    	        break;
+            case 'y':
+	        rc = uuid_parse(optarg, src_cont_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse source cont uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+                mfu_src_file->type = DAOS;
+    	        break;
+            case 'Y':
+	        rc = uuid_parse(optarg, dst_cont_uuid);
+                if (rc != 0) {
+                    if (rank == 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to parse dst cont uuid: '%s'", optarg);
+                    }
+                    usage = 1;
+                }
+                mfu_dst_file->type = DAOS;
+    	        break;
+            case 'z':
+    	        svc = MFU_STRDUP(optarg);
+    	        break;
+            case 'X':
+    	        dfs_prefix = MFU_STRDUP(optarg);
+    	        break;
 #endif
             case 'i':
                 inputname = MFU_STRDUP(optarg);
@@ -271,10 +438,103 @@ int main(int argc, char** argv)
         usage = 1;
     }
 
+    char** argpaths = (&argv[optind]);
+
+#ifdef DAOS_SUPPORT
+    rc = daos_init();
+
+    /* TODO: Don't exit and fail if daos fails init,
+     * could just be regular paths */
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to initialize daos");
+    }
+
+    /* Figure out if daos path is the src or dst,
+     * using UNS path, then chop off UNS path
+     * prefix since the path is mapped to the root
+     * of the container in the DAOS DFS mount */
+    if (!daos_uuid_valid(src_pool_uuid) || !daos_uuid_valid(dst_pool_uuid)) {
+        daos_set_paths(&rank, argpaths, &src_pool_uuid, &src_cont_uuid,
+            &dst_pool_uuid, &dst_cont_uuid, dfs_prefix, mfu_src_file, mfu_dst_file);
+    }
+
+    /* check if DAOS source and destination containers are in the same pool */
+    bool same_pool = false;
+    if (mfu_src_file->type == DAOS && mfu_dst_file->type == DAOS) {
+        if (uuid_compare(src_pool_uuid, dst_pool_uuid) == 0) {
+            same_pool = true;
+        }
+    } 
+
+    /* connect to DAOS source pool if uuid is valid */
+    if (mfu_src_file->type == DAOS) {
+       /* if DAOS source pool uuid is valid, then set source file type to DAOS */
+        daos_connect(&rank, &src_poh, &src_coh, &src_pool_uuid, &src_cont_uuid, svc); 
+    }
+
+    if (mfu_dst_file->type == DAOS) {
+        if (daos_uuid_valid(dst_pool_uuid) && !same_pool) {
+            /* if DAOS is the source and destination type, and containers are in different pools,
+             *  then connect to the second pool */
+            daos_connect(&rank, &dst_poh, &dst_coh, &dst_pool_uuid, &dst_cont_uuid, svc); 
+        } else {
+            /* if DAOS is source and destination type, and containers are in the same pool,
+             * then pool is already connected, so we just need to open and/or create the container */
+            if (rank == 0) {
+                /* create container in same pool */
+                daos_cont_info_t co_info;
+                rc = daos_cont_open(src_poh, dst_cont_uuid, DAOS_COO_RW, &dst_coh, &co_info, NULL);
+	        if (rc != 0) {
+                    /* If NOEXIST we create it */
+                    uuid_t cuuid;
+                    rc = dfs_cont_create(src_poh, cuuid, NULL, NULL, NULL);
+                    if (rc != 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to create DFS2 container");
+                    }
+                    rc = daos_cont_open(src_poh, cuuid, DAOS_COO_RW, &dst_coh, &co_info, NULL);
+                    if (rc != 0) {
+                        MFU_LOG(MFU_LOG_ERR, "Failed to open DFS2 container");
+                    }
+                }
+            }
+            HandleDistribute(rank, &dst_coh, &src_poh, CONT_HANDLE);
+        }
+    }
+
+    if (mfu_src_file->type == DAOS) {
+        /* DFS is mounted for the source container */
+        rc = dfs_mount(src_poh, src_coh, O_RDWR, &dfs1);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS)");
+        }
+    }
+
+    if (mfu_dst_file->type == DAOS) {
+        /* DFS is mounted for the destination container */
+        if (same_pool) {
+            rc = dfs_mount(src_poh, dst_coh, O_RDWR, &dfs2);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS)");
+            }
+        } else {
+            rc = dfs_mount(dst_poh, dst_coh, O_RDWR, &dfs2);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS)");
+            }
+        }
+    }
+
+    /* set source and destination files to address of their
+     * DFS mount within DAOS */
+    mfu_src_file->dfs = dfs1;
+    mfu_dst_file->dfs = dfs2;
+#endif
+
     /* paths to walk come after the options */
     int numpaths = 0;
     int numpaths_src = 0;
     mfu_param_path* paths = NULL;
+
     if (optind < argc) {
         /* determine number of paths specified by user */
         numpaths = argc - optind;
@@ -283,7 +543,7 @@ int main(int argc, char** argv)
         paths = (mfu_param_path*) MFU_MALLOC((size_t)numpaths * sizeof(mfu_param_path));
 
         /* process each path */
-        const char** argpaths = (const char**)(&argv[optind]);
+
         mfu_param_path_set_all(numpaths, argpaths, paths);
 
         /* advance to next set of options */
@@ -314,8 +574,9 @@ int main(int argc, char** argv)
 
     /* Parse the source and destination paths. */
     int valid, copy_into_dir;
-    mfu_param_path_check_copy(numpaths_src, paths, destpath, &valid, &copy_into_dir);
-    mfu_copy_opts->copy_into_dir = copy_into_dir;
+    mfu_param_path_check_copy(numpaths_src, paths, destpath, mfu_src_file, mfu_dst_file, &valid, &copy_into_dir);
+    mfu_copy_opts->copy_into_dir = copy_into_dir; 
+
     /* exit job if we found a problem */
     if (!valid) {
         if(rank == 0) {
@@ -332,7 +593,8 @@ int main(int argc, char** argv)
     mfu_flist flist = mfu_flist_new();
 
     if (inputname == NULL) {
-        mfu_flist_walk_param_paths(numpaths_src, paths, walk_opts, flist);
+        /* if daos is set to SRC then use daos_ functions on walk */
+        mfu_flist_walk_param_paths(numpaths_src, paths, walk_opts, flist, mfu_src_file);
     } else {
         struct mfu_flist_skip_args skip_args;
 
@@ -346,8 +608,10 @@ int main(int argc, char** argv)
         mfu_flist_free(&input_flist);
     }
 
-    /* copy flist into destination */
-    int tmp_rc = mfu_flist_copy(flist, numpaths_src, paths, destpath, mfu_copy_opts);
+    /* copy flist into destination */ 
+    int tmp_rc = mfu_flist_copy(flist, numpaths_src, paths,
+                                destpath, mfu_copy_opts, mfu_src_file,
+                                mfu_dst_file);
     if (tmp_rc < 0) {
         /* hit some sort of error during copy */
         rc = 1;
@@ -371,9 +635,63 @@ int main(int argc, char** argv)
     /* free the copy options */
     mfu_walk_opts_delete(&walk_opts);
 
-    /* shut down MPI */
-    /* shut down MPI */
+    /* DAOS: unmount DFS, and close containers and pools */
+#ifdef DAOS_SUPPORT
+    if (mfu_src_file->type == DAOS) {
+        rc = dfs_umount(mfu_src_file->dfs);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to mount DFS namespace");
+        }
+        rc = daos_cont_close(src_coh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+        }
+    }
+
+    if (mfu_dst_file->type == DAOS) {
+        rc = dfs_umount(mfu_dst_file->dfs);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed unmount DFS namespace");
+        }
+        rc = daos_cont_close(dst_coh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+        }
+    }
+
+    if (mfu_src_file->type == DAOS) {
+        rc = daos_pool_disconnect(src_poh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from source pool");
+        }
+    }
+
+    if (mfu_dst_file->type == DAOS && !same_pool) {
+        rc = daos_pool_disconnect(dst_poh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool");
+        }
+    }
+#endif
+
+    /* free the mfu_file object */
+    mfu_file_delete(&mfu_src_file);
+    mfu_file_delete(&mfu_dst_file);
+
+#ifdef DAOS_SUPPORT
+    /* finalize daos */
+    rc = daos_fini();
+#endif
+
     mfu_finalize();
+
+    /* shut down MPI */
     MPI_Finalize();
 
     return 0;
diff --git a/src/ddup/ddup.c b/src/ddup/ddup.c
index c4e3a9bc..582ea30d 100644
--- a/src/ddup/ddup.c
+++ b/src/ddup/ddup.c
@@ -299,8 +299,11 @@ int main(int argc, char** argv)
     /* allocate a file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file object */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* Walk the path(s) to build the flist */
-    mfu_flist_walk_path(dir, walk_opts, flist);
+    mfu_flist_walk_path(dir, walk_opts, flist, mfu_file);
 
     /* TODO: spread list among procs? */
 
@@ -508,6 +511,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     mfu_free(&group_rank);
     mfu_free(&group_ranks);
     mfu_free(&group_id);
diff --git a/src/dfilemaker1/dfilemaker1.c b/src/dfilemaker1/dfilemaker1.c
index ce97d584..86863729 100644
--- a/src/dfilemaker1/dfilemaker1.c
+++ b/src/dfilemaker1/dfilemaker1.c
@@ -144,9 +144,12 @@ int main(int argc, char* argv[])
   /* pointer to mfu_copy opts */
   mfu_copy_opts_t* mfu_copy_opts = mfu_copy_opts_new();
 
+  /* create new mfu_file objects */
+  mfu_file_t* mfu_file = mfu_file_new();
+
   mfu_flist_mkdir(flist);
   mfu_flist_mknod(flist);
-  mfu_flist_fill(flist, mfu_copy_opts);
+  mfu_flist_fill(flist, mfu_copy_opts, mfu_file);
   //mfu_flist_setmeta()
 
   mfu_flist_free(&flist);
@@ -154,6 +157,9 @@ int main(int argc, char* argv[])
   /* free the copy options */
   mfu_copy_opts_delete(&mfu_copy_opts);
 
+  /* delete file objects */
+  mfu_file_delete(&mfu_file);
+
   /* shut down */
   mfu_finalize();
   MPI_Finalize();
diff --git a/src/dfind/dfind.c b/src/dfind/dfind.c
index 7ec2495a..1c25593f 100644
--- a/src/dfind/dfind.c
+++ b/src/dfind/dfind.c
@@ -585,9 +585,12 @@ int main (int argc, char** argv)
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read data from cache file */
@@ -631,6 +634,9 @@ int main (int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dreln/dreln.c b/src/dreln/dreln.c
index 1b547b22..3f3adf7a 100644
--- a/src/dreln/dreln.c
+++ b/src/dreln/dreln.c
@@ -217,10 +217,13 @@ int main (int argc, char* argv[])
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* get source file list */
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     } else {
         /* read cache file */
         mfu_flist_read_cache(inputname, flist);
@@ -418,6 +421,9 @@ int main (int argc, char* argv[])
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     mfu_path_delete(&path_new);
     mfu_path_delete(&path_old);
 
diff --git a/src/drm/drm.c b/src/drm/drm.c
index 80ea54d1..5ab7108c 100644
--- a/src/drm/drm.c
+++ b/src/drm/drm.c
@@ -257,11 +257,14 @@ int main(int argc, char** argv)
     /* create an empty file list */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     /* get our list of files, either by walking or reading an
      * input file */
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read list from file */
@@ -327,6 +330,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dstripe/dstripe.c b/src/dstripe/dstripe.c
index 3020769d..181b1721 100644
--- a/src/dstripe/dstripe.c
+++ b/src/dstripe/dstripe.c
@@ -549,7 +549,11 @@ int main(int argc, char* argv[])
 
     /* walk list of input paths and stat as we walk */
     mfu_flist flist = mfu_flist_new();
-    mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_file = mfu_file_new();
+
+    mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
 
     /* filter down our list to files which don't meet our striping requirements */
     mfu_flist filtered = filter_list(flist, stripes, stripe_size, min_size, &create_prog_count_total, &stripe_prog_bytes_total);
@@ -687,6 +691,9 @@ int main(int argc, char* argv[])
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file object */
+    mfu_file_delete(&mfu_file);
+
     /* free filtered list, path parameters */
     mfu_flist_free(&filtered);
     mfu_param_path_free_all(numpaths, paths);
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index 1dd5d969..1463f29e 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -1261,7 +1261,9 @@ static int dsync_sync_files(
         mfu_flist dst_remove_list,
         mfu_flist link_dst_list,
         mfu_flist src_cp_list,
-        mfu_copy_opts_t* mfu_copy_opts)
+        mfu_copy_opts_t* mfu_copy_opts,
+        mfu_file_t* mfu_src_file,
+        mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1273,7 +1275,7 @@ static int dsync_sync_files(
 
     /* Parse the source and destination paths. */
     int valid, copy_into_dir;
-    mfu_param_path_check_copy(1, src_path, dest_path, &valid, &copy_into_dir);
+    mfu_param_path_check_copy(1, src_path, dest_path, mfu_src_file, mfu_dst_file, &valid, &copy_into_dir);
 
     /* record copy_into_dir flag result from check_copy into
      * mfu copy options structure */
@@ -1316,7 +1318,8 @@ static int dsync_sync_files(
         if (rank == 0) {
             MFU_LOG(MFU_LOG_INFO, "Copying items to destination");
         }
-        tmp_rc = mfu_flist_copy(src_cp_list, 1, src_path, dest_path, mfu_copy_opts);
+        tmp_rc = mfu_flist_copy(src_cp_list, 1, src_path, dest_path, mfu_copy_opts,
+                                mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -1333,7 +1336,8 @@ static int dsync_sync_files(
             if (rank == 0) {
                 MFU_LOG(MFU_LOG_INFO, "Linking items in destination");
             }
-            tmp_rc = mfu_flist_hardlink(link_dst_list, link_path, dest_path, mfu_copy_opts);
+            tmp_rc = mfu_flist_hardlink(link_dst_list, link_path, dest_path,
+                                        mfu_copy_opts, mfu_src_file, mfu_dst_file);
             if (tmp_rc < 0) {
                 rc = -1;
             }
@@ -1503,7 +1507,9 @@ static int dsync_strmap_compare(
     mfu_copy_opts_t* mfu_copy_opts,
     const mfu_param_path* src_path,
     const mfu_param_path* dest_path,
-    const mfu_param_path* link_path)
+    const mfu_param_path* link_path,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1784,7 +1790,7 @@ static int dsync_strmap_compare(
         /* sync the files that are in the source and destination directories */
         tmp_rc = dsync_sync_files(src_map, dst_map,
             src_path, dest_path, link_path, dst_list, dst_remove_list,
-            link_dst_list, cp_list, mfu_copy_opts);
+            link_dst_list, cp_list, mfu_copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -1809,7 +1815,8 @@ static int dsync_strmap_compare(
             uint64_t dst_index = (uint64_t) dst_i;
 
             /* copy metadata values from source to destination, if needed */
-            tmp_rc = mfu_flist_file_sync_meta(src_list, src_index, dst_list, dst_index);
+            tmp_rc = mfu_flist_file_sync_meta(src_list, src_index, dst_list,
+                                              dst_index, mfu_dst_file);
             if (tmp_rc < 0) {
                 rc = -1;
             }
@@ -2958,6 +2965,10 @@ int main(int argc, char **argv)
     mfu_flist flist_tmp_src = mfu_flist_new();
     mfu_flist flist_tmp_dst = mfu_flist_new();
 
+    /* create new mfu_file objects */
+    mfu_file_t* mfu_src_file = mfu_file_new();
+    mfu_file_t* mfu_dst_file = mfu_file_new();
+
     mfu_param_path* linkpath = NULL;
     mfu_flist flist_tmp_link = MFU_FLIST_NULL;     
     if (options.link_dest != NULL) {
@@ -2989,7 +3000,7 @@ int main(int argc, char **argv)
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking source path");
     }
-    mfu_flist_walk_param_paths(1, srcpath, walk_opts, flist_tmp_src);
+    mfu_flist_walk_param_paths(1, srcpath, walk_opts, flist_tmp_src, mfu_src_file);
 
     /* check that we actually got something so that we don't delete
      * an entire target directory because of a typo on the source dir */
@@ -3016,14 +3027,14 @@ int main(int argc, char **argv)
     if (rank == 0) {
         MFU_LOG(MFU_LOG_INFO, "Walking destination path");
     }
-    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist_tmp_dst);
+    mfu_flist_walk_param_paths(1, destpath, walk_opts, flist_tmp_dst, mfu_dst_file);
 
     /* walk link-dest path if we have one */
     if (options.link_dest != NULL) {
         if (rank == 0) {
             MFU_LOG(MFU_LOG_INFO, "Walking link-dest path");
         }
-        mfu_flist_walk_param_paths(1, linkpath, walk_opts, flist_tmp_link);
+        mfu_flist_walk_param_paths(1, linkpath, walk_opts, flist_tmp_link, mfu_dst_file);
     }
 
     /* store src and dest path strings */
@@ -3061,7 +3072,7 @@ int main(int argc, char **argv)
 
     /* compare files in map_src with those in map_dst */
     int tmp_rc = dsync_strmap_compare(flist_src, map_src, flist_dst, map_dst, flist_link, map_link,
-        strlen(path_src), mfu_copy_opts, srcpath, destpath, linkpath);
+        strlen(path_src), mfu_copy_opts, srcpath, destpath, linkpath, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = 1;
     }
@@ -3100,6 +3111,10 @@ int main(int argc, char **argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file objects */
+    mfu_file_delete(&mfu_src_file);
+    mfu_file_delete(&mfu_dst_file);
+
     /* shut down */
     mfu_finalize();
     MPI_Finalize();
diff --git a/src/dwalk/dwalk.c b/src/dwalk/dwalk.c
index fe419945..69384dcd 100644
--- a/src/dwalk/dwalk.c
+++ b/src/dwalk/dwalk.c
@@ -572,9 +572,12 @@ int main(int argc, char** argv)
     /* create an empty file list with default values */
     mfu_flist flist = mfu_flist_new();
 
+    /* create new mfu_file object */
+    mfu_file_t* mfu_file = mfu_file_new();
+
     if (walk) {
         /* walk list of input paths */
-        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist);
+        mfu_flist_walk_param_paths(numpaths, paths, walk_opts, flist, mfu_file);
     }
     else {
         /* read data from cache file */
@@ -630,6 +633,9 @@ int main(int argc, char** argv)
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
+    /* delete file object */
+    mfu_file_delete(&mfu_file);
+
     /* shut down MPI */
     mfu_finalize();
     MPI_Finalize();

From 175cb9a256797c2e6ab9df2eea90d6b559ac5088 Mon Sep 17 00:00:00 2001
From: Adam Moody <moody20@llnl.gov>
Date: Fri, 17 Jul 2020 12:30:13 -0700
Subject: [PATCH 02/27] daos: style updates

Signed-off-by: Adam Moody <moody20@llnl.gov>
---
 src/common/mfu_util.c | 146 ++++++++++++++++++++++++------------------
 src/common/mfu_util.h |  19 ++++--
 src/dcp/dcp.c         | 120 +++++++++++++++++++---------------
 3 files changed, 163 insertions(+), 122 deletions(-)

diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 4499d5cc..3080902f 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -40,107 +40,125 @@ int mfu_progress_timeout = 10;
 #ifdef DAOS_SUPPORT
 bool daos_uuid_valid(const uuid_t uuid)
 {
-	return uuid && !uuid_is_null(uuid);
+    return uuid && !uuid_is_null(uuid);
 }
 
 /* Distribute process 0's pool or container handle to others. */
-void HandleDistribute(int rank, daos_handle_t *handle,
-                      daos_handle_t* poh, enum handleType type)
+void daos_bcast_handle(
+  int rank,              /* root rank for broadcast */
+  daos_handle_t* handle, /* handle value to be broadcasted */
+  daos_handle_t* poh,    /* daos pool for global2local conversion of container handle */
+  enum handleType type)  /* handle type: POOL_HANDLE or CONT_HANDLE */
 {
-        d_iov_t global;
-        int        rc;
-
-        global.iov_buf = NULL;
-        global.iov_buf_len = 0;
-        global.iov_len = 0;
-
-        if (rank == 0) {
-                /* Get the global handle size. */
-                if (type == POOL_HANDLE) {
-                    rc = daos_pool_local2global(*handle, &global);
-                } else {
-                    rc = daos_cont_local2global(*handle, &global);
-                }
-                if (rc != 0) {
-                    MFU_LOG(MFU_LOG_INFO, "Failed to get global handle size");
-                }
-        }
+    int rc;
 
-        MPI_Bcast(&global.iov_buf_len, 1, MPI_UINT64_T, 0, MPI_COMM_WORLD);
- 
-        global.iov_len = global.iov_buf_len;
-        global.iov_buf = malloc(global.iov_buf_len);
-        if (global.iov_buf == NULL) {
-            MPI_Abort(MPI_COMM_WORLD, -1);
+    d_iov_t global;
+    global.iov_buf     = NULL;
+    global.iov_buf_len = 0;
+    global.iov_len     = 0;
+
+    /* Get the global handle size. */
+    if (rank == 0) {
+        if (type == POOL_HANDLE) {
+            rc = daos_pool_local2global(*handle, &global);
+        } else {
+            rc = daos_cont_local2global(*handle, &global);
         }
-
-        if (rank == 0) {
-                if (type == POOL_HANDLE) {
-                    rc = daos_pool_local2global(*handle, &global);
-                } else {
-                    rc = daos_cont_local2global(*handle, &global);
-                }
-                if (rc != 0) {
-                    MFU_LOG(MFU_LOG_INFO, "Failed to create global handle");
-                }
+        if (rc != 0) {
+            MFU_ABORT(-1, "Failed to get global handle size");
         }
+    }
+
+    /* broadcast size of global handle */
+    MPI_Bcast(&global.iov_buf_len, 1, MPI_UINT64_T, 0, MPI_COMM_WORLD);
+
+    /* allocate memory to hold global handle value */
+    global.iov_len = global.iov_buf_len;
+    global.iov_buf = MFU_MALLOC(global.iov_buf_len);
+
+    /* convert from local handle to global handle */
+    if (rank == 0) {
+       if (type == POOL_HANDLE) {
+           rc = daos_pool_local2global(*handle, &global);
+       } else {
+           rc = daos_cont_local2global(*handle, &global);
+       }
+       if (rc != 0) {
+           MFU_ABORT(-1, "Failed to create global handle");
+       }
+    }
 
-        MPI_Bcast(global.iov_buf, global.iov_buf_len, MPI_BYTE, 0, MPI_COMM_WORLD);
+    /* broadcast global handle value */
+    MPI_Bcast(global.iov_buf, global.iov_buf_len, MPI_BYTE, 0, MPI_COMM_WORLD);
 
-        if (rank != 0) {
-                if (type == POOL_HANDLE) {
-                    rc = daos_pool_global2local(global, handle);
-                } else {
-                    rc = daos_cont_global2local(*poh, global, handle);
-                }
-                if (rc != 0) {
-                    MFU_LOG(MFU_LOG_INFO, "Failed to get local handle");
-                }
+    /* convert global handle to local value */
+    if (rank != 0) {
+        if (type == POOL_HANDLE) {
+            rc = daos_pool_global2local(global, handle);
+        } else {
+            rc = daos_cont_global2local(*poh, global, handle);
         }
+        if (rc != 0) {
+            MFU_ABORT(-1, "Failed to get local handle");
+        }
+    }
 
-        free(global.iov_buf);
+    /* free temporary buffer used to hold global handle value */
+    mfu_free(&global.iov_buf);
 }
 
-void daos_connect(int* rank, daos_handle_t* poh, daos_handle_t* coh,
-                  uuid_t* pool_uuid, uuid_t* cont_uuid, char* svc)
-{ 
+void daos_connect(
+  int rank,
+  const char* svc,
+  uuid_t pool_uuid,
+  uuid_t cont_uuid,
+  daos_handle_t* poh,
+  daos_handle_t* coh)
+{
     /* TODO: if src daos path and dst daos path are false 
-    *  skip connecting to daos pool */
-    int rc = 0;
-    if (*rank == 0) {
-        d_rank_list_t *svcl = NULL;
-        daos_pool_info_t pool_info;
-        daos_cont_info_t co_info;
+     * skip connecting to daos pool */
 
-        svcl = daos_rank_list_parse(svc, ":");
+    /* have rank 0 connect to the pool and container,
+     * we'll then broadcast the handle ids from rank 0 to everyone else */
+    if (rank == 0) {
+        d_rank_list_t* svcl = daos_rank_list_parse(svc, ":");
         if (svcl == NULL) {
- 	    MPI_Abort(MPI_COMM_WORLD, -1);
+            MFU_ABORT(-1, "Failed to parse DAOS rank list: '%s'", svc);
         }
 
-        /** Connect to DAOS pool */
-        rc = daos_pool_connect(*pool_uuid, NULL, svcl, DAOS_PC_RW,
+        /* Connect to DAOS pool */
+        daos_pool_info_t pool_info;
+        int rc = daos_pool_connect(pool_uuid, NULL, svcl, DAOS_PC_RW,
                                poh, &pool_info, NULL);
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to connect to pool");
         }
         d_rank_list_free(svcl);
 
-        rc = daos_cont_open(*poh, *cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+        /* attempt to open the daos container */
+        daos_cont_info_t co_info;
+        rc = daos_cont_open(*poh, cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
+
         /* If NOEXIST we create it */
         if (rc != 0) {
+            /* create the container */
             uuid_t cuuid;
             rc = dfs_cont_create(*poh, cuuid, NULL, NULL, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to create DFS container");
             }
+
+            /* try to open it again */
             rc = daos_cont_open(*poh, cuuid, DAOS_COO_RW, coh, &co_info, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
             }
         }
     }
-    HandleDistribute(*rank, poh, poh, POOL_HANDLE);
-    HandleDistribute(*rank, coh, poh, CONT_HANDLE);
+
+    /* broadcast pool and container handles from rank 0 */
+    daos_bcast_handle(rank, poh, poh, POOL_HANDLE);
+    daos_bcast_handle(rank, coh, poh, CONT_HANDLE);
 }
 #endif
 
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index d956e21d..3adf5d1e 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -118,13 +118,22 @@ extern int mfu_progress_timeout;
 bool daos_uuid_valid(const uuid_t uuid);
 
 /* Distribute process 0's pool or container handle to others. */
-void HandleDistribute(int rank, daos_handle_t *handle,
-                      daos_handle_t* poh, enum handleType type);
+void daos_bcast_handle(
+  int rank,              /* root rank for broadcast */
+  daos_handle_t* handle, /* handle value to be broadcasted */
+  daos_handle_t* poh,    /* daos pool for global2local conversion of container handle */
+  enum handleType type   /* handle type: POOL_HANDLE or CONT_HANDLE */
+);
 
 /* connect to DAOS pool, and then open container */
-void daos_connect(int* rank, daos_handle_t* poh,
-                  daos_handle_t* coh, uuid_t* pool_uuid,
-                  uuid_t* cont_uuid, char* svc);
+void daos_connect(
+  int rank,
+  const char* svc,
+  uuid_t pool_uuid,
+  uuid_t cont_uuid,
+  daos_handle_t* poh,
+  daos_handle_t* coh
+);
 #endif
 
 /* initialize mfu library,
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 6c963375..a3b5300f 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -23,27 +23,33 @@
 #include "mfu.h"
 
 #ifdef DAOS_SUPPORT
-static void daos_set_paths(int* rank, char** argpaths, uuid_t* src_pool_uuid,
-			   uuid_t* src_cont_uuid, uuid_t* dst_pool_uuid, uuid_t* dst_cont_uuid,
-                           char* dfs_prefix, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static void daos_set_paths(
+    char** argpaths,
+    const char* dfs_prefix,
+    uuid_t src_pool_uuid,
+    uuid_t src_cont_uuid,
+    uuid_t dst_pool_uuid,
+    uuid_t dst_cont_uuid,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
+    int rc = 0;
+
+    char* src_path = argpaths[0];
+    char* dst_path = argpaths[1];
+
     /* find out if a dfs_prefix is being used,
      * if so, then that means that the container
      * is not being copied from the root of the
      * UNS path  */
-    int rc = 0;
-    struct duns_attr_t dattr  = {0}; 
-    struct duns_attr_t ddattr = {0}; 
-    char* src_path            = argpaths[0];
-    char* dst_path            = argpaths[1];
-
-    /* assume both are daos paths for UNS, if resolve path
-     * doesn't succeed then set accordingly */
-    int src_rc = -1;
-    int dst_rc = -1;
     if (dfs_prefix == NULL) {
-        src_rc = duns_resolve_path(src_path, &dattr);
-        dst_rc = duns_resolve_path(dst_path, &ddattr);
+        /* assume both are daos paths for UNS, if resolve path
+         * doesn't succeed then set accordingly */
+        struct duns_attr_t src_dattr = {0}; 
+        struct duns_attr_t dst_dattr = {0}; 
+        int src_rc = duns_resolve_path(src_path, &src_dattr);
+        int dst_rc = duns_resolve_path(dst_path, &dst_dattr);
+
         /* Forward slash is "root" of container to walk
          * in daos. Cannot walk from Unified namespace
          * path given /tmp/dsikich/dfs, it is only used
@@ -53,42 +59,44 @@ static void daos_set_paths(int* rank, char** argpaths, uuid_t* src_pool_uuid,
         if (src_rc == 0 && dst_rc == 0) {
             mfu_src_file->type = DAOS;
             mfu_dst_file->type = DAOS;
-            uuid_copy(*src_pool_uuid, dattr.da_puuid);
-            uuid_copy(*src_cont_uuid, dattr.da_cuuid);
-            uuid_copy(*dst_pool_uuid, ddattr.da_puuid);
-            uuid_copy(*dst_cont_uuid, ddattr.da_cuuid);
-            argpaths[0]  = "/";
+            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
+            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
+            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
+            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
+            argpaths[0] = "/";
             argpaths[1] = "/";
         } else if (src_rc == 0) { 
             mfu_src_file->type = DAOS;
-            uuid_copy(*src_pool_uuid, dattr.da_puuid);
-            uuid_copy(*src_cont_uuid, dattr.da_cuuid);
-            argpaths[0]  = "/";
+            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
+            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
+            argpaths[0] = "/";
         } else if (dst_rc == 0) {
             mfu_dst_file->type = DAOS;
-            uuid_copy(*dst_pool_uuid, ddattr.da_puuid);
-            uuid_copy(*dst_cont_uuid, ddattr.da_cuuid);
-            argpaths[1]  = "/";
+            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
+            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
+            argpaths[1] = "/";
         }
+
         /* set daos io functions for src/dst paths */
     } else {
+        struct duns_attr_t dattr = {0}; 
         rc = duns_resolve_path(dfs_prefix, &dattr);
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS UNS path");
         }
+
         /* figure out if prefix is on dst or src for 
          * for copying container subsets */
-        char* src_ret;
-        src_ret = strstr(src_path, dfs_prefix);
+        char* src_ret = strstr(src_path, dfs_prefix);
         if (src_ret != NULL) {
             mfu_src_file->type = DAOS;
-            uuid_copy(*src_pool_uuid, dattr.da_puuid);
-            uuid_copy(*src_cont_uuid, dattr.da_cuuid);
+            uuid_copy(src_pool_uuid, dattr.da_puuid);
+            uuid_copy(src_cont_uuid, dattr.da_cuuid);
             argpaths[0] = src_path + strlen(dfs_prefix);
         } else {
             mfu_dst_file->type = DAOS;
-            uuid_copy(*dst_pool_uuid, dattr.da_puuid);
-            uuid_copy(*dst_cont_uuid, dattr.da_cuuid);
+            uuid_copy(dst_pool_uuid, dattr.da_puuid);
+            uuid_copy(dst_cont_uuid, dattr.da_cuuid);
             argpaths[1] = dst_path + strlen(dfs_prefix);
         }
     }
@@ -326,25 +334,25 @@ int main(int argc, char** argv)
 #endif
 #ifdef DAOS_SUPPORT
             case 'x':
-	        rc = uuid_parse(optarg, src_pool_uuid);
+                rc = uuid_parse(optarg, src_pool_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse source pool uuid: '%s'", optarg);
                     }
                     usage = 1;
                 }
-    	        break;
+                break;
             case 'D':
-	        rc = uuid_parse(optarg, dst_pool_uuid);
+                rc = uuid_parse(optarg, dst_pool_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse dst pool uuid: '%s'", optarg);
                     }
                     usage = 1;
                 }
-    	        break;
+                break;
             case 'y':
-	        rc = uuid_parse(optarg, src_cont_uuid);
+                rc = uuid_parse(optarg, src_cont_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse source cont uuid: '%s'", optarg);
@@ -352,9 +360,9 @@ int main(int argc, char** argv)
                     usage = 1;
                 }
                 mfu_src_file->type = DAOS;
-    	        break;
+                break;
             case 'Y':
-	        rc = uuid_parse(optarg, dst_cont_uuid);
+                rc = uuid_parse(optarg, dst_cont_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse dst cont uuid: '%s'", optarg);
@@ -362,13 +370,13 @@ int main(int argc, char** argv)
                     usage = 1;
                 }
                 mfu_dst_file->type = DAOS;
-    	        break;
+                break;
             case 'z':
-    	        svc = MFU_STRDUP(optarg);
-    	        break;
+                svc = MFU_STRDUP(optarg);
+                break;
             case 'X':
-    	        dfs_prefix = MFU_STRDUP(optarg);
-    	        break;
+                dfs_prefix = MFU_STRDUP(optarg);
+                break;
 #endif
             case 'i':
                 inputname = MFU_STRDUP(optarg);
@@ -454,8 +462,8 @@ int main(int argc, char** argv)
      * prefix since the path is mapped to the root
      * of the container in the DAOS DFS mount */
     if (!daos_uuid_valid(src_pool_uuid) || !daos_uuid_valid(dst_pool_uuid)) {
-        daos_set_paths(&rank, argpaths, &src_pool_uuid, &src_cont_uuid,
-            &dst_pool_uuid, &dst_cont_uuid, dfs_prefix, mfu_src_file, mfu_dst_file);
+        daos_set_paths(argpaths, dfs_prefix, src_pool_uuid, src_cont_uuid,
+            dst_pool_uuid, dst_cont_uuid, mfu_src_file, mfu_dst_file);
     }
 
     /* check if DAOS source and destination containers are in the same pool */
@@ -468,15 +476,15 @@ int main(int argc, char** argv)
 
     /* connect to DAOS source pool if uuid is valid */
     if (mfu_src_file->type == DAOS) {
-       /* if DAOS source pool uuid is valid, then set source file type to DAOS */
-        daos_connect(&rank, &src_poh, &src_coh, &src_pool_uuid, &src_cont_uuid, svc); 
+        /* if DAOS source pool uuid is valid, then set source file type to DAOS */
+        daos_connect(rank, svc, src_pool_uuid, src_cont_uuid, &src_poh, &src_coh); 
     }
 
     if (mfu_dst_file->type == DAOS) {
         if (daos_uuid_valid(dst_pool_uuid) && !same_pool) {
             /* if DAOS is the source and destination type, and containers are in different pools,
-             *  then connect to the second pool */
-            daos_connect(&rank, &dst_poh, &dst_coh, &dst_pool_uuid, &dst_cont_uuid, svc); 
+             * then connect to the second pool */
+            daos_connect(rank, svc, dst_pool_uuid, dst_cont_uuid, &dst_poh, &dst_coh); 
         } else {
             /* if DAOS is source and destination type, and containers are in the same pool,
              * then pool is already connected, so we just need to open and/or create the container */
@@ -484,20 +492,26 @@ int main(int argc, char** argv)
                 /* create container in same pool */
                 daos_cont_info_t co_info;
                 rc = daos_cont_open(src_poh, dst_cont_uuid, DAOS_COO_RW, &dst_coh, &co_info, NULL);
-	        if (rc != 0) {
-                    /* If NOEXIST we create it */
+
+                /* If NOEXIST we create it */
+                if (rc != 0) {
+                    /* create the container */
                     uuid_t cuuid;
                     rc = dfs_cont_create(src_poh, cuuid, NULL, NULL, NULL);
                     if (rc != 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to create DFS2 container");
                     }
+
+                    /* try to open it again */
                     rc = daos_cont_open(src_poh, cuuid, DAOS_COO_RW, &dst_coh, &co_info, NULL);
                     if (rc != 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to open DFS2 container");
                     }
                 }
             }
-            HandleDistribute(rank, &dst_coh, &src_poh, CONT_HANDLE);
+
+            /* broadcast container handle from rank 0 */
+            daos_bcast_handle(rank, &dst_coh, &src_poh, CONT_HANDLE);
         }
     }
 

From 6f95a3b514549fa3b5f6af97bbc2dd5b8b90b3a1 Mon Sep 17 00:00:00 2001
From: Danielle Sikich <danielle.sikich@intel.com>
Date: Tue, 21 Jul 2020 00:17:30 +0000
Subject: [PATCH 03/27] fixes #350

On error the daos_read and daos_write call should set
errno then return negative one.

Signed-off-by: Danielle Sikich <danielle.sikich@intel.com>
---
 src/common/mfu_io.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index ad730ee8..13b72938 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -790,7 +790,7 @@ ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file
         MFU_LOG(MFU_LOG_ERR, "dfs_read %s failed (%d %s)",
                 file, rc, strerror(rc));
         errno = rc;
-        rc = -1;
+        return -1;
     }
     mfu_file->offset += (daos_off_t)got_size;
     return (ssize_t)got_size;
@@ -892,7 +892,7 @@ ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* m
         MFU_LOG(MFU_LOG_ERR, "dfs_write %s failed (%d %s)",
                 file, rc, strerror(rc));
         errno = rc;
-        rc = -1;
+        return -1;
     }
     mfu_file->offset += (daos_off_t)size;
     return (ssize_t)size;

From db3e7177dc1c8220fef9a389bfc26a9e8d67b2c8 Mon Sep 17 00:00:00 2001
From: Danielle Sikich <danielle.sikich@intel.com>
Date: Thu, 23 Jul 2020 17:38:16 +0000
Subject: [PATCH 04/27] fixes #351

Make sgl and iov variables local to the daos_read and
daos_write functions.

Signed-off-by: Danielle Sikich <danielle.sikich@intel.com>
---
 src/common/mfu_flist_copy.c | 31 -------------------------------
 src/common/mfu_io.c         | 27 ++++++++++++++++++++++-----
 src/common/mfu_param_path.h |  1 -
 3 files changed, 22 insertions(+), 37 deletions(-)

diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index d4e133ab..d1345b68 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -1604,35 +1604,10 @@ static int mfu_copy_file_normal(
         return -1;
     }
 
-    /* declare daos vars */
-#ifdef DAOS_SUPPORT
-    daos_size_t got_size;
-    d_sg_list_t sgl;
-    d_iov_t     iov;
-#endif
-
     /* set buffer and buffer size */
     size_t buf_size = mfu_copy_opts->block_size;
     void* buf       = mfu_copy_opts->block_buf1;
 
-    /* set daos vars and buffers */
-#ifdef DAOS_SUPPORT
-    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
-        sgl.sg_nr = 1;
-        D_ALLOC(buf, buf_size);
-        D_ASSERT(buf != NULL);
-        d_iov_set(&iov, buf, buf_size);
-        sgl.sg_iovs = &iov;
-        sgl.sg_nr_out = 1;
-        if (mfu_src_file->type == DAOS) {
-            mfu_src_file->sgl = &sgl;
-        }
-        if (mfu_dst_file->type == DAOS) {
-            mfu_dst_file->sgl = &sgl;
-        }
-    }
-#endif
-
     /* write data */
     size_t total_bytes = 0;
     while(total_bytes < (size_t)length) {
@@ -1774,12 +1749,6 @@ static int mfu_copy_file_normal(
 
     /* we don't bother closing the file because our cache does it for us */
 
-#ifdef DAOS_SUPPORT
-    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
-        D_FREE(buf);
-    }
-#endif
-
     return 0;
 }
 
diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 13b72938..38f59165 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -784,8 +784,17 @@ ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file
 {
 #ifdef DAOS_SUPPORT
     daos_size_t got_size;
-    mfu_file->sgl->sg_iovs[0].iov_len = size;
-    int rc = dfs_read(mfu_file->dfs, mfu_file->obj, mfu_file->sgl, mfu_file->offset, &got_size, NULL); 
+
+    d_sg_list_t sgl;
+    d_iov_t     iov;
+
+    sgl.sg_nr = 1;
+    d_iov_set(&iov, buf, size);
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+    sgl.sg_iovs[0].iov_len = size;
+
+    int rc = dfs_read(mfu_file->dfs, mfu_file->obj, &sgl, mfu_file->offset, &got_size, NULL); 
     if (rc) {
         MFU_LOG(MFU_LOG_ERR, "dfs_read %s failed (%d %s)",
                 file, rc, strerror(rc));
@@ -886,8 +895,16 @@ ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size)
 ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
-    mfu_file->sgl->sg_iovs[0].iov_len = size;
-    int rc = dfs_write(mfu_file->dfs, mfu_file->obj, mfu_file->sgl, mfu_file->offset, NULL); 
+    d_sg_list_t sgl;
+    d_iov_t     iov;
+
+    sgl.sg_nr = 1;
+    d_iov_set(&iov, buf, size);
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+    sgl.sg_iovs[0].iov_len = size;
+
+    int rc = dfs_write(mfu_file->dfs, mfu_file->obj, &sgl, mfu_file->offset, NULL); 
     if (rc) {
         MFU_LOG(MFU_LOG_ERR, "dfs_write %s failed (%d %s)",
                 file, rc, strerror(rc));
@@ -1042,7 +1059,7 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file) {
 
     /* only call mkdir if the dir_name is not the root DFS directory */
     if (strcmp(dir_name, "/") != 0) {
-        rc = dfs_mkdir(mfu_file->dfs, parent, name, S_IRWXU, 0);
+        rc = dfs_mkdir(mfu_file->dfs, parent, name, mode, 0);
     }
 
     if (rc) {
diff --git a/src/common/mfu_param_path.h b/src/common/mfu_param_path.h
index ad71b964..e1ab1167 100644
--- a/src/common/mfu_param_path.h
+++ b/src/common/mfu_param_path.h
@@ -59,7 +59,6 @@ typedef struct {
     bool        only_daos;
 #ifdef DAOS_SUPPORT
     /* DAOS specific variables for I/O */
-    d_sg_list_t* sgl;
     daos_off_t   offset;
     dfs_obj_t*   obj;
     dfs_t*       dfs;

From 3847d119bf4b5d5aba15f50aecbbe08bc1d18d36 Mon Sep 17 00:00:00 2001
From: Danielle Sikich <danielle.sikich@intel.com>
Date: Thu, 20 Aug 2020 01:17:23 +0000
Subject: [PATCH 05/27] fix #357

Use strncmp instead of strstr to check if dfs_prefix is a
prefix of the src or dst path. Using strstr was incorrect
because it was checking for a matching substring instead
of a prefix.

Signed-off-by: Danielle Sikich <danielle.sikich@intel.com>
---
 src/dcp/dcp.c | 22 ++++++++++++++++++----
 1 file changed, 18 insertions(+), 4 deletions(-)

diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index a3b5300f..f9fa3b17 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -23,6 +23,21 @@
 #include "mfu.h"
 
 #ifdef DAOS_SUPPORT
+static bool daos_check_prefix(char* path, const char* dfs_prefix) 
+{
+    bool is_prefix = false;
+    /* figure out if dfs_prefix is a prefix of the file path */
+    int prefix_len = strlen(dfs_prefix);
+    if (strncmp(path, dfs_prefix, prefix_len) == 0) {
+        /* if we have another character, it must be '/' */
+        if (strlen(path) > prefix_len &&
+            path[prefix_len] == '/') {
+            is_prefix = true;
+        }
+    }
+    return is_prefix;
+}
+
 static void daos_set_paths(
     char** argpaths,
     const char* dfs_prefix,
@@ -86,14 +101,13 @@ static void daos_set_paths(
         }
 
         /* figure out if prefix is on dst or src for 
-         * for copying container subsets */
-        char* src_ret = strstr(src_path, dfs_prefix);
-        if (src_ret != NULL) {
+         * copying container subsets */
+	if (check_prefix(src_path, dfs_prefix)) {
             mfu_src_file->type = DAOS;
             uuid_copy(src_pool_uuid, dattr.da_puuid);
             uuid_copy(src_cont_uuid, dattr.da_cuuid);
             argpaths[0] = src_path + strlen(dfs_prefix);
-        } else {
+        } else if (check_prefix(dst_path, dfs_prefix)) {
             mfu_dst_file->type = DAOS;
             uuid_copy(dst_pool_uuid, dattr.da_puuid);
             uuid_copy(dst_cont_uuid, dattr.da_cuuid);

From e7ee207a1e2174ed87cca0e7ab794d94bb750d35 Mon Sep 17 00:00:00 2001
From: Danielle Sikich <danielle.sikich@intel.com>
Date: Thu, 20 Aug 2020 16:52:50 +0000
Subject: [PATCH 06/27] Add documentation about DAOS Support

Signed-off-by: Danielle Sikich <danielle.sikich@intel.com>
---
 DAOS-Support.md   | 99 +++++++++++++++++++++++++++++++++++++++++++++++
 README.md         |  4 ++
 doc/rst/build.rst | 21 ++++++++++
 3 files changed, 124 insertions(+)
 create mode 100644 DAOS-Support.md

diff --git a/DAOS-Support.md b/DAOS-Support.md
new file mode 100644
index 00000000..69144be7
--- /dev/null
+++ b/DAOS-Support.md
@@ -0,0 +1,99 @@
+# DAOS Support
+
+[DAOS](https://github.com/daos-stack/daos) is supported as a backend storage system in dcp. The build instructions for
+enabling DAOS support can be found here:
+[Enable DAOS](https://github.com/hpc/mpifileutils/doc/rst/build.rst).
+
+The following are ways that DAOS can be used to move data both across DAOS as well as POSIX
+filesystems:
+
+1. DAOS  -> POSIX
+2. POSIX -> DAOS
+3. DAOS  -> DAOS
+
+## DAOS Data Movement Use Cases
+
+In each use case, it is assumed the the pools used already exist. Also,
+only one DAOS source is supported.
+
+1. **DAOS Destination**
+    * POSIX container may or may not exist already
+
+2. **DAOS Source**
+    * POSIX source container exists
+
+3. **DAOS Source and Destination**
+    * Copy across two different pools
+    * Copy across containers in the same pool
+
+## DAOS Data Movement Examples
+
+#### Example One
+
+Show a copy from a regular /tmp source path to a DAOS container. 
+A DAOS Unified Namespace path is used as the destination, which allows you to lookup
+the pool and container UUID from the path. This feature can only be used if the 
+container is created with a path.
+
+```shell
+$ mpirun -np 3 --daos-dst-svcl 0 -v /tmp/$USER/s /tmp/$USER/conts/p1cont1
+[2020-04-23T17:04:15]   Items: 6
+[2020-04-23T17:04:15]  Directories: 3
+[2020-04-23T17:04:15]  Files: 3
+[2020-04-23T17:04:15]  Links: 0
+```
+
+#### Example Two
+
+Show a copy where the pool and container UUID are passed in directly. This option
+can be used if the type of container is POSIX, but the container was not created
+with a path. The destination is the relative path within the DAOS container, which 
+in this example is the root of the container. 
+
+```shell
+$ mpirun -np 3 dcp --daos-dst-svcl 0 -v --daos-dst-pool $pool --daos-dst-cont $p1cont1 /tmp/$USER/s /
+[2020-04-23T17:17:51] Items: 6
+[2020-04-23T17:17:51]  Directories: 3
+[2020-04-23T17:17:51]  Files: 3
+[2020-04-23T17:17:51]  Links: 0
+```
+#### Example Three
+
+Show a copy from one DAOS container to another container that exists in the same
+pool. A DAOS Unified Namespace path is used as the source and the destination.
+
+```shell
+$ mpirun -np 3 dcp --daos-src-svcl 0 --daos-dst-svcl 0 -v /tmp/$USER/conts/p1cont1 /tmp/$USER/conts/p1cont2
+[2020-04-23T17:04:15] Items: 6
+[2020-04-23T17:04:15]  Directories: 3
+[2020-04-23T17:04:15]  Files: 3
+[2020-04-23T17:04:15]  Links: 0
+```
+
+#### Example Four
+
+This example passes in the pool and container UUID directly. The destination path
+is the relative path within the DAOS container, which in this case is a subset of 
+the DAOS container. 
+
+```shell
+$ mpirun -np 3 dcp --daos-src-svcl 0 --daos-dst-svcl 0 -v --daos-src-pool $pool --daos-src-cont $p1cont1 \
+--daos-dst-pool $pool2 --daos-dst-cont $p2cont2 /s/biggerfile /
+[2020-04-28T00:47:59] Items: 1
+[2020-04-28T00:47:59]  Directories: 0
+[2020-04-28T00:47:59]  Files: 1
+[2020-04-28T00:47:59]  Links: 0
+```
+
+#### Example Five
+
+This example copies data from a DAOS container to /tmp, where a DAOS
+Unified Namespace path is used as the source. 
+
+```shell
+$ mpirun -np 3 dcp --daos-src-svcl 0 -v /tmp/$USER/conts/p1cont1 /tmp/$USER/d
+[2020-04-23T17:17:51] Items: 6
+[2020-04-23T17:17:51]  Directories: 3
+[2020-04-23T17:17:51]  Files: 3
+[2020-04-23T17:17:51]  Links: 0
+```
diff --git a/README.md b/README.md
index aa5f686f..a00189d1 100644
--- a/README.md
+++ b/README.md
@@ -3,6 +3,10 @@ mpiFileUtils provides both a library called [libmfu](src/common/README.md) and a
 
 Documentation is available on [ReadTheDocs](http://mpifileutils.readthedocs.io).
 
+## DAOS Support
+
+mpiFileUtils supports a DAOS backend for dcp. Details and usage examples are provided in [DAOS Support](DAOS-Support.md).
+ 
 ## Contributors
 We welcome contributions to the project.  For details on how to help, see our [Contributor Guide](.github/CONTRIBUTING.md)
 
diff --git a/doc/rst/build.rst b/doc/rst/build.rst
index 99a8ad90..561ec68f 100644
--- a/doc/rst/build.rst
+++ b/doc/rst/build.rst
@@ -99,6 +99,27 @@ or to build the latest mpiFileUtils from the master branch:
      -DCMAKE_INSTALL_PREFIX=../install
    make install
 
+build latest mpiFileUtils from the master branch with DAOS Support:
+
+.. code-block:: Bash
+
+   git clone https://github.com/hpc/mpifileutils
+   mkdir build install
+   cd build
+   cmake ../mpifileutils \
+     -DWITH_DTCMP_PREFIX=../install \
+     -DWITH_LibCircle_PREFIX=../install \
+     -DCMAKE_INSTALL_PREFIX=../install
+     -DWITH_CART_PREFIX=</path/to/daos/>
+     -DWITH_DAOS_PREFIX=</path/to/daos/>
+     -DCMAKE_INSTALL_PREFIX=../install
+     -DENABLE_DAOS=ON;
+   make install
+
+The above build with DAOS option also assumes you have already installed DAOS. If
+CART and DAOS are installed under a standard system path then specifying the CART
+and DAOS paths is unnecessary. 
+
 To enable Lustre, GPFS, and experimental tools, add the following flags during CMake:
 
 .. code-block:: Bash

From b9eca8e89d41097172836cf16a938d3094e1dcbe Mon Sep 17 00:00:00 2001
From: Danielle Sikich <danielle.sikich@intel.com>
Date: Tue, 25 Aug 2020 00:01:41 +0000
Subject: [PATCH 07/27] Add option for daos-dst-svcl

Previously you could only provide one service level to DAOS,
but we should be able to pass a service level for the
source and destination pools explicitly.

Signed-off-by: Danielle Sikich <danielle.sikich@intel.com>
---
 src/dcp/dcp.c | 54 +++++++++++++++++++++++++++++++--------------------
 1 file changed, 33 insertions(+), 21 deletions(-)

diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index f9fa3b17..20c88539 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -102,12 +102,12 @@ static void daos_set_paths(
 
         /* figure out if prefix is on dst or src for 
          * copying container subsets */
-	if (check_prefix(src_path, dfs_prefix)) {
+	if (daos_check_prefix(src_path, dfs_prefix)) {
             mfu_src_file->type = DAOS;
             uuid_copy(src_pool_uuid, dattr.da_puuid);
             uuid_copy(src_cont_uuid, dattr.da_cuuid);
             argpaths[0] = src_path + strlen(dfs_prefix);
-        } else if (check_prefix(dst_path, dfs_prefix)) {
+        } else if (daos_check_prefix(dst_path, dfs_prefix)) {
             mfu_dst_file->type = DAOS;
             uuid_copy(dst_pool_uuid, dattr.da_puuid);
             uuid_copy(dst_cont_uuid, dattr.da_cuuid);
@@ -175,17 +175,18 @@ void print_usage(void)
     printf("      --daos-dst-pool      - DAOS destination pool \n");
     printf("      --daos-src-cont      - DAOS source container \n");
     printf("      --daos-dst-cont      - DAOS destination container \n");
-    printf("      --daos-svcl          - DAOS service level \n");
+    printf("      --daos-src-svcl      - DAOS service level used by source DAOS pool \n");
+    printf("      --daos-dst-svcl      - DAOS service level used by destination DAOS pool \n");
     printf("      --daos-prefix        - DAOS prefix for unified namespace path \n");
-    printf("  -i, --input <file>  - read source list from file\n");
-    printf("  -k, --chunksize     - work size per task in bytes (default 1MB)\n");
-    printf("  -p, --preserve      - preserve permissions, ownership, timestamps, extended attributes\n");
-    printf("  -s, --synchronous   - use synchronous read/write calls (O_DIRECT)\n");
-    printf("  -S, --sparse        - create sparse files when possible\n");
-    printf("      --progress <N>  - print progress every N seconds\n");
-    printf("  -v, --verbose       - verbose output\n");
-    printf("  -q, --quiet         - quiet output\n");
-    printf("  -h, --help          - print usage\n");
+    printf("  -i, --input <file>       - read source list from file\n");
+    printf("  -k, --chunksize          - work size per task in bytes (default 1MB)\n");
+    printf("  -p, --preserve           - preserve permissions, ownership, timestamps, extended attributes\n");
+    printf("  -s, --synchronous        - use synchronous read/write calls (O_DIRECT)\n");
+    printf("  -S, --sparse             - create sparse files when possible\n");
+    printf("      --progress <N>       - print progress every N seconds\n");
+    printf("  -v, --verbose            - verbose output\n");
+    printf("  -q, --quiet              - quiet output\n");
+    printf("  -h, --help               - print usage\n");
     printf("For more information see https://mpifileutils.readthedocs.io.\n");
     printf("\n");
     fflush(stdout);
@@ -232,7 +233,8 @@ int main(int argc, char** argv)
     daos_handle_t dst_coh = DAOS_HDL_INVAL;
     dfs_t *dfs1           = NULL;
     dfs_t *dfs2           = NULL;
-    char* svc             = NULL;
+    char* src_svc         = NULL;
+    char* dst_svc         = NULL;
     char* dfs_prefix      = NULL;
 
     /* initalize value of DAOS UUID's to NULL with uuid_clear */
@@ -255,7 +257,8 @@ int main(int argc, char** argv)
         {"daos-dst-pool"        , required_argument, 0, 'D'},
         {"daos-src-cont"        , required_argument, 0, 'y'},
         {"daos-dst-cont"        , required_argument, 0, 'Y'},
-        {"daos-svcl"            , required_argument, 0, 'z'},
+        {"daos-src-svcl"        , required_argument, 0, 'z'},
+        {"daos-dst-svcl"        , required_argument, 0, 'Z'},
         {"daos-prefix"          , required_argument, 0, 'X'},
         {"input"                , required_argument, 0, 'i'},
         {"chunksize"            , required_argument, 0, 'k'},
@@ -386,7 +389,10 @@ int main(int argc, char** argv)
                 mfu_dst_file->type = DAOS;
                 break;
             case 'z':
-                svc = MFU_STRDUP(optarg);
+                src_svc = MFU_STRDUP(optarg);
+                break;
+            case 'Z':
+                dst_svc = MFU_STRDUP(optarg);
                 break;
             case 'X':
                 dfs_prefix = MFU_STRDUP(optarg);
@@ -491,17 +497,23 @@ int main(int argc, char** argv)
     /* connect to DAOS source pool if uuid is valid */
     if (mfu_src_file->type == DAOS) {
         /* if DAOS source pool uuid is valid, then set source file type to DAOS */
-        daos_connect(rank, svc, src_pool_uuid, src_cont_uuid, &src_poh, &src_coh); 
+        daos_connect(rank, src_svc, src_pool_uuid, src_cont_uuid, &src_poh, &src_coh); 
     }
 
     if (mfu_dst_file->type == DAOS) {
-        if (daos_uuid_valid(dst_pool_uuid) && !same_pool) {
+        if (!same_pool) {
             /* if DAOS is the source and destination type, and containers are in different pools,
              * then connect to the second pool */
-            daos_connect(rank, svc, dst_pool_uuid, dst_cont_uuid, &dst_poh, &dst_coh); 
+            daos_connect(rank, dst_svc, dst_pool_uuid, dst_cont_uuid, &dst_poh, &dst_coh); 
         } else {
-            /* if DAOS is source and destination type, and containers are in the same pool,
-             * then pool is already connected, so we just need to open and/or create the container */
+            /* Containers are using the same pool uuid.
+             * This is unlikely to ever happen but we can print an error just in case */
+            if (dst_svc != NULL && src_svc != NULL) {
+                if (strcmp(dst_svc, src_svc) != 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Using same pool uuid with different svcl's");
+                    return 1;
+                }
+            }
             if (rank == 0) {
                 /* create container in same pool */
                 daos_cont_info_t co_info;
@@ -572,7 +584,7 @@ int main(int argc, char** argv)
 
         /* process each path */
 
-        mfu_param_path_set_all(numpaths, argpaths, paths);
+        mfu_param_path_set_all(numpaths, (const char**)argpaths, paths);
 
         /* advance to next set of options */
         optind += numpaths;

From df0f44472b3a8ec2c656e92c9cdf2fc7570a40b2 Mon Sep 17 00:00:00 2001
From: Adam Moody <moody20@llnl.gov>
Date: Mon, 31 Aug 2020 15:47:16 -0700
Subject: [PATCH 08/27] add link to overview talk

Signed-off-by: Adam Moody <moody20@llnl.gov>
---
 doc/rst/index.rst | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/doc/rst/index.rst b/doc/rst/index.rst
index a7d77297..4cb02f41 100644
--- a/doc/rst/index.rst
+++ b/doc/rst/index.rst
@@ -20,6 +20,8 @@ jobs like copy, remove, and compare for such datasets, providing speedups of up
 to 50x. The libmfu library simplifies the creation of new tools
 and it can be called directly from within HPC applications.
 
+Video Overview: `"Scalable Management of HPC Datasets with mpiFileUtils" <https://youtu.be/cxjPOUS-ZBY>`_, HPCKP'20.
+
 User Guide
 ***************************
 

From a9cd09d6a4412b5a5e87419c8423d6d79f32caab Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Wed, 2 Sep 2020 22:06:22 +0000
Subject: [PATCH 09/27] Refined daos_set_paths to allow UNS on src and dst

daos_set_paths not properly allows a UNS path on the
source or destination when the other uses a prefix.

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/dcp/dcp.c | 84 +++++++++++++++++++++++++++------------------------
 1 file changed, 44 insertions(+), 40 deletions(-)

diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 20c88539..8a2962ff 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -53,65 +53,69 @@ static void daos_set_paths(
     char* src_path = argpaths[0];
     char* dst_path = argpaths[1];
 
+    bool prefix_on_src = false;
+    bool prefix_on_dst = false;
+
     /* find out if a dfs_prefix is being used,
      * if so, then that means that the container
      * is not being copied from the root of the
      * UNS path  */
-    if (dfs_prefix == NULL) {
-        /* assume both are daos paths for UNS, if resolve path
-         * doesn't succeed then set accordingly */
-        struct duns_attr_t src_dattr = {0}; 
-        struct duns_attr_t dst_dattr = {0}; 
-        int src_rc = duns_resolve_path(src_path, &src_dattr);
-        int dst_rc = duns_resolve_path(dst_path, &dst_dattr);
-
-        /* Forward slash is "root" of container to walk
-         * in daos. Cannot walk from Unified namespace
-         * path given /tmp/dsikich/dfs, it is only used
-         * to lookup pool/cont uuids, and tells you
-         * if that path is mapped to pool/cont uuid in
-         * DAOS */
-        if (src_rc == 0 && dst_rc == 0) {
-            mfu_src_file->type = DAOS;
-            mfu_dst_file->type = DAOS;
-            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
-            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
-            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
-            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
-            argpaths[0] = "/";
-            argpaths[1] = "/";
-        } else if (src_rc == 0) { 
-            mfu_src_file->type = DAOS;
-            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
-            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
-            argpaths[0] = "/";
-        } else if (dst_rc == 0) {
-            mfu_dst_file->type = DAOS;
-            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
-            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
-            argpaths[1] = "/";
-        }
-
-        /* set daos io functions for src/dst paths */
-    } else {
-        struct duns_attr_t dattr = {0}; 
+    if (dfs_prefix != NULL) {
+        struct duns_attr_t dattr = {0};
         rc = duns_resolve_path(dfs_prefix, &dattr);
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS UNS path");
         }
 
-        /* figure out if prefix is on dst or src for 
+        /* figure out if prefix is on dst or src for
          * copying container subsets */
-	if (daos_check_prefix(src_path, dfs_prefix)) {
+        if (daos_check_prefix(src_path, dfs_prefix)) {
             mfu_src_file->type = DAOS;
             uuid_copy(src_pool_uuid, dattr.da_puuid);
             uuid_copy(src_cont_uuid, dattr.da_cuuid);
             argpaths[0] = src_path + strlen(dfs_prefix);
+            prefix_on_src = true;
         } else if (daos_check_prefix(dst_path, dfs_prefix)) {
             mfu_dst_file->type = DAOS;
             uuid_copy(dst_pool_uuid, dattr.da_puuid);
             uuid_copy(dst_cont_uuid, dattr.da_cuuid);
             argpaths[1] = dst_path + strlen(dfs_prefix);
+            prefix_on_dst = true;
+        }
+    }
+
+    /* Forward slash is "root" of container to walk
+     * in daos. Cannot walk from Unified namespace
+     * path given /tmp/dsikich/dfs, it is only used
+     * to lookup pool/cont uuids, and tells you
+     * if that path is mapped to pool/cont uuid in
+     * DAOS 
+     *
+     * For each of the source and destination,
+     * if it is not using a prefix then assume
+     * is is a daos path for UNS. If resolve path
+     * doesn't succeed then set accordingly */
+    if (!prefix_on_src) {
+        struct duns_attr_t src_dattr = {0};
+        int src_rc = duns_resolve_path(src_path, &src_dattr);
+        
+        if (src_rc == 0) {
+            mfu_src_file->type = DAOS;
+            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
+            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
+            argpaths[0] = "/";
+        }
+    }
+
+    if (!prefix_on_dst) {
+        struct duns_attr_t dst_dattr = {0};
+        int dst_rc = duns_resolve_path(dst_path, &dst_dattr);
+
+        if (dst_rc == 0) {
+            mfu_dst_file->type = DAOS;
+            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
+            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
+            argpaths[1] = "/";
         }
     }
 }

From a2ede7adff73b941e9fb4159e9d52855522106df Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Wed, 2 Sep 2020 22:06:22 +0000
Subject: [PATCH 10/27] daos: dcp: enhanced error checking

**common/mfu_errors.h**
- New file
- Defines some generic error codes, codes for dcp, and codes for DAOS
- Defines MFU_ERRF and MFU_ERRP for printing the error codes.
  - Formatted as: MFU_ERR(#)
  - Could be improved in the future to print the"string" error code instead of just MFU_ERR

**common/mfu_io**
- Defined daos_access

**common/mfu_param_path.c**
- mfu_param_path_check_copy - Return on DAOS error

**common/mfu_util**
- daos_connect
  - Added flag for whether or not to connect to pool
  - Added flag for whether or not to auto-create the destination container
    - No longer creates the source container automatically
  - These flags allow a centralized way to capture errors. I.e. only one bcast is needed for pool connection, cont connection, cont creation
  - Rank 0 now tracks and broadcasts any errors before trying to share the handles
  - Function returns an error

**dcp/dcp.c**
- Use the new error codes from mfu_error.h
- DAOS errors are generally handled more precisely
  - Each process tracks local errors, and stops making DAOS calls once it has run into an error
  - Allreduce on local DAOS errors, so all processes will know to exit
  - Check DAOS arguments before trying to make DAOS calls
  - Refactored daos_connect calls to better capture errors and exit if found
  - More gracefully handle a failed daos_init call
  - Exit if DAOS source is DAOS destination

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/CMakeLists.txt   |   1 +
 src/common/mfu_errors.h     |  32 +++
 src/common/mfu_io.c         |  30 ++-
 src/common/mfu_io.h         |   2 +-
 src/common/mfu_param_path.c |  15 +-
 src/common/mfu_util.c       |  79 ++++--
 src/common/mfu_util.h       |   6 +-
 src/dcp/dcp.c               | 463 ++++++++++++++++++++++++++----------
 8 files changed, 463 insertions(+), 165 deletions(-)
 create mode 100644 src/common/mfu_errors.h

diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt
index f04e38a4..9bea346d 100644
--- a/src/common/CMakeLists.txt
+++ b/src/common/CMakeLists.txt
@@ -1,6 +1,7 @@
 # todo re-asses if all of these must be *installed*
 LIST(APPEND libmfu_install_headers
   mfu.h
+  mfu_errors.h
   mfu_bz2.h
   mfu_flist.h
   mfu_flist_internal.h
diff --git a/src/common/mfu_errors.h b/src/common/mfu_errors.h
new file mode 100644
index 00000000..ae80453a
--- /dev/null
+++ b/src/common/mfu_errors.h
@@ -0,0 +1,32 @@
+/* Defines common error codes */
+
+/* enable C++ codes to include this header directly */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef MFU_ERRORS_H
+#define MFU_ERRORS_H
+
+/* Generic error codes */
+#define MFU_ERR           1000
+#define MFU_ERR_INVAL_ARG 1001
+
+/* DCP-specific error codes */
+#define MFU_ERR_DCP      1100
+#define MFU_ERR_DCP_COPY 1101
+
+/* DAOS-specific error codes*/
+#define MFU_ERR_DAOS            4000
+#define MFU_ERR_DAOS_INVAL_ARG  4001
+
+/* Error macros */
+#define MFU_ERRF "%s(%d)"
+#define MFU_ERRP(rc) "MFU_ERR", rc
+
+#endif /* MFU_ERRORS_H */
+
+/* enable C++ codes to include this header directly */
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 38f59165..4afd5d6a 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -199,7 +199,7 @@ int mfu_file_access(const char* path, int amode, mfu_file_t* mfu_file)
         int rc = mfu_access(path, amode);
         return rc;
     } else if (mfu_file->type == DAOS) {
-        int rc = daos_access(path, amode);
+        int rc = daos_access(path, amode, mfu_file);
         return rc;
     } else {
         MFU_ABORT(-1, "File type not known: %s type=%d",
@@ -227,11 +227,23 @@ int mfu_access(const char* path, int amode)
     return rc;
 }
 
-int daos_access(const char* path, int amode)
+int daos_access(const char* path, int amode, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
-    /* noop becuase daos have an access call */
-    return 0;
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    dfs_obj_t* parent = NULL;
+    int rc = dfs_access(mfu_file->dfs, parent, name, amode);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_access %s failed (%d %s)",
+                name, rc, strerror(rc));
+        errno = rc;
+        rc = -1;
+    }
+    return rc;
 #endif
 }
 
@@ -264,7 +276,7 @@ int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
     parse_filename(path, &name, &dir_name);
     assert(dir_name);
 
-    dfs_obj_t *parent = NULL;
+    dfs_obj_t* parent = NULL;
     int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
     if (parent != NULL) {
         rc = dfs_chmod(mfu_file->dfs, parent, name, mode);
@@ -346,7 +358,7 @@ int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file) {
     parse_filename(path, &name, &dir_name);
     assert(dir_name);
 
-    dfs_obj_t *parent = NULL;
+    dfs_obj_t* parent = NULL;
     int rc;
     if (mfu_file->only_daos) {
         rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
@@ -564,7 +576,7 @@ void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
     parse_filename(file, &name, &dir_name);
     assert(dir_name);
 
-    dfs_obj_t *parent = NULL;
+    dfs_obj_t* parent = NULL;
     int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
     if (parent != NULL) {
         rc = dfs_open(mfu_file->dfs, parent, name,
@@ -1054,7 +1066,7 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file) {
     assert(dir_name);
 
     /* Need to lookup parent directory in DFS */
-    dfs_obj_t *parent = NULL;
+    dfs_obj_t* parent = NULL;
     int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
 
     /* only call mkdir if the dir_name is not the root DFS directory */
@@ -1131,7 +1143,7 @@ int mfu_rmdir(const char* dir)
 
 #ifdef DAOS_SUPPORT
 struct dfs_mfu_t {
-    dfs_obj_t *dir;
+    dfs_obj_t* dir;
     struct dirent ents[NUM_DIRENTS];
     daos_anchor_t anchor;
     int num_ents;
diff --git a/src/common/mfu_io.h b/src/common/mfu_io.h
index 96543320..e6d395b4 100644
--- a/src/common/mfu_io.h
+++ b/src/common/mfu_io.h
@@ -56,7 +56,7 @@ struct stat64;
 /* calls access, and retries a few times if we get EIO or EINTR */
 int mfu_file_access(const char* path, int amode, mfu_file_t* mfu_file);
 int mfu_access(const char* path, int amode);
-int daos_access(const char* path, int amode);
+int daos_access(const char* path, int amode, mfu_file_t* mfu_file);
 
 /* calls lchown, and retries a few times if we get EIO or EINTR */
 int mfu_lchown(const char* path, uid_t owner, gid_t group);
diff --git a/src/common/mfu_param_path.c b/src/common/mfu_param_path.c
index 96bb28ea..eedeee8a 100644
--- a/src/common/mfu_param_path.c
+++ b/src/common/mfu_param_path.c
@@ -406,12 +406,6 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
     *flag_valid = 0;
     *flag_copy_into_dir = 0;
 
-    if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
-        if (num != 1) {
-            MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
-        }
-    }
-
     /* need at least two paths to have a shot at being valid */
     if (num < 1 || paths == NULL || destpath == NULL) {
         return;
@@ -426,6 +420,15 @@ void mfu_param_path_check_copy(uint64_t num, const mfu_param_path* paths,
 
     /* just have rank 0 check */
     if(rank == 0) {
+        /* DAOS-specific error checks*/
+        if (mfu_src_file->type == DAOS || mfu_dst_file->type == DAOS) {
+            if (num != 1) {
+                MFU_LOG(MFU_LOG_ERR, "Only one source can be specified when using DAOS");
+                valid = 0;
+                goto bcast;
+            }
+        }
+        
         /* count number of readable source paths */
         uint64_t i;
         int num_readable = 0;
diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 3080902f..32878844 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -107,58 +107,89 @@ void daos_bcast_handle(
     mfu_free(&global.iov_buf);
 }
 
-void daos_connect(
+int daos_connect(
   int rank,
   const char* svc,
   uuid_t pool_uuid,
   uuid_t cont_uuid,
   daos_handle_t* poh,
-  daos_handle_t* coh)
+  daos_handle_t* coh,
+  bool connect_pool,
+  bool create_cont)
 {
-    /* TODO: if src daos path and dst daos path are false 
-     * skip connecting to daos pool */
+    /* assume failure until otherwise */
+    int valid = 0;
+    int rc;
 
     /* have rank 0 connect to the pool and container,
      * we'll then broadcast the handle ids from rank 0 to everyone else */
     if (rank == 0) {
-        d_rank_list_t* svcl = daos_rank_list_parse(svc, ":");
-        if (svcl == NULL) {
-            MFU_ABORT(-1, "Failed to parse DAOS rank list: '%s'", svc);
-        }
+        /* Parse svc and connect to DAOS pool */
+        if (connect_pool) {
+            d_rank_list_t* svcl = daos_rank_list_parse(svc, ":");
+            if (svcl == NULL) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to parse DAOS rank list: '%s'", svc);
+                goto bcast;
+            }
 
-        /* Connect to DAOS pool */
-        daos_pool_info_t pool_info;
-        int rc = daos_pool_connect(pool_uuid, NULL, svcl, DAOS_PC_RW,
-                               poh, &pool_info, NULL);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to connect to pool");
+            daos_pool_info_t pool_info;
+            rc = daos_pool_connect(pool_uuid, NULL, svcl, DAOS_PC_RW,
+                    poh, &pool_info, NULL);
+            if (rc != 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to connect to pool");
+                d_rank_list_free(svcl);
+                goto bcast;
+            }
+            d_rank_list_free(svcl);
         }
-        d_rank_list_free(svcl);
 
-        /* attempt to open the daos container */
+        /* Try to open the container 
+         * If NOEXIST we create it */
         daos_cont_info_t co_info;
         rc = daos_cont_open(*poh, cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
-
-        /* If NOEXIST we create it */
         if (rc != 0) {
-            /* create the container */
-            uuid_t cuuid;
-            rc = dfs_cont_create(*poh, cuuid, NULL, NULL, NULL);
+            if (!create_cont) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
+                goto bcast;
+            }
+            
+            rc = dfs_cont_create(*poh, cont_uuid, NULL, NULL, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to create DFS container");
+                goto bcast;
             }
 
             /* try to open it again */
-            rc = daos_cont_open(*poh, cuuid, DAOS_COO_RW, coh, &co_info, NULL);
+            rc = daos_cont_open(*poh, cont_uuid, DAOS_COO_RW, coh, &co_info, NULL);
             if (rc != 0) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to open DFS container");
+                goto bcast;
             }
         }
+
+        /* everything looks good so far */
+        valid = 1;
+    }
+
+bcast:
+    /* broadcast valid from rank 0 */
+    MPI_Bcast(&valid, 1, MPI_INT, 0, MPI_COMM_WORLD);
+
+    /* return if invalid */
+    if (valid == 0) {
+        return -1;
     }
 
-    /* broadcast pool and container handles from rank 0 */
-    daos_bcast_handle(rank, poh, poh, POOL_HANDLE);
+    /* broadcast pool handle from rank 0 
+     * If connect_pool is false, then the handle was unchanged */
+    if (connect_pool) {
+        daos_bcast_handle(rank, poh, poh, POOL_HANDLE);
+    }
+
+    /* broadcast container handle from rank 0 */
     daos_bcast_handle(rank, coh, poh, CONT_HANDLE);
+
+    return 0;
 }
 #endif
 
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index 3adf5d1e..77158910 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -126,13 +126,15 @@ void daos_bcast_handle(
 );
 
 /* connect to DAOS pool, and then open container */
-void daos_connect(
+int daos_connect(
   int rank,
   const char* svc,
   uuid_t pool_uuid,
   uuid_t cont_uuid,
   daos_handle_t* poh,
-  daos_handle_t* coh
+  daos_handle_t* coh,
+  bool connect_pool,
+  bool create_cont
 );
 #endif
 
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 20c88539..09d27845 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -22,7 +22,120 @@
 #include "libcircle.h"
 #include "mfu.h"
 
+#include "mfu_errors.h"
+
 #ifdef DAOS_SUPPORT
+int daos_check_args(
+    int rank,
+    char** argpaths,
+    uuid_t src_pool_uuid,
+    uuid_t src_cont_uuid,
+    uuid_t dst_pool_uuid,
+    uuid_t dst_cont_uuid,
+    char* src_svc,
+    char* dst_svc,
+    char* dfs_prefix,
+    int* flag_daos_args)
+{
+    char* src_path = argpaths[0];
+    char* dst_path = argpaths[1];
+
+    bool have_src_path  = src_path != NULL;
+    bool have_dst_path  = dst_path != NULL;
+    bool have_src_pool  = daos_uuid_valid(src_pool_uuid);
+    bool have_src_cont  = daos_uuid_valid(src_cont_uuid);
+    bool have_dst_pool  = daos_uuid_valid(dst_pool_uuid);
+    bool have_dst_cont  = daos_uuid_valid(dst_cont_uuid);
+    bool have_src_svc   = src_svc != NULL;
+    bool have_dst_svc   = dst_svc != NULL;
+    bool have_prefix    = dfs_prefix != NULL;
+
+    /* Determine whether any DAOS arguments are supplied. 
+     * If not, then there is nothing to check. */
+    *flag_daos_args = 0;
+    if (have_src_pool || have_src_cont || have_dst_pool || have_dst_cont
+            || have_src_svc || have_dst_svc || have_prefix) {
+        *flag_daos_args = 1;
+    }
+    else {
+        return 0;
+    } 
+    
+    bool same_pool = false;
+    bool same_cont = false;
+    if (have_src_pool && have_dst_pool 
+            && uuid_compare(src_pool_uuid, dst_pool_uuid) == 0) {
+        same_pool = true;
+        if (have_src_cont && have_dst_cont
+                && uuid_compare(src_cont_uuid, dst_cont_uuid) == 0) {
+            same_cont = true;
+        }
+    }
+
+    int rc = 0;
+
+    if (have_src_cont && !have_src_pool) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source container requires source pool");
+        }
+        rc = 1;
+    }
+    if (have_src_pool && !have_src_cont) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source pool requires source container");
+        }
+        rc = 1;
+    }
+    if (have_src_pool && !have_src_svc) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source pool requires source svcl");
+        }
+        rc = 1;
+    }
+    if (have_dst_cont && !have_dst_pool) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Destination container requires destination pool");
+        }
+        rc = 1;
+    }
+    if (have_dst_pool && !have_dst_svc) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Destination pool requires destination svcl");
+        }
+        rc = 1;
+    }
+    if (have_prefix && !have_src_svc && !have_dst_svc) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Prefix requires source or destination svcl");
+        }
+        rc = 1;
+    }
+
+    /* Containers are using the same pool uuid.
+     * Make sure they are also using the same svc.
+     * This is unlikely to ever happen but we can print an error just in case. */
+    if (same_pool && have_src_svc && have_dst_svc) {
+        if (strcmp(dst_svc, src_svc) != 0) {
+            if (rank == 0) {
+                MFU_LOG(MFU_LOG_ERR, "Using same pool uuid with different svcl's");
+            }
+            rc = 1;
+        }
+    }
+
+    /* Make sure the source and destination are different */
+    if (same_cont && have_src_path && have_dst_path) {
+        if (strcmp(src_path, dst_path) == 0) {
+            if (rank == 0) {
+                 MFU_LOG(MFU_LOG_ERR, "DAOS source is DAOS destination");
+            }
+            rc = 1;
+        }
+    }
+
+    return rc;
+}
+
 static bool daos_check_prefix(char* path, const char* dfs_prefix) 
 {
     bool is_prefix = false;
@@ -38,7 +151,8 @@ static bool daos_check_prefix(char* path, const char* dfs_prefix)
     return is_prefix;
 }
 
-static void daos_set_paths(
+static int daos_set_paths(
+    int rank,
     char** argpaths,
     const char* dfs_prefix,
     uuid_t src_pool_uuid,
@@ -53,67 +167,100 @@ static void daos_set_paths(
     char* src_path = argpaths[0];
     char* dst_path = argpaths[1];
 
+    bool prefix_on_src = false;
+    bool prefix_on_dst = false;
+
     /* find out if a dfs_prefix is being used,
      * if so, then that means that the container
      * is not being copied from the root of the
      * UNS path  */
-    if (dfs_prefix == NULL) {
-        /* assume both are daos paths for UNS, if resolve path
-         * doesn't succeed then set accordingly */
-        struct duns_attr_t src_dattr = {0}; 
-        struct duns_attr_t dst_dattr = {0}; 
-        int src_rc = duns_resolve_path(src_path, &src_dattr);
-        int dst_rc = duns_resolve_path(dst_path, &dst_dattr);
-
-        /* Forward slash is "root" of container to walk
-         * in daos. Cannot walk from Unified namespace
-         * path given /tmp/dsikich/dfs, it is only used
-         * to lookup pool/cont uuids, and tells you
-         * if that path is mapped to pool/cont uuid in
-         * DAOS */
-        if (src_rc == 0 && dst_rc == 0) {
-            mfu_src_file->type = DAOS;
-            mfu_dst_file->type = DAOS;
-            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
-            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
-            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
-            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
-            argpaths[0] = "/";
-            argpaths[1] = "/";
-        } else if (src_rc == 0) { 
-            mfu_src_file->type = DAOS;
-            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
-            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
-            argpaths[0] = "/";
-        } else if (dst_rc == 0) {
-            mfu_dst_file->type = DAOS;
-            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
-            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
-            argpaths[1] = "/";
-        }
-
-        /* set daos io functions for src/dst paths */
-    } else {
-        struct duns_attr_t dattr = {0}; 
+    if (dfs_prefix != NULL) {
+        struct duns_attr_t dattr = {0};
         rc = duns_resolve_path(dfs_prefix, &dattr);
         if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS UNS path");
+            MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS Prefix UNS path");
+            return 1;
         }
 
-        /* figure out if prefix is on dst or src for 
+        /* figure out if prefix is on dst or src for
          * copying container subsets */
-	if (daos_check_prefix(src_path, dfs_prefix)) {
+        if (daos_check_prefix(src_path, dfs_prefix)) {
             mfu_src_file->type = DAOS;
             uuid_copy(src_pool_uuid, dattr.da_puuid);
             uuid_copy(src_cont_uuid, dattr.da_cuuid);
             argpaths[0] = src_path + strlen(dfs_prefix);
+            prefix_on_src = true;
         } else if (daos_check_prefix(dst_path, dfs_prefix)) {
             mfu_dst_file->type = DAOS;
             uuid_copy(dst_pool_uuid, dattr.da_puuid);
             uuid_copy(dst_cont_uuid, dattr.da_cuuid);
             argpaths[1] = dst_path + strlen(dfs_prefix);
+            prefix_on_dst = true;
+        }
+
+        if (!prefix_on_src && !prefix_on_dst) {
+            MFU_LOG(MFU_LOG_ERR, "DAOS prefix does not match source or destination");
+            return 1;
         }
     }
+
+    /* Forward slash is "root" of container to walk
+     * in daos. Cannot walk from Unified namespace
+     * path given /tmp/dsikich/dfs, it is only used
+     * to lookup pool/cont uuids, and tells you
+     * if that path is mapped to pool/cont uuid in
+     * DAOS 
+     *
+     * For each of the source and destination,
+     * if it is not using a prefix then assume
+     * it is a daos path for UNS. If resolve path
+     * doesn't succeed then it might be a POSIX path */
+    if (!prefix_on_src) {
+        struct duns_attr_t src_dattr = {0};
+        int src_rc = duns_resolve_path(src_path, &src_dattr);
+        
+        if (src_rc == 0) {
+            mfu_src_file->type = DAOS;
+            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
+            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
+            argpaths[0] = "/";
+        }
+    }
+
+    if (!prefix_on_dst) {
+        struct duns_attr_t dst_dattr = {0};
+        int dst_rc = duns_resolve_path(dst_path, &dst_dattr);
+
+        if (dst_rc == 0) {
+            mfu_dst_file->type = DAOS;
+            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
+            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
+            argpaths[1] = "/";
+        }
+    }
+
+    return 0;
+}
+
+/* return 1 if any process has a local error
+ * return 0 otherwise
+ * ignore if no daos args supplied */
+static int daos_any_error(int rank, bool local_daos_error, int flag_daos_args)
+{
+    bool no_error = !local_daos_error;
+    if (flag_daos_args == 0) {
+        no_error = true;
+    }
+
+    if (! mfu_alltrue(no_error, MPI_COMM_WORLD)) {
+        if (rank == 0) {
+           MFU_LOG(MFU_LOG_ERR, "Detected one or more DAOS errors: "
+                   MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+        }
+        return 1;
+    }
+
+    return 0;
 }
 #endif 
 
@@ -197,6 +344,9 @@ int main(int argc, char** argv)
     /* assume we'll exit with success */
     int rc = 0;
 
+    /* for juggling multiple rc values */
+    int tmp_rc = 0;
+
     /* initialize MPI */
     MPI_Init(&argc, &argv);
     mfu_init();
@@ -466,24 +616,93 @@ int main(int argc, char** argv)
         usage = 1;
     }
 
+    /* If we need to print the usage
+     * then do so before internal processing */
+    if (usage) {
+        if (rank == 0) {
+            print_usage();
+        }
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
+
     char** argpaths = (&argv[optind]);
 
 #ifdef DAOS_SUPPORT
-    rc = daos_init();
+    /* If only the source or destination svc is
+     * given, default the other */
+    if (src_svc != NULL && dst_svc == NULL) {
+        dst_svc = MFU_STRDUP(src_svc);
+    }
+    else if (src_svc == NULL && dst_svc != NULL) {
+        src_svc = MFU_STRDUP(dst_svc);
+    }
+
+    /* Each process keeps track of whether it had any DAOS errors.
+     * If there weren't any daos args, then ignore daos_init errors.
+     * Then, perform a reduction and exit if any process errored. */
+    bool local_daos_error = false;
+    int flag_daos_args;
+
+    /* Make sure we have the required DAOS arguments (if any).
+     * Safe to exit here, since all processes have the same values. */
+    rc = daos_check_args(rank, argpaths, src_pool_uuid, src_cont_uuid,
+            dst_pool_uuid, dst_cont_uuid, src_svc, dst_svc, dfs_prefix,
+            &flag_daos_args);
+    if (rc != 0) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+        }
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
+    }
 
-    /* TODO: Don't exit and fail if daos fails init,
-     * could just be regular paths */
+    /* For now, track the error.
+     * Later, ignore if no daos args supplied */
+    rc = daos_init();
     if (rc != 0) {
         MFU_LOG(MFU_LOG_ERR, "Failed to initialize daos");
+        local_daos_error = true;
     }
 
     /* Figure out if daos path is the src or dst,
      * using UNS path, then chop off UNS path
      * prefix since the path is mapped to the root
      * of the container in the DAOS DFS mount */
-    if (!daos_uuid_valid(src_pool_uuid) || !daos_uuid_valid(dst_pool_uuid)) {
-        daos_set_paths(argpaths, dfs_prefix, src_pool_uuid, src_cont_uuid,
-            dst_pool_uuid, dst_cont_uuid, mfu_src_file, mfu_dst_file);
+    if (!local_daos_error
+            && (!daos_uuid_valid(src_pool_uuid) || !daos_uuid_valid(dst_pool_uuid))) {
+        rc = daos_set_paths(rank, argpaths, dfs_prefix, src_pool_uuid, src_cont_uuid,
+                dst_pool_uuid, dst_cont_uuid, mfu_src_file, mfu_dst_file);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+            local_daos_error = true;
+        }
+    }
+
+    /* Re-check the required DAOS arguments (if any) */
+    if (!local_daos_error) {
+        rc = daos_check_args(rank, argpaths, src_pool_uuid, src_cont_uuid,
+                dst_pool_uuid, dst_cont_uuid, src_svc, dst_svc, dfs_prefix,
+                &flag_daos_args);
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+            local_daos_error = true;
+        }
+    }
+
+    /* Make sure there weren't any errors before continuing.
+     * Since daos_connect has a collective broadcast.
+     * we have to make sure same_pool below is valid. */
+    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
+        tmp_rc = daos_fini();
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
     }
 
     /* check if DAOS source and destination containers are in the same pool */
@@ -492,76 +711,65 @@ int main(int argc, char** argv)
         if (uuid_compare(src_pool_uuid, dst_pool_uuid) == 0) {
             same_pool = true;
         }
-    } 
+    }
 
     /* connect to DAOS source pool if uuid is valid */
-    if (mfu_src_file->type == DAOS) {
-        /* if DAOS source pool uuid is valid, then set source file type to DAOS */
-        daos_connect(rank, src_svc, src_pool_uuid, src_cont_uuid, &src_poh, &src_coh); 
+    if (!local_daos_error && mfu_src_file->type == DAOS) {
+        /* Open pool connection, but do not create container if non-existent */
+        rc = daos_connect(rank, src_svc, src_pool_uuid, src_cont_uuid, &src_poh, &src_coh, true, false);
+        if (rc != 0) {
+            /* rc from daos_connect is collective */
+            local_daos_error = true;
+        }
     }
 
-    if (mfu_dst_file->type == DAOS) {
-        if (!same_pool) {
-            /* if DAOS is the source and destination type, and containers are in different pools,
-             * then connect to the second pool */
-            daos_connect(rank, dst_svc, dst_pool_uuid, dst_cont_uuid, &dst_poh, &dst_coh); 
+    /* If the source and destination are in the same pool,
+     * then open the container in that pool.
+     * Otherwise, connect to the second pool and open the container */
+    if (!local_daos_error && mfu_dst_file->type == DAOS) {
+        if (same_pool) {
+            /* Don't reconnect to pool, but do create container if non-existent */
+            rc = daos_connect(rank, dst_svc, dst_pool_uuid, dst_cont_uuid, &src_poh, &dst_coh, false, true);
         } else {
-            /* Containers are using the same pool uuid.
-             * This is unlikely to ever happen but we can print an error just in case */
-            if (dst_svc != NULL && src_svc != NULL) {
-                if (strcmp(dst_svc, src_svc) != 0) {
-                    MFU_LOG(MFU_LOG_ERR, "Using same pool uuid with different svcl's");
-                    return 1;
-                }
-            }
-            if (rank == 0) {
-                /* create container in same pool */
-                daos_cont_info_t co_info;
-                rc = daos_cont_open(src_poh, dst_cont_uuid, DAOS_COO_RW, &dst_coh, &co_info, NULL);
-
-                /* If NOEXIST we create it */
-                if (rc != 0) {
-                    /* create the container */
-                    uuid_t cuuid;
-                    rc = dfs_cont_create(src_poh, cuuid, NULL, NULL, NULL);
-                    if (rc != 0) {
-                        MFU_LOG(MFU_LOG_ERR, "Failed to create DFS2 container");
-                    }
-
-                    /* try to open it again */
-                    rc = daos_cont_open(src_poh, cuuid, DAOS_COO_RW, &dst_coh, &co_info, NULL);
-                    if (rc != 0) {
-                        MFU_LOG(MFU_LOG_ERR, "Failed to open DFS2 container");
-                    }
-                }
-            }
-
-            /* broadcast container handle from rank 0 */
-            daos_bcast_handle(rank, &dst_coh, &src_poh, CONT_HANDLE);
+            /* Open pool connection, and create container if non-existent */
+            rc = daos_connect(rank, dst_svc, dst_pool_uuid, dst_cont_uuid, &dst_poh, &dst_coh, true, true); 
+        }
+        if (rc != 0) {
+            /* rc from daos_connect is collective */
+            local_daos_error = true;
         }
     }
 
-    if (mfu_src_file->type == DAOS) {
+    if (!local_daos_error && mfu_src_file->type == DAOS) {
         /* DFS is mounted for the source container */
         rc = dfs_mount(src_poh, src_coh, O_RDWR, &dfs1);
         if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS)");
+            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+            local_daos_error = true;
         }
     }
 
-    if (mfu_dst_file->type == DAOS) {
+    if (!local_daos_error && mfu_dst_file->type == DAOS) {
         /* DFS is mounted for the destination container */
         if (same_pool) {
             rc = dfs_mount(src_poh, dst_coh, O_RDWR, &dfs2);
-            if (rc != 0) {
-                MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS)");
-            }
         } else {
             rc = dfs_mount(dst_poh, dst_coh, O_RDWR, &dfs2);
-            if (rc != 0) {
-                MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS)");
-            }
         }
+        if (rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+            local_daos_error = true;
+        }
+    }
+
+    /* Exit if any process had a daos error */
+    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
+        tmp_rc = daos_fini();
+        mfu_finalize();
+        MPI_Finalize();
+        return 1;
     }
 
     /* set source and destination files to address of their
@@ -593,13 +801,10 @@ int main(int argc, char** argv)
         numpaths_src = numpaths - 1;
     }
 
-    if (usage || numpaths_src == 0) {
+    if (numpaths_src == 0) {
         if(rank == 0) {
-            if (usage != 1) {
-                MFU_LOG(MFU_LOG_ERR, "A source and destination path is needed");
-            } else {
-                print_usage();
-            }
+            MFU_LOG(MFU_LOG_ERR, "A source and destination path is needed: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
         }
 
         mfu_param_path_free_all(numpaths, paths);
@@ -615,12 +820,13 @@ int main(int argc, char** argv)
     /* Parse the source and destination paths. */
     int valid, copy_into_dir;
     mfu_param_path_check_copy(numpaths_src, paths, destpath, mfu_src_file, mfu_dst_file, &valid, &copy_into_dir);
-    mfu_copy_opts->copy_into_dir = copy_into_dir; 
+    mfu_copy_opts->copy_into_dir = copy_into_dir;
 
     /* exit job if we found a problem */
     if (!valid) {
         if(rank == 0) {
-            MFU_LOG(MFU_LOG_ERR, "Invalid src/dest paths provided. Exiting run.\n");
+            MFU_LOG(MFU_LOG_ERR, "Invalid src/dest paths provided. Exiting run: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
         }
         mfu_param_path_free_all(numpaths, paths);
         mfu_free(&paths);
@@ -649,9 +855,9 @@ int main(int argc, char** argv)
     }
 
     /* copy flist into destination */ 
-    int tmp_rc = mfu_flist_copy(flist, numpaths_src, paths,
-                                destpath, mfu_copy_opts, mfu_src_file,
-                                mfu_dst_file);
+    tmp_rc = mfu_flist_copy(flist, numpaths_src, paths,
+                            destpath, mfu_copy_opts, mfu_src_file,
+                            mfu_dst_file);
     if (tmp_rc < 0) {
         /* hit some sort of error during copy */
         rc = 1;
@@ -678,43 +884,43 @@ int main(int argc, char** argv)
     /* DAOS: unmount DFS, and close containers and pools */
 #ifdef DAOS_SUPPORT
     if (mfu_src_file->type == DAOS) {
-        rc = dfs_umount(mfu_src_file->dfs);
+        tmp_rc = dfs_umount(mfu_src_file->dfs);
         MPI_Barrier(MPI_COMM_WORLD);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to mount DFS namespace");
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to umount DFS namespace");
         }
-        rc = daos_cont_close(src_coh, NULL);
+        tmp_rc = daos_cont_close(src_coh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
-        if (rc != 0) {
+        if (tmp_rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
         }
     }
 
     if (mfu_dst_file->type == DAOS) {
-        rc = dfs_umount(mfu_dst_file->dfs);
+        tmp_rc = dfs_umount(mfu_dst_file->dfs);
         MPI_Barrier(MPI_COMM_WORLD);
-        if (rc != 0) {
+        if (tmp_rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed unmount DFS namespace");
         }
-        rc = daos_cont_close(dst_coh, NULL);
+        tmp_rc = daos_cont_close(dst_coh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
-        if (rc != 0) {
+        if (tmp_rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
         }
     }
 
     if (mfu_src_file->type == DAOS) {
-        rc = daos_pool_disconnect(src_poh, NULL);
+        tmp_rc = daos_pool_disconnect(src_poh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
-        if (rc != 0) {
+        if (tmp_rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from source pool");
         }
     }
 
     if (mfu_dst_file->type == DAOS && !same_pool) {
-        rc = daos_pool_disconnect(dst_poh, NULL);
+        tmp_rc = daos_pool_disconnect(dst_poh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
-        if (rc != 0) {
+        if (tmp_rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool");
         }
     }
@@ -724,9 +930,17 @@ int main(int argc, char** argv)
     mfu_file_delete(&mfu_src_file);
     mfu_file_delete(&mfu_dst_file);
 
+    /* Alert the user if there were copy errors */
+    if (rc != 0) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "One or more errors were detected while copying: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DCP_COPY));
+        }
+    }
+
 #ifdef DAOS_SUPPORT
     /* finalize daos */
-    rc = daos_fini();
+    tmp_rc = daos_fini();
 #endif
 
     mfu_finalize();
@@ -734,5 +948,8 @@ int main(int argc, char** argv)
     /* shut down MPI */
     MPI_Finalize();
 
+    if (rc != 0) {
+        return 1;
+    }
     return 0;
 }

From 0edeef2cd8ea9e95a91932d1b165ab7610b4e8fe Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Tue, 15 Sep 2020 19:10:31 +0000
Subject: [PATCH 11/27] mfu_alltrue use bool instead of int

mfu_alltrue now uses a bool type instead of int.
The input, output, and reduction type are now bool.

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_util.c | 8 ++++----
 src/common/mfu_util.h | 2 +-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 32878844..2ee49180 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -1123,11 +1123,11 @@ void mfu_stripe_set(const char *path, uint64_t stripe_size, int stripe_count)
 }
 
 /* executes a logical AND operation on flag on all procs on comm,
- * returns 1 if all true and 0 otherwise */
-int mfu_alltrue(int flag, MPI_Comm comm)
+ * returns true if all true and false otherwise */
+bool mfu_alltrue(bool flag, MPI_Comm comm)
 {
     /* check that all processes wrote successfully */
-    int alltrue;
-    MPI_Allreduce(&flag, &alltrue, 1, MPI_INT, MPI_LAND, comm);
+    bool alltrue;
+    MPI_Allreduce(&flag, &alltrue, 1, MPI_C_BOOL, MPI_LAND, comm);
     return alltrue;
 }
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index 77158910..84490aa5 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -288,7 +288,7 @@ void mfu_stripe_set(const char *path, uint64_t stripe_size, int stripe_count);
 
 /* executes a logical AND operation on flag on all procs on comm,
  * returns 1 if all true and 0 otherwise */
-int mfu_alltrue(int flag, MPI_Comm comm);
+bool mfu_alltrue(bool flag, MPI_Comm comm);
 
 #endif /* MFU_UTIL_H */
 

From bb4abec6e31c5b16da8994cf1239a898947a82ab Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Tue, 15 Sep 2020 22:27:07 +0000
Subject: [PATCH 12/27] daos: free memory and fix mkdir root check

There was a check for dir_name=="/"
which has been changed to name=="/"
since dir_name is the parent.

In all daos calls to parse_filename,
free the returned char* memory.

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_io.c | 28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 4afd5d6a..332e8b87 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -243,6 +243,10 @@ int daos_access(const char* path, int amode, mfu_file_t* mfu_file)
         errno = rc;
         rc = -1;
     }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+    
     return rc;
 #endif
 }
@@ -291,6 +295,10 @@ int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
         errno = ENOENT;
         rc = -1;
     }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
     return rc;
 #endif
 }
@@ -351,7 +359,8 @@ int mfu_utimensat(int dirfd, const char *pathname, const struct timespec times[2
     return rc;
 }
 
-int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file) {
+int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
+{
 #ifdef DAOS_SUPPORT
     char* name     = NULL;
     char* dir_name = NULL;
@@ -377,6 +386,10 @@ int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file) {
         errno = rc;
         rc = -1;
     }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
     return rc;
 #endif
 }
@@ -593,6 +606,9 @@ void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
         errno = ENOENT;
         rc = -1;
     }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
 #endif
 }
 
@@ -1058,7 +1074,8 @@ void mfu_getcwd(char* buf, size_t size)
     }
 }
 
-int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file) {
+int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
+{
 #ifdef DAOS_SUPPORT
     char* name     = NULL;
     char* dir_name = NULL;
@@ -1069,8 +1086,8 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file) {
     dfs_obj_t* parent = NULL;
     int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
 
-    /* only call mkdir if the dir_name is not the root DFS directory */
-    if (strcmp(dir_name, "/") != 0) {
+    /* only call mkdir if name is not the root DFS directory */
+    if (name && strcmp(name, "/") != 0) {
         rc = dfs_mkdir(mfu_file->dfs, parent, name, mode, 0);
     }
 
@@ -1079,6 +1096,9 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file) {
         rc = -1;
     }
 
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
     return rc;
 #endif
 }

From 1f211843fc57a04d1539ed7217375c3cb13cfeeb Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Tue, 15 Sep 2020 22:31:32 +0000
Subject: [PATCH 13/27] daos: dcp: abstract and improve daos code

Added an early check to make sure at least two
paths are provided, right after processing the arguments.
This will cut down on unnecessary processing.

daos_check_prefix now effectively ignores
the trailing '/' on the prefix and path.

If the daos prefix matches the source and source UUIDs are supplied,
alert the user and exit.

If the daos prefix matches the destination and destination UUIDs are
supplied, alert the user and exit.

If the daos source path is UNS and source UUIDs are supplied,
alert the user and exit.

If the daos destination path is UNS and destination UUIDs are supplied,
alert the user and exit.

DAOS-related code has been abstracted.
New daos_args struct to hold args.
New daos_setup to setup DAOS.
New daos_cleanup to cleanup DAOS.

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/dcp/dcp.c | 641 ++++++++++++++++++++++++++++++--------------------
 1 file changed, 380 insertions(+), 261 deletions(-)

diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 09d27845..753824c5 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -25,30 +25,89 @@
 #include "mfu_errors.h"
 
 #ifdef DAOS_SUPPORT
-int daos_check_args(
+/* struct for holding DAOS arguments */
+typedef struct {
+    daos_handle_t src_poh; /* source pool handle */
+    daos_handle_t dst_poh; /* destination pool handle */
+    daos_handle_t src_coh; /* source container handle */
+    daos_handle_t dst_coh; /* destination container handle */
+    uuid_t src_pool_uuid;  /* source pool UUID */
+    uuid_t dst_pool_uuid;  /* destination pool UUID */
+    uuid_t src_cont_uuid;  /* source container UUID */
+    uuid_t dst_cont_uuid;  /* destination container UUID */
+    dfs_t* dfs1;           /* source dfs object */
+    dfs_t* dfs2;           /* destination dfs object */
+    char* src_svc;         /* source service level */
+    char* dst_svc;         /* destination service level */
+    char* dfs_prefix;      /* prefix for UNS */
+} daos_args_t;
+
+/* Return a newly allocated daos_args_t structure.
+ * Set default values on its fields. */
+static daos_args_t* daos_args_new(void)
+{
+    daos_args_t* da = (daos_args_t*) MFU_MALLOC(sizeof(daos_args_t));
+    
+    da->src_poh    = DAOS_HDL_INVAL;
+    da->dst_poh    = DAOS_HDL_INVAL;
+    da->src_coh    = DAOS_HDL_INVAL;
+    da->dst_coh    = DAOS_HDL_INVAL;
+    da->dfs1       = NULL;
+    da->dfs2       = NULL;
+    da->src_svc    = NULL;
+    da->dst_svc    = NULL;
+    da->dfs_prefix = NULL;
+
+    /* initalize value of DAOS UUID's to NULL with uuid_clear */
+    uuid_clear(da->src_pool_uuid);
+    uuid_clear(da->dst_pool_uuid);
+    uuid_clear(da->src_cont_uuid);
+    uuid_clear(da->dst_cont_uuid);
+    
+    return da;
+}
+
+/* free a daos_args_t structure.
+ * dfs is handled in dfs_umount */
+static void daos_args_delete(daos_args_t** pda)
+{
+    if (pda != NULL) {
+        daos_args_t* da = *pda;
+        mfu_free(&da->src_svc);
+        mfu_free(&da->dst_svc);
+        mfu_free(&da->dfs_prefix);
+        mfu_free(pda);
+    }
+}
+
+/* Verify DAOS arguments are valid */
+static int daos_check_args(
     int rank,
     char** argpaths,
-    uuid_t src_pool_uuid,
-    uuid_t src_cont_uuid,
-    uuid_t dst_pool_uuid,
-    uuid_t dst_cont_uuid,
-    char* src_svc,
-    char* dst_svc,
-    char* dfs_prefix,
+    daos_args_t* da,
     int* flag_daos_args)
 {
     char* src_path = argpaths[0];
     char* dst_path = argpaths[1];
 
+    /* If only the source or destination svc is
+     * given, default the other */
+    if (da->src_svc != NULL && da->dst_svc == NULL) {
+        da->dst_svc = MFU_STRDUP(da->src_svc);
+    }
+    else if (da->src_svc == NULL && da->dst_svc != NULL) {
+        da->src_svc = MFU_STRDUP(da->dst_svc);
+    }
+
     bool have_src_path  = src_path != NULL;
     bool have_dst_path  = dst_path != NULL;
-    bool have_src_pool  = daos_uuid_valid(src_pool_uuid);
-    bool have_src_cont  = daos_uuid_valid(src_cont_uuid);
-    bool have_dst_pool  = daos_uuid_valid(dst_pool_uuid);
-    bool have_dst_cont  = daos_uuid_valid(dst_cont_uuid);
-    bool have_src_svc   = src_svc != NULL;
-    bool have_dst_svc   = dst_svc != NULL;
-    bool have_prefix    = dfs_prefix != NULL;
+    bool have_src_pool  = daos_uuid_valid(da->src_pool_uuid);
+    bool have_src_cont  = daos_uuid_valid(da->src_cont_uuid);
+    bool have_dst_pool  = daos_uuid_valid(da->dst_pool_uuid);
+    bool have_dst_cont  = daos_uuid_valid(da->dst_cont_uuid);
+    bool have_src_svc   = da->src_svc != NULL;
+    bool have_dst_svc   = da->dst_svc != NULL;
+    bool have_prefix    = da->dfs_prefix != NULL;
 
     /* Determine whether any DAOS arguments are supplied. 
      * If not, then there is nothing to check. */
@@ -64,10 +123,10 @@ int daos_check_args(
     bool same_pool = false;
     bool same_cont = false;
     if (have_src_pool && have_dst_pool 
-            && uuid_compare(src_pool_uuid, dst_pool_uuid) == 0) {
+            && uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
         same_pool = true;
         if (have_src_cont && have_dst_cont
-                && uuid_compare(src_cont_uuid, dst_cont_uuid) == 0) {
+                && uuid_compare(da->src_cont_uuid, da->dst_cont_uuid) == 0) {
             same_cont = true;
         }
     }
@@ -115,7 +174,7 @@ int daos_check_args(
      * Make sure they are also using the same svc.
      * This is unlikely to ever happen but we can print an error just in case. */
     if (same_pool && have_src_svc && have_dst_svc) {
-        if (strcmp(dst_svc, src_svc) != 0) {
+        if (strcmp(da->dst_svc, da->src_svc) != 0) {
             if (rank == 0) {
                 MFU_LOG(MFU_LOG_ERR, "Using same pool uuid with different svcl's");
             }
@@ -136,34 +195,50 @@ int daos_check_args(
     return rc;
 }
 
-static bool daos_check_prefix(char* path, const char* dfs_prefix) 
+/* Checks if the prefix is valid.
+ * If valid, returns matching string into suffix */
+static bool daos_check_prefix(char* path, const char* dfs_prefix, char** suffix)
 {
     bool is_prefix = false;
-    /* figure out if dfs_prefix is a prefix of the file path */
     int prefix_len = strlen(dfs_prefix);
+    int path_len = strlen(path);
+
+    /* ignore trailing '/' on the prefix */
+    if (dfs_prefix[prefix_len-1] == '/') {
+        prefix_len--;
+    }
+
+    /* figure out if dfs_prefix is a prefix of the file path */
     if (strncmp(path, dfs_prefix, prefix_len) == 0) {
-        /* if we have another character, it must be '/' */
-        if (strlen(path) > prefix_len &&
+        /* if equal, assume root */
+        if (path_len == prefix_len) {
+            *suffix = "/";
+            is_prefix = true;
+        }
+        /* if path is longer, it must start with '/' */
+        else if (path_len > prefix_len &&
             path[prefix_len] == '/') {
+            *suffix = path + prefix_len;
             is_prefix = true;
         }
     }
     return is_prefix;
 }
 
+/* Checks for UNS paths and sets
+ * paths and DAOS args accordingly */
 static int daos_set_paths(
     int rank,
     char** argpaths,
-    const char* dfs_prefix,
-    uuid_t src_pool_uuid,
-    uuid_t src_cont_uuid,
-    uuid_t dst_pool_uuid,
-    uuid_t dst_cont_uuid,
+    daos_args_t* da,
     mfu_file_t* mfu_src_file,
     mfu_file_t* mfu_dst_file)
 {
     int rc = 0;
 
+    bool have_src_pool  = daos_uuid_valid(da->src_pool_uuid);
+    bool have_dst_pool  = daos_uuid_valid(da->dst_pool_uuid);
+    
     char* src_path = argpaths[0];
     char* dst_path = argpaths[1];
 
@@ -174,9 +249,9 @@ static int daos_set_paths(
      * if so, then that means that the container
      * is not being copied from the root of the
      * UNS path  */
-    if (dfs_prefix != NULL) {
+    if (da->dfs_prefix != NULL) {
         struct duns_attr_t dattr = {0};
-        rc = duns_resolve_path(dfs_prefix, &dattr);
+        rc = duns_resolve_path(da->dfs_prefix, &dattr);
         if (rc != 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to resolve DAOS Prefix UNS path");
             return 1;
@@ -184,21 +259,25 @@ static int daos_set_paths(
 
         /* figure out if prefix is on dst or src for
          * copying container subsets */
-        if (daos_check_prefix(src_path, dfs_prefix)) {
+        if (daos_check_prefix(src_path, da->dfs_prefix, &argpaths[0])) {
+            if (have_src_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS source pool should not be used with DAOS source prefix");
+                return 1;
+            }
             mfu_src_file->type = DAOS;
-            uuid_copy(src_pool_uuid, dattr.da_puuid);
-            uuid_copy(src_cont_uuid, dattr.da_cuuid);
-            argpaths[0] = src_path + strlen(dfs_prefix);
+            uuid_copy(da->src_pool_uuid, dattr.da_puuid);
+            uuid_copy(da->src_cont_uuid, dattr.da_cuuid);
             prefix_on_src = true;
-        } else if (daos_check_prefix(dst_path, dfs_prefix)) {
+        } else if (daos_check_prefix(dst_path, da->dfs_prefix, &argpaths[1])) {
+            if (have_dst_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS destination pool should not be used with DAOS destination prefix");
+                return 1;
+            }
             mfu_dst_file->type = DAOS;
-            uuid_copy(dst_pool_uuid, dattr.da_puuid);
-            uuid_copy(dst_cont_uuid, dattr.da_cuuid);
-            argpaths[1] = dst_path + strlen(dfs_prefix);
+            uuid_copy(da->dst_pool_uuid, dattr.da_puuid);
+            uuid_copy(da->dst_cont_uuid, dattr.da_cuuid);
             prefix_on_dst = true;
-        }
-
-        if (!prefix_on_src && !prefix_on_dst) {
+        } else {
             MFU_LOG(MFU_LOG_ERR, "DAOS prefix does not match source or destination");
             return 1;
         }
@@ -220,9 +299,13 @@ static int daos_set_paths(
         int src_rc = duns_resolve_path(src_path, &src_dattr);
         
         if (src_rc == 0) {
+            if (have_src_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS source pool should not be used with DAOS source UNS path");
+                return 1;
+            }
             mfu_src_file->type = DAOS;
-            uuid_copy(src_pool_uuid, src_dattr.da_puuid);
-            uuid_copy(src_cont_uuid, src_dattr.da_cuuid);
+            uuid_copy(da->src_pool_uuid, src_dattr.da_puuid);
+            uuid_copy(da->src_cont_uuid, src_dattr.da_cuuid);
             argpaths[0] = "/";
         }
     }
@@ -232,9 +315,13 @@ static int daos_set_paths(
         int dst_rc = duns_resolve_path(dst_path, &dst_dattr);
 
         if (dst_rc == 0) {
+            if (have_dst_pool) {
+                MFU_LOG(MFU_LOG_ERR, "DAOS destination pool should not be used with DAOS destination UNS path");
+                return 1;
+            }
             mfu_dst_file->type = DAOS;
-            uuid_copy(dst_pool_uuid, dst_dattr.da_puuid);
-            uuid_copy(dst_cont_uuid, dst_dattr.da_cuuid);
+            uuid_copy(da->dst_pool_uuid, dst_dattr.da_puuid);
+            uuid_copy(da->dst_cont_uuid, dst_dattr.da_cuuid);
             argpaths[1] = "/";
         }
     }
@@ -262,6 +349,233 @@ static int daos_any_error(int rank, bool local_daos_error, int flag_daos_args)
 
     return 0;
 }
+
+/* Setup DAOS arguments.
+ * Connect to pools.
+ * Open containers.
+ * Mount DFS. 
+ * Returns 1 on error, 0 on success */
+static int daos_setup(
+    int rank,
+    char** argpaths,
+    daos_args_t* da,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
+{
+    int tmp_rc;
+
+    /* Each process keeps track of whether it had any DAOS errors.
+     * If there weren't any daos args, then ignore daos_init errors.
+     * Then, perform a reduction and exit if any process errored. */
+    bool local_daos_error = false;
+    int flag_daos_args;
+
+    /* Make sure we have the required DAOS arguments (if any).
+     * Safe to return here, since all processes have the same values. */
+    tmp_rc = daos_check_args(rank, argpaths, da, &flag_daos_args);
+    if (tmp_rc != 0) {
+        if (rank == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+        }
+        return 1;
+    }
+
+    /* For now, track the error.
+     * Later, ignore if no daos args supplied */
+    tmp_rc = daos_init();
+    if (tmp_rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to initialize daos");
+        local_daos_error = true;
+    }
+
+    /* Figure out if daos path is the src or dst,
+     * using UNS path, then chop off UNS path
+     * prefix since the path is mapped to the root
+     * of the container in the DAOS DFS mount */
+    if (!local_daos_error
+            && (!daos_uuid_valid(da->src_pool_uuid) || !daos_uuid_valid(da->dst_pool_uuid))) {
+        tmp_rc = daos_set_paths(rank, argpaths, da, mfu_src_file, mfu_dst_file);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+            local_daos_error = true;
+        }
+    }
+
+    /* Re-check the required DAOS arguments (if any) */
+    if (!local_daos_error) {
+        tmp_rc = daos_check_args(rank, argpaths, da, &flag_daos_args);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
+            local_daos_error = true;
+        }
+    }
+
+    /* Make sure there weren't any errors before continuing.
+     * Since daos_connect has a collective broadcast.
+     * we have to make sure same_pool below is valid. */
+    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
+        tmp_rc = daos_fini();
+        return 1;
+    }
+
+    /* check if DAOS source and destination containers are in the same pool */
+    bool same_pool = false;
+    if (mfu_src_file->type == DAOS && mfu_dst_file->type == DAOS) {
+        if (uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
+            same_pool = true;
+        }
+    }
+
+    /* connect to DAOS source pool if uuid is valid */
+    if (!local_daos_error && mfu_src_file->type == DAOS) {
+        /* Open pool connection, but do not create container if non-existent */
+        tmp_rc = daos_connect(rank, da->src_svc, da->src_pool_uuid,
+                da->src_cont_uuid, &da->src_poh, &da->src_coh, true, false);
+        if (tmp_rc != 0) {
+            /* tmp_rc from daos_connect is collective */
+            local_daos_error = true;
+        }
+    }
+
+    /* If the source and destination are in the same pool,
+     * then open the container in that pool.
+     * Otherwise, connect to the second pool and open the container */
+    if (!local_daos_error && mfu_dst_file->type == DAOS) {
+        if (same_pool) {
+            /* Don't reconnect to pool, but do create container if non-existent */
+            tmp_rc = daos_connect(rank, da->dst_svc, da->dst_pool_uuid,
+                    da->dst_cont_uuid, &da->src_poh, &da->dst_coh, false, true);
+        } else {
+            /* Open pool connection, and create container if non-existent */
+            tmp_rc = daos_connect(rank, da->dst_svc, da->dst_pool_uuid,
+                    da->dst_cont_uuid, &da->dst_poh, &da->dst_coh, true, true);
+        }
+        if (tmp_rc != 0) {
+            /* tmp_rc from daos_connect is collective */
+            local_daos_error = true;
+        }
+    }
+
+    if (!local_daos_error && mfu_src_file->type == DAOS) {
+        /* DFS is mounted for the source container */
+        tmp_rc = dfs_mount(da->src_poh, da->src_coh, O_RDWR, &da->dfs1);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+            local_daos_error = true;
+        }
+    }
+
+    if (!local_daos_error && mfu_dst_file->type == DAOS) {
+        /* DFS is mounted for the destination container */
+        if (same_pool) {
+            tmp_rc = dfs_mount(da->src_poh, da->dst_coh, O_RDWR, &da->dfs2);
+        } else {
+            tmp_rc = dfs_mount(da->dst_poh, da->dst_coh, O_RDWR, &da->dfs2);
+        }
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
+                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+            local_daos_error = true;
+        }
+    }
+
+    /* Return if any process had a daos error */
+    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
+        tmp_rc = daos_fini();
+        return 1;
+    }
+
+    /* set source and destination files to address of their
+     * DFS mount within DAOS */
+    mfu_src_file->dfs = da->dfs1;
+    mfu_dst_file->dfs = da->dfs2;
+
+    /* Everything looks good so far */
+    return 0;
+}
+
+/* Unmount DFS.
+ * Disconnect from pool/cont.
+ * Cleanup DAOS-related vars, handles. 
+ * Finalize DAOS. */
+static int daos_cleanup(
+    daos_args_t* da,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
+{
+    /* assume success until failure */
+    int rc = 0;
+    int tmp_rc;
+
+    bool same_pool = false;
+    if (daos_uuid_valid(da->src_pool_uuid) && daos_uuid_valid(da->dst_pool_uuid)
+            && uuid_compare(da->src_pool_uuid, da->dst_pool_uuid) == 0) {
+        same_pool = true;
+    }
+
+    if (mfu_src_file->type == DAOS) {
+        tmp_rc = dfs_umount(mfu_src_file->dfs);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to umount DFS namespace");
+            rc = 1;
+        }
+        tmp_rc = daos_cont_close(da->src_coh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+            rc = 1;
+        }
+    }
+
+    if (mfu_dst_file->type == DAOS) {
+        tmp_rc = dfs_umount(mfu_dst_file->dfs);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed unmount DFS namespace");
+            rc = 1;
+        }
+        tmp_rc = daos_cont_close(da->dst_coh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
+            rc = 1;
+        }
+    }
+
+    if (mfu_src_file->type == DAOS) {
+        tmp_rc = daos_pool_disconnect(da->src_poh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from source pool");
+            rc = 1;
+        }
+    }
+
+    if (mfu_dst_file->type == DAOS && !same_pool) {
+        tmp_rc = daos_pool_disconnect(da->dst_poh, NULL);
+        MPI_Barrier(MPI_COMM_WORLD);
+        if (tmp_rc != 0) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool");
+            rc = 1;
+        }
+    }
+
+    /* Finalize DAOS */
+    tmp_rc = daos_fini();
+    if (tmp_rc != 0) {
+        rc = 1;
+    }
+
+    /* Free DAOS args */
+    daos_args_delete(&da);
+
+    return rc;
+}
 #endif 
 
 static int input_flist_skip(const char* name, void *args)
@@ -344,9 +658,6 @@ int main(int argc, char** argv)
     /* assume we'll exit with success */
     int rc = 0;
 
-    /* for juggling multiple rc values */
-    int tmp_rc = 0;
-
     /* initialize MPI */
     MPI_Init(&argc, &argv);
     mfu_init();
@@ -377,25 +688,7 @@ int main(int argc, char** argv)
 
 #ifdef DAOS_SUPPORT
     /* DAOS vars */ 
-    daos_handle_t src_poh = DAOS_HDL_INVAL;
-    daos_handle_t dst_poh = DAOS_HDL_INVAL;
-    daos_handle_t src_coh = DAOS_HDL_INVAL;
-    daos_handle_t dst_coh = DAOS_HDL_INVAL;
-    dfs_t *dfs1           = NULL;
-    dfs_t *dfs2           = NULL;
-    char* src_svc         = NULL;
-    char* dst_svc         = NULL;
-    char* dfs_prefix      = NULL;
-
-    /* initalize value of DAOS UUID's to NULL with uuid_clear */
-    uuid_t src_pool_uuid;
-    uuid_t dst_pool_uuid;
-    uuid_t src_cont_uuid;
-    uuid_t dst_cont_uuid;
-    uuid_clear(src_pool_uuid);
-    uuid_clear(dst_pool_uuid);
-    uuid_clear(src_cont_uuid);
-    uuid_clear(dst_cont_uuid);
+    daos_args_t* daos_args = daos_args_new();    
 #endif
 
     int option_index = 0;
@@ -501,7 +794,7 @@ int main(int argc, char** argv)
 #endif
 #ifdef DAOS_SUPPORT
             case 'x':
-                rc = uuid_parse(optarg, src_pool_uuid);
+                rc = uuid_parse(optarg, daos_args->src_pool_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse source pool uuid: '%s'", optarg);
@@ -510,7 +803,7 @@ int main(int argc, char** argv)
                 }
                 break;
             case 'D':
-                rc = uuid_parse(optarg, dst_pool_uuid);
+                rc = uuid_parse(optarg, daos_args->dst_pool_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse dst pool uuid: '%s'", optarg);
@@ -519,7 +812,7 @@ int main(int argc, char** argv)
                 }
                 break;
             case 'y':
-                rc = uuid_parse(optarg, src_cont_uuid);
+                rc = uuid_parse(optarg, daos_args->src_cont_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse source cont uuid: '%s'", optarg);
@@ -529,7 +822,7 @@ int main(int argc, char** argv)
                 mfu_src_file->type = DAOS;
                 break;
             case 'Y':
-                rc = uuid_parse(optarg, dst_cont_uuid);
+                rc = uuid_parse(optarg, daos_args->dst_cont_uuid);
                 if (rc != 0) {
                     if (rank == 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to parse dst cont uuid: '%s'", optarg);
@@ -539,13 +832,13 @@ int main(int argc, char** argv)
                 mfu_dst_file->type = DAOS;
                 break;
             case 'z':
-                src_svc = MFU_STRDUP(optarg);
+                daos_args->src_svc = MFU_STRDUP(optarg);
                 break;
             case 'Z':
-                dst_svc = MFU_STRDUP(optarg);
+                daos_args->dst_svc = MFU_STRDUP(optarg);
                 break;
             case 'X':
-                dfs_prefix = MFU_STRDUP(optarg);
+                daos_args->dfs_prefix = MFU_STRDUP(optarg);
                 break;
 #endif
             case 'i':
@@ -627,155 +920,26 @@ int main(int argc, char** argv)
         return 1;
     }
 
-    char** argpaths = (&argv[optind]);
-
-#ifdef DAOS_SUPPORT
-    /* If only the source or destination svc is
-     * given, default the other */
-    if (src_svc != NULL && dst_svc == NULL) {
-        dst_svc = MFU_STRDUP(src_svc);
-    }
-    else if (src_svc == NULL && dst_svc != NULL) {
-        src_svc = MFU_STRDUP(dst_svc);
-    }
-
-    /* Each process keeps track of whether it had any DAOS errors.
-     * If there weren't any daos args, then ignore daos_init errors.
-     * Then, perform a reduction and exit if any process errored. */
-    bool local_daos_error = false;
-    int flag_daos_args;
-
-    /* Make sure we have the required DAOS arguments (if any).
-     * Safe to exit here, since all processes have the same values. */
-    rc = daos_check_args(rank, argpaths, src_pool_uuid, src_cont_uuid,
-            dst_pool_uuid, dst_cont_uuid, src_svc, dst_svc, dfs_prefix,
-            &flag_daos_args);
-    if (rc != 0) {
-        if (rank == 0) {
-            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
-                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
-        }
-        mfu_finalize();
-        MPI_Finalize();
-        return 1;
-    }
-
-    /* For now, track the error.
-     * Later, ignore if no daos args supplied */
-    rc = daos_init();
-    if (rc != 0) {
-        MFU_LOG(MFU_LOG_ERR, "Failed to initialize daos");
-        local_daos_error = true;
-    }
-
-    /* Figure out if daos path is the src or dst,
-     * using UNS path, then chop off UNS path
-     * prefix since the path is mapped to the root
-     * of the container in the DAOS DFS mount */
-    if (!local_daos_error
-            && (!daos_uuid_valid(src_pool_uuid) || !daos_uuid_valid(dst_pool_uuid))) {
-        rc = daos_set_paths(rank, argpaths, dfs_prefix, src_pool_uuid, src_cont_uuid,
-                dst_pool_uuid, dst_cont_uuid, mfu_src_file, mfu_dst_file);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
-                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
-            local_daos_error = true;
-        }
-    }
-
-    /* Re-check the required DAOS arguments (if any) */
-    if (!local_daos_error) {
-        rc = daos_check_args(rank, argpaths, src_pool_uuid, src_cont_uuid,
-                dst_pool_uuid, dst_cont_uuid, src_svc, dst_svc, dfs_prefix,
-                &flag_daos_args);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Invalid DAOS args: "
-                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS_INVAL_ARG));
-            local_daos_error = true;
-        }
-    }
-
-    /* Make sure there weren't any errors before continuing.
-     * Since daos_connect has a collective broadcast.
-     * we have to make sure same_pool below is valid. */
-    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
-        tmp_rc = daos_fini();
+    /* Early check to avoid extra processing.
+     * Will be further checked below. */
+    if ((argc-optind) < 2) {
+        MFU_LOG(MFU_LOG_ERR, "A source and destination path is needed: "
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_INVAL_ARG));
         mfu_finalize();
         MPI_Finalize();
         return 1;
     }
 
-    /* check if DAOS source and destination containers are in the same pool */
-    bool same_pool = false;
-    if (mfu_src_file->type == DAOS && mfu_dst_file->type == DAOS) {
-        if (uuid_compare(src_pool_uuid, dst_pool_uuid) == 0) {
-            same_pool = true;
-        }
-    }
-
-    /* connect to DAOS source pool if uuid is valid */
-    if (!local_daos_error && mfu_src_file->type == DAOS) {
-        /* Open pool connection, but do not create container if non-existent */
-        rc = daos_connect(rank, src_svc, src_pool_uuid, src_cont_uuid, &src_poh, &src_coh, true, false);
-        if (rc != 0) {
-            /* rc from daos_connect is collective */
-            local_daos_error = true;
-        }
-    }
-
-    /* If the source and destination are in the same pool,
-     * then open the container in that pool.
-     * Otherwise, connect to the second pool and open the container */
-    if (!local_daos_error && mfu_dst_file->type == DAOS) {
-        if (same_pool) {
-            /* Don't reconnect to pool, but do create container if non-existent */
-            rc = daos_connect(rank, dst_svc, dst_pool_uuid, dst_cont_uuid, &src_poh, &dst_coh, false, true);
-        } else {
-            /* Open pool connection, and create container if non-existent */
-            rc = daos_connect(rank, dst_svc, dst_pool_uuid, dst_cont_uuid, &dst_poh, &dst_coh, true, true); 
-        }
-        if (rc != 0) {
-            /* rc from daos_connect is collective */
-            local_daos_error = true;
-        }
-    }
-
-    if (!local_daos_error && mfu_src_file->type == DAOS) {
-        /* DFS is mounted for the source container */
-        rc = dfs_mount(src_poh, src_coh, O_RDWR, &dfs1);
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
-                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
-            local_daos_error = true;
-        }
-    }
-
-    if (!local_daos_error && mfu_dst_file->type == DAOS) {
-        /* DFS is mounted for the destination container */
-        if (same_pool) {
-            rc = dfs_mount(src_poh, dst_coh, O_RDWR, &dfs2);
-        } else {
-            rc = dfs_mount(dst_poh, dst_coh, O_RDWR, &dfs2);
-        }
-        if (rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
-                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
-            local_daos_error = true;
-        }
-    }
+    char** argpaths = (&argv[optind]);
 
-    /* Exit if any process had a daos error */
-    if (daos_any_error(rank, local_daos_error, flag_daos_args)) {
-        tmp_rc = daos_fini();
+#ifdef DAOS_SUPPORT
+    /* Set up DAOS arguments, containers, dfs, etc. */
+    rc = daos_setup(rank, argpaths, daos_args, mfu_src_file, mfu_dst_file);
+    if (rc != 0) {
         mfu_finalize();
         MPI_Finalize();
         return 1;
     }
-
-    /* set source and destination files to address of their
-     * DFS mount within DAOS */
-    mfu_src_file->dfs = dfs1;
-    mfu_dst_file->dfs = dfs2;
 #endif
 
     /* paths to walk come after the options */
@@ -855,10 +1019,10 @@ int main(int argc, char** argv)
     }
 
     /* copy flist into destination */ 
-    tmp_rc = mfu_flist_copy(flist, numpaths_src, paths,
+    rc = mfu_flist_copy(flist, numpaths_src, paths,
                             destpath, mfu_copy_opts, mfu_src_file,
                             mfu_dst_file);
-    if (tmp_rc < 0) {
+    if (rc < 0) {
         /* hit some sort of error during copy */
         rc = 1;
     }
@@ -881,49 +1045,9 @@ int main(int argc, char** argv)
     /* free the copy options */
     mfu_walk_opts_delete(&walk_opts);
 
-    /* DAOS: unmount DFS, and close containers and pools */
 #ifdef DAOS_SUPPORT
-    if (mfu_src_file->type == DAOS) {
-        tmp_rc = dfs_umount(mfu_src_file->dfs);
-        MPI_Barrier(MPI_COMM_WORLD);
-        if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to umount DFS namespace");
-        }
-        tmp_rc = daos_cont_close(src_coh, NULL);
-        MPI_Barrier(MPI_COMM_WORLD);
-        if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
-        }
-    }
-
-    if (mfu_dst_file->type == DAOS) {
-        tmp_rc = dfs_umount(mfu_dst_file->dfs);
-        MPI_Barrier(MPI_COMM_WORLD);
-        if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed unmount DFS namespace");
-        }
-        tmp_rc = daos_cont_close(dst_coh, NULL);
-        MPI_Barrier(MPI_COMM_WORLD);
-        if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to close container (%d)", rc);
-        }
-    }
-
-    if (mfu_src_file->type == DAOS) {
-        tmp_rc = daos_pool_disconnect(src_poh, NULL);
-        MPI_Barrier(MPI_COMM_WORLD);
-        if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from source pool");
-        }
-    }
-
-    if (mfu_dst_file->type == DAOS && !same_pool) {
-        tmp_rc = daos_pool_disconnect(dst_poh, NULL);
-        MPI_Barrier(MPI_COMM_WORLD);
-        if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to disconnect from destination pool");
-        }
-    }
+    /* Cleanup DAOS-related variables, etc. */
+    daos_cleanup(daos_args, mfu_src_file, mfu_dst_file);
 #endif
 
     /* free the mfu_file object */
@@ -938,11 +1062,6 @@ int main(int argc, char** argv)
         }
     }
 
-#ifdef DAOS_SUPPORT
-    /* finalize daos */
-    tmp_rc = daos_fini();
-#endif
-
     mfu_finalize();
 
     /* shut down MPI */

From f060ea28ae84d7409a3b08c344a7a4dd356906ae Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Wed, 16 Sep 2020 22:52:20 +0000
Subject: [PATCH 14/27] daos: include gurt common to remove compile warning

Add #include <gurt/common.h>
Thisremoves the compile warning for implicit
definition for d_rank_list_free

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_util.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 2ee49180..46cdb5b7 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -24,6 +24,10 @@
 #include <lustre/lustreapi.h>
 #endif
 
+#ifdef DAOS_SUPPORT
+#include <gurt/common.h>
+#endif
+
 int mfu_initialized = 0;
 
 /* set globals */

From 2b8a2fe63af2a8624b2301b05319028fc75e6594 Mon Sep 17 00:00:00 2001
From: Honwai Leong <hleong@ddn.com>
Date: Fri, 4 Sep 2020 17:09:28 +1000
Subject: [PATCH 15/27] dsync: Add Direct I/O support to dsync

Add in a "-s" option to dsync to enable direct I/O.

Signed-off-by: Honwai Leong <hleong@ddn.com>
---
 src/dsync/dsync.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index 1463f29e..f306538e 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -57,6 +57,7 @@ static void print_usage(void)
     printf("      --progress <N>    - print progress every N seconds\n");
     printf("  -v, --verbose         - verbose output\n");
     printf("  -q, --quiet           - quiet output\n");
+    printf("  -s, --synchronous     - use synchronous read/write calls(O_DIRECT)\n");
     printf("  -h, --help            - print usage\n");
     printf("\n");
     printf("For more information see https://mpifileutils.readthedocs.io.\n");
@@ -2826,6 +2827,7 @@ int main(int argc, char **argv)
         {"progress",      1, 0, 'P'},
         {"verbose",       0, 0, 'v'},
         {"quiet",         0, 0, 'q'},
+        {"synchronous",   0, 0, 's'},
         {"help",          0, 0, 'h'},
         {0, 0, 0, 0}
     };
@@ -2841,7 +2843,7 @@ int main(int argc, char **argv)
 
     while (1) {
         int c = getopt_long(
-            argc, argv, "b:cDo:Svqh",
+            argc, argv, "b:cDo:Svqsh",
             long_options, &option_index
         );
 
@@ -2891,6 +2893,12 @@ int main(int argc, char **argv)
              * disable the algorithm to save some overhead */
             mfu_progress_timeout = 0;
             break;
+        case 's':
+            mfu_copy_opts->synchronous = true;
+            if(rank == 0) {
+                MFU_LOG(MFU_LOG_INFO, "Using synchronous read/write (O_DIRECT)");
+            }
+            break;
         case 'h':
         case '?':
             usage = 1;

From 49a332b5a8628cc91dd00c1dcc95126c6a665ecf Mon Sep 17 00:00:00 2001
From: Honwai Leong <hleong@ddn.com>
Date: Tue, 8 Sep 2020 16:33:21 +1000
Subject: [PATCH 16/27] dsync: Speed up timestamp and metadata updates

This change speeds up the last stage in dsync, i.e.
updating timestamps on newly copied files.

Before this change, the mfu_flist_file_sync_meta function
has to walk through all files that have common existence in
both source and destination to check for difference
in metadata (uid, gid, perm, atime, and mtime), then
update the destination to match the source accordingly.

For large directory, metadata refresh spends a lot of
cycle time for a second walk through all the files.
As noted in dsync.c, this is not efficient, especially
if only a very small number of files require
metadata update.

This change updates dsync to leverage on existing
dsync_compare_metadata function do an earlier check on
the metadata (uid, gid and perm, atime, mtime) right
after the first walk, and include only those that
show DCMPS_DIFFER state (in either of DCMPF_UID, DCMPF_GID,
DCMPF_MTIME, DCMPF_ATIME or DCMPF_PERM field) to the
metadata_refresh array. Thus, the mfu_flist_file_sync_meta
function only needs to check and update as necessary on
a subset of files, instead of all the files again.

Signed-off-by: Honwai Leong <hleong@ddn.com>
---
 src/dsync/dsync.c | 27 ++++++++++++++++++++++++---
 1 file changed, 24 insertions(+), 3 deletions(-)

diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index f306538e..2cef389b 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -189,6 +189,11 @@ const char *dsync_default_outputs[] = {
     "EXIST=COMMON@TYPE=COMMON",
     "EXIST=DIFFER",
     "EXIST=COMMON",
+    "EXIST=COMMON@UID=DIFFER",
+    "EXIST=COMMON@GID=DIFFER",
+    "EXIST=COMMON@PERM=DIFFER",
+    "EXIST=COMMON@ATIME=DIFFER",
+    "EXIST=COMMON@MTIME=DIFFER",
     NULL,
 };
 
@@ -1591,9 +1596,6 @@ static int dsync_strmap_compare(
             continue;
         }
 
-        /* add any item that is in both source and destination to meta
-         * refresh list */
-        strmap_setf(metadata_refresh, "%llu=%llu", src_index, dst_index);
 
         /* item exists in both source and destination,
          * so update our state to record that fact */
@@ -1605,6 +1607,25 @@ static int dsync_strmap_compare(
              key);
         assert(tmp_rc >= 0);
 
+        /* add any item that is in both source and destination to meta
+         * refresh list, only include those that have different metadata. */
+        dsync_state uid_state, gid_state, perm_state, atime_state, mtime_state;
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_UID, &uid_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_GID, &gid_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_PERM, &perm_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_ATIME, &atime_state);
+        assert(tmp_rc == 0);
+        tmp_rc = dsync_strmap_item_state(src_map, key, DCMPF_MTIME, &mtime_state);
+        assert(tmp_rc == 0);
+        if ((uid_state == DCMPS_DIFFER) || (gid_state == DCMPS_DIFFER) ||
+            (perm_state == DCMPS_DIFFER) || (atime_state == DCMPS_DIFFER) ||
+            (mtime_state == DCMPS_DIFFER)) {
+            strmap_setf(metadata_refresh, "%llu=%llu", src_index, dst_index);
+        }
+
         /* Skip if no need to compare type.
          * All the following comparison depends on type. */
         if (!dsync_option_need_compare(DCMPF_TYPE)) {

From 867cb5e9d7e4abdf6b9fde763d94725a0893affa Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Fri, 18 Sep 2020 22:22:50 +0000
Subject: [PATCH 17/27] daos: daos_mknod implementation

daos_mknod is implemented in two steps:
1. dfs_open(..., O_CREATE,...)
2. dfs_release(...)

daos_mknod and daos_open will both default the
filetype in mode to be S_IFREG.
And if any other filetype is passed in, they
will return an error.

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_io.c | 70 ++++++++++++++++++++++++++++++++++++++++++---
 src/common/mfu_io.h |  2 +-
 2 files changed, 67 insertions(+), 5 deletions(-)

diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 332e8b87..7ad17142 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -449,10 +449,61 @@ int mfu_lstat64(const char* path, struct stat64* buf)
     return rc;
 }
 
-/* use a noop, daos does not have a mknod function */
+/* emulates mknod with dfs_open, dfs_release */
 int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
 {
-    return 0;
+#ifdef DAOS_SUPPORT
+    /* Only regular files are supported at this time */
+    mode_t dfs_mode = mode | S_IFREG;
+    mode_t filetype = dfs_mode & S_IFMT;
+    if (filetype != S_IFREG) {
+        MFU_LOG(MFU_LOG_ERR, "Invalid entry type (not a file)");
+        errno = EINVAL;
+        return -1;
+    }
+
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(path, &name, &dir_name);
+    assert(dir_name);
+
+    dfs_obj_t* parent = NULL;
+    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    if (parent == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+        errno = ENOENT;
+        rc = -1;
+    }
+    else {
+        /* create regular file */
+        rc = dfs_open(mfu_file->dfs, parent, name,
+                      dfs_mode, O_CREAT,
+                      0, 0, NULL, &(mfu_file->obj));
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_open %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
+            rc = -1;
+        }
+        else {
+            /* close the file */
+            rc = dfs_release(mfu_file->obj);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_release %s failed (%d %s)",
+                        path, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+        }
+        /* close the parent, ignoring errors since they have no direct impact */
+        dfs_release(parent);
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc;
+#endif
 }
 
 int mfu_mknod(const char* path, mode_t mode, dev_t dev)
@@ -581,9 +632,18 @@ int mfu_hardlink(const char* oldpath, const char* newpath)
 /*****************************
  * Files
  ****************************/
-void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
+int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
+    /* Only regular files are supported at this time */
+    mode_t dfs_mode = mode | S_IFREG;
+    mode_t filetype = dfs_mode & S_IFMT;
+    if (filetype != S_IFREG) {
+        MFU_LOG(MFU_LOG_ERR, "Invalid entry type (not a file)");
+        errno = EINVAL;
+        return -1;
+    }
+
     char* name     = NULL;
     char* dir_name = NULL;
     parse_filename(file, &name, &dir_name);
@@ -593,7 +653,7 @@ void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
     int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
     if (parent != NULL) {
         rc = dfs_open(mfu_file->dfs, parent, name,
-                      S_IFREG | mode, flags,
+                      dfs_mode, flags,
                       0, 0, NULL, &(mfu_file->obj));
         if (rc) {
             MFU_LOG(MFU_LOG_ERR, "dfs_open %s failed (%d %s)",
@@ -609,6 +669,8 @@ void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
 
     mfu_free(&name);
     mfu_free(&dir_name);
+
+    return rc;
 #endif
 }
 
diff --git a/src/common/mfu_io.h b/src/common/mfu_io.h
index e6d395b4..bcc96be3 100644
--- a/src/common/mfu_io.h
+++ b/src/common/mfu_io.h
@@ -114,7 +114,7 @@ int mfu_symlink(const char* oldpath, const char* newpath);
 
 /* open file with specified flags and mode, retry open a few times on failure */
 void mfu_file_open(const char* file, int flags, mfu_file_t* mfu_file, ...);
-void daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file);
+int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file);
 int mfu_open(const char* file, int flags, ...);
 
 /* close file */

From 492b278559937ad3aba1afa1b968517d4548d40e Mon Sep 17 00:00:00 2001
From: Adam Moody <moody20@llnl.gov>
Date: Sat, 19 Sep 2020 14:51:40 -0700
Subject: [PATCH 18/27] rename --synchronous to --direct, handle O_DIRECT short
 read/writes

Signed-off-by: Adam Moody <moody20@llnl.gov>
---
 doc/rst/dcmp.1.rst          |   4 +
 doc/rst/dcp.1.rst           |   5 +-
 doc/rst/dsync.1.rst         |   4 +
 src/common/mfu_flist_copy.c | 216 +++++++++++++------------------
 src/common/mfu_io.c         | 169 ++++++++++++++++++++++--
 src/common/mfu_io.h         |  10 ++
 src/common/mfu_param_path.h |   2 +-
 src/common/mfu_util.c       | 248 ++++++++++++++++++++++++------------
 src/common/mfu_util.h       |   3 +-
 src/dcmp/dcmp.c             |  48 +++++--
 src/dcp/dcp.c               |   7 +-
 src/dsync/dsync.c           | 101 ++++++++-------
 12 files changed, 531 insertions(+), 286 deletions(-)

diff --git a/doc/rst/dcmp.1.rst b/doc/rst/dcmp.1.rst
index 0e3067ba..40f39ac4 100644
--- a/doc/rst/dcmp.1.rst
+++ b/doc/rst/dcmp.1.rst
@@ -36,6 +36,10 @@ OPTIONS
 
    Enable base checks and normal stdout results when --output is used.
 
+.. option:: -s, --direct
+
+   Use O_DIRECT to avoid caching file data.
+
 .. option:: --progress N
 
    Print progress message to stdout approximately every N seconds.
diff --git a/doc/rst/dcp.1.rst b/doc/rst/dcp.1.rst
index 599eb0b4..230f6f8c 100644
--- a/doc/rst/dcp.1.rst
+++ b/doc/rst/dcp.1.rst
@@ -67,10 +67,9 @@ OPTIONS
 
    Preserve permissions, group, timestamps, and extended attributes.
 
-.. option:: -s, --synchronous
+.. option:: -s, --direct
 
-   Use synchronous read/write calls (open files with O_DIRECT).
-   This also avoids caching the file data on the client nodes.
+   Use O_DIRECT to avoid caching file data.
 
 .. option:: -S, --sparse
 
diff --git a/doc/rst/dsync.1.rst b/doc/rst/dsync.1.rst
index c3dfa24e..6eac6338 100644
--- a/doc/rst/dsync.1.rst
+++ b/doc/rst/dsync.1.rst
@@ -35,6 +35,10 @@ OPTIONS
 
    Delete extraneous files from destination.
 
+.. option:: -s, --direct
+
+   Use O_DIRECT to avoid caching file data.
+
 .. option:: --link-dest DIR
 
    Create hardlink in DEST to files in DIR when file is unchanged
diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index d1345b68..c718dbf7 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -128,14 +128,14 @@ static void mfu_copy_open_file(const char* file, int read_flag,
     /* open the new file */
     if (read_flag) {
         int flags = O_RDONLY;
-        if (mfu_copy_opts->synchronous) {
+        if (mfu_copy_opts->direct) {
             flags |= O_DIRECT;
         }
         /* set obj or fd here */
         mfu_file_open(file, flags, mfu_file);
     } else {
         int flags = O_WRONLY | O_CREAT;
-        if (mfu_copy_opts->synchronous) {
+        if (mfu_copy_opts->direct) {
             flags |= O_DIRECT;
         }
         /* set obj or fd here */
@@ -1556,30 +1556,6 @@ static int mfu_is_all_null(const char* buf, uint64_t buf_size)
     return 1;
 }
 
-/* when using sparse files, we need to write the last byte if the
- * hole is adjacent to EOF, so we need to detect whether we're at
- * the end of the file */
-static int mfu_is_eof(const char* file, mfu_file_t* mfu_file)
-{
-    /* read one byte from fd to determine whether this is EOF.
-     * This is not efficient, but it is the only reliable way */
-    char buf[1];
-    ssize_t num_of_bytes_read = mfu_file_read(file, buf, 1, mfu_file);
-
-    /* return if we detect EOF */
-    if(! num_of_bytes_read) {
-        return 1;
-    }
-
-    /* otherwise, we're not at EOF yet, seek back one byte */
-    if(mfu_file_lseek(file, mfu_file, -1, SEEK_CUR) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in path `%s' (errno=%d %s)",
-                  file, errno, strerror(errno));
-        return -1;
-    }
-    return 0;
-}
-
 static int mfu_copy_file_normal(
     const char* src,
     const char* dest,
@@ -1590,60 +1566,77 @@ static int mfu_copy_file_normal(
     mfu_file_t* mfu_src_file,
     mfu_file_t* mfu_dst_file)
 {
-    /* There is no equivalent "lseek" in daos, it is part of read, so skip that
-     * for a DAOS path */
-    /* seek to offset in source file */
-    if(mfu_file_lseek(src, mfu_src_file, offset, SEEK_SET) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in source path `%s' (errno=%d %s)", src, errno, strerror(errno));
-        return -1;
-    }
-
-    /* seek to offset in destination file */
-    if (mfu_file_lseek(dest, mfu_dst_file, offset, SEEK_SET) == (off_t)-1) {
-        MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)", dest, errno, strerror(errno));
-        return -1;
-    }
-
     /* set buffer and buffer size */
     size_t buf_size = mfu_copy_opts->block_size;
     void* buf       = mfu_copy_opts->block_buf1;
 
+    /* for O_DIRECT, check that length is multiple of block_size */
+    if (mfu_copy_opts->direct &&       /* using O_DIRECT */
+        offset + length < file_size && /* not at end of file */
+        length % buf_size != 0)        /* length not an integer multiple of block size */
+    {
+        MFU_ABORT(-1, "O_DIRECT requires chunk size to be integer multiple of block size %llu",
+            buf_size);
+    }
+
+    /* initialize our starting offset within the file */
+    off_t off = offset;
+
     /* write data */
-    size_t total_bytes = 0;
-    while(total_bytes < (size_t)length) {
-        /* determine number of bytes that we
-         * can read = max(buf size, remaining chunk) */
-        size_t left_to_read = (size_t)length - total_bytes;
-        
-        if(left_to_read > buf_size) {
-            left_to_read = buf_size;
+    uint64_t total_bytes = 0;
+    while (total_bytes < length) {
+        /* determine number of bytes to read,
+         * O_DIRECT requires read operation of certain size blocks,
+         * even if we know that would run past the end of the file */
+        size_t left_to_read = buf_size;
+        if (! mfu_copy_opts->direct) {
+            uint64_t remainder = length - total_bytes;
+            if (remainder < (uint64_t) buf_size) {
+                left_to_read = (size_t) remainder;
+            }
         }
 
-        if(mfu_copy_opts->synchronous) {
-            /* O_DIRECT requires particular read sizes */
-            left_to_read = buf_size;
+        /* read data from source file */
+        ssize_t bytes_read = mfu_file_pread(src, buf, left_to_read, off, mfu_src_file);
+
+        /* If we're using O_DIRECT, deal with short reads.
+         * Retry with same buffer and offset since those must
+         * be aligned at block boundaries. */
+        while (mfu_copy_opts->direct &&        /* using O_DIRECT */
+               bytes_read > 0 &&               /* read was not an error or eof */
+               bytes_read < left_to_read &&    /* shorter than requested */
+               (off + bytes_read) < file_size) /* not at end of file */
+        {
+            /* TODO: probably should retry a limited number of times then abort */
+            bytes_read = mfu_file_pread(src, buf, left_to_read, off, mfu_src_file);
         }
 
-        /* read data from source file */
-        ssize_t num_of_bytes_read = mfu_file_read(src, buf, left_to_read, mfu_src_file);
+        /* check for an error */
+        if (bytes_read < 0) {
+            MFU_LOG(MFU_LOG_ERR, "Read error when copying from `%s' to `%s' (errno=%d %s)",
+                src, dest, errno, strerror(errno));
+            return -1;
+        }
 
-        /* check for EOF */
-        if(! num_of_bytes_read) {
-            break;
+        /* check for early EOF */
+        if (bytes_read == 0) {
+            MFU_LOG(MFU_LOG_ERR, "Source file `%s' shorter than expected %llu (errno=%d %s)",
+                src, file_size, errno, strerror(errno));
+            return -1;
         }
 
         /* compute number of bytes to write */
-        size_t bytes_to_write = (size_t) num_of_bytes_read;
-        if(mfu_copy_opts->synchronous) {
+        size_t bytes_to_write = (size_t) bytes_read;
+        if (mfu_copy_opts->direct) {
             /* O_DIRECT requires particular write sizes,
              * ok to write beyond end of file so long as
              * we truncate in cleanup step */
-            size_t remainder = buf_size - (size_t) num_of_bytes_read;
-            if(remainder > 0) {
+            size_t remainder = buf_size - (size_t) bytes_read;
+            if (remainder > 0) {
                 /* zero out the end of the buffer for security,
                  * don't want to leave data from another file at end of
                  * current file if we fail before truncating */
-                char* bufzero = ((char*)buf + num_of_bytes_read);
+                char* bufzero = ((char*)buf + bytes_read);
                 memset(bufzero, 0, remainder);
             }
 
@@ -1651,68 +1644,46 @@ static int mfu_copy_file_normal(
             bytes_to_write = buf_size;
         }
 
-        /* Write data to destination file.
-         * Do nothing for a hole in the middle of a file,
-         * because write of next chunk will create one for us.
-         * Write only the last byte to create the hole,
-         * if the hole is next to EOF. */
-        /* TODO: add code for daos api to support sparse files? */
-        ssize_t num_of_bytes_written = (ssize_t)bytes_to_write;
+        /* If in sparse mode, skip writing out blocks that are all 0.
+         * Rely on posix hole semantics to account for those 0 values instead.
+         * If this hole is at the end of the file, the truncate below will
+         * set the file size correctly. */
+        int skip_write = 0;
         if (mfu_copy_opts->sparse && mfu_is_all_null(buf, bytes_to_write)) {
-            /* TODO: isn't there a better way to know if we're at EOF,
-             * e.g., by using file size? */
-            /* determine whether we're at the end of the file */
-            int end_of_file = mfu_is_eof(src, mfu_src_file);
-            if (end_of_file < 0) {
-                /* hit an error while looking for EOF */
-                return -1;
-            }
+            skip_write = 1;
+        }
 
-            /* if we're at the end of the file, write out a byte,
-             * otherwise just seek out destination file pointer
-             * ahead without writing anything */
-            if (end_of_file) {
-                /* seek to last byte position in file */
-                if(mfu_file_lseek(dest, mfu_dst_file, (off_t)bytes_to_write - 1, SEEK_CUR) == (off_t)-1) {
-                    MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
-                        dest, errno, strerror(errno));
+        /* write data to destination file if needed */
+        if (! skip_write) {
+            /* we loop to account for short writes */
+            ssize_t n = 0;
+            while (n < bytes_to_write) {
+                /* write bytes to destination file */
+                ssize_t bytes_written = mfu_file_pwrite(dest, ((char*)buf) + n, bytes_to_write - n, off + n, mfu_dst_file);
+
+                /* check for an error */
+                if (bytes_written < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s' (errno=%d %s)",
+                        src, dest, errno, strerror(errno));
                     return -1;
                 }
 
-                /* write out a single byte */
-                mfu_file_write(dest, buf, 1, mfu_dst_file);
-            } else {
-                /* this section of the destination file is all 0,
-                 * seek past this section */
-                if(mfu_file_lseek(dest, mfu_dst_file, (off_t)bytes_to_write, SEEK_CUR) == (off_t)-1) {
-                    MFU_LOG(MFU_LOG_ERR, "Couldn't seek in destination path `%s' (errno=%d %s)",
-                        dest, errno, strerror(errno));
-                    return -1;
+                /* So long as we're not using O_DIRECT, we can handle short writes
+                 * by advancing by the number of bytes written.  For O_DIRECT, we
+                 * need to keep buffer, file offset, and amount to write aligned
+                 * on block boundaries, so just retry the entire operation. */
+                if (!mfu_copy_opts->direct || bytes_written == bytes_to_write) {
+                    n += bytes_written;
                 }
             }
-        } else {
-            /* write bytes to destination file */
-            num_of_bytes_written = mfu_file_write(dest, buf, bytes_to_write, mfu_dst_file);
-        }
-
-        /* check for an error */
-        if(num_of_bytes_written < 0) {
-            MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s' (errno=%d %s)",
-                src, dest, errno, strerror(errno));
-            return -1;
         }
 
-        /* check that we wrote the same number of bytes that we read */
-        if((size_t)num_of_bytes_written != bytes_to_write) {
-            MFU_LOG(MFU_LOG_ERR, "Write error when copying from `%s' to `%s'",
-                src, dest);
-            return -1;
-        }
-
-        total_bytes += (size_t) num_of_bytes_read;
+        /* update current offset and accumulate number of bytes copied */
+        off += (off_t) bytes_read;
+        total_bytes += (uint64_t) bytes_read;
 
         /* update number of bytes we have copied for progress messages */
-        copy_count += (uint64_t) num_of_bytes_read;
+        copy_count += (uint64_t) bytes_read;
         mfu_progress_update(&copy_count, copy_prog);
     }
 
@@ -1722,17 +1693,11 @@ static int mfu_copy_file_normal(
 
 #if 0
     /* force data to file system */
-    if(total_bytes > 0) {
+    if (total_bytes > 0) {
         mfu_fsync(dest, out_fd);
     }
 #endif
 
-    /* no need to truncate if sparse file is enabled,
-     * since we truncated files when they were first created */
-    if (mfu_copy_opts->sparse) {
-        return 0;
-    }
-
     /* if we wrote the last chunk, truncate the file */
     off_t last_written = offset + length;
     off_t file_size_offt = (off_t) file_size;
@@ -1740,15 +1705,13 @@ static int mfu_copy_file_normal(
         /* Use ftruncate() here rather than truncate(), because grouplock
          * of Lustre would cause block to truncate() since the fd is different
          * from the out_fd. */
-        if(mfu_file_ftruncate(mfu_dst_file, file_size_offt) < 0) {
+        if (mfu_file_ftruncate(mfu_dst_file, file_size_offt) < 0) {
             MFU_LOG(MFU_LOG_ERR, "Failed to truncate destination file: %s (errno=%d %s)",
                 dest, errno, strerror(errno));
             return -1;
         }
     }
 
-    /* we don't bother closing the file because our cache does it for us */
-
     return 0;
 }
 
@@ -1764,7 +1727,7 @@ static int mfu_copy_file_fiemap(
     mfu_file_t* mfu_dst_file)
 {
     *normal_copy_required = true;
-    if (mfu_copy_opts->synchronous) {
+    if (mfu_copy_opts->direct) {
         goto fail_normal_copy;
     }
 
@@ -1938,9 +1901,7 @@ static int mfu_copy_file(
     mfu_file_t* mfu_dst_file)
 {
     int ret;
-    bool normal_copy_required;
 
-    
     /* open the input file */
     mfu_copy_open_file(src, 1, &mfu_copy_src_cache,
                        mfu_copy_opts, mfu_src_file);
@@ -1959,6 +1920,7 @@ static int mfu_copy_file(
     }
 
     if (mfu_copy_opts->sparse) {
+        bool normal_copy_required;
         ret = mfu_copy_file_fiemap(src, dest, offset, length, file_size,
                                &normal_copy_required, mfu_copy_opts,
                                mfu_src_file, mfu_dst_file);
@@ -2721,7 +2683,7 @@ static int mfu_fill_file(
         }
 
         /* compute number of bytes to write */
-        if (mfu_copy_opts->synchronous) {
+        if (mfu_copy_opts->direct) {
             /* O_DIRECT requires particular write sizes,
              * ok to write beyond end of file so long as
              * we truncate in cleanup step */
@@ -3184,7 +3146,7 @@ mfu_copy_opts_t* mfu_copy_opts_new(void)
     opts->preserve      = false;
 
     /* By default, don't use O_DIRECT. */
-    opts->synchronous   = false;
+    opts->direct        = false;
 
     /* By default, don't use sparse file. */
     opts->sparse        = false;
diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 7ad17142..cd0dbfc6 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -873,17 +873,18 @@ ssize_t mfu_file_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_
 ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
-    daos_size_t got_size;
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, buf, size);
 
+    /* define scatter-gather list for dfs_read */
     d_sg_list_t sgl;
-    d_iov_t     iov;
-
     sgl.sg_nr = 1;
-    d_iov_set(&iov, buf, size);
     sgl.sg_iovs = &iov;
     sgl.sg_nr_out = 1;
-    sgl.sg_iovs[0].iov_len = size;
 
+    /* execute read operation */
+    daos_size_t got_size;
     int rc = dfs_read(mfu_file->dfs, mfu_file->obj, &sgl, mfu_file->offset, &got_size, NULL); 
     if (rc) {
         MFU_LOG(MFU_LOG_ERR, "dfs_read %s failed (%d %s)",
@@ -891,7 +892,10 @@ ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file
         errno = rc;
         return -1;
     }
+
+    /* update file pointer with number of bytes read */
     mfu_file->offset += (daos_off_t)got_size;
+
     return (ssize_t)got_size;
 #endif
 }
@@ -949,7 +953,7 @@ ssize_t mfu_file_write(const char* file, const void* buf, size_t size, mfu_file_
 
 ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size)
 {
-    int tries = 10;
+    int tries = MFU_IO_TRIES;
     ssize_t n = 0;
     while ((size_t)n < size) {
         errno = 0;
@@ -985,15 +989,18 @@ ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size)
 ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
-    d_sg_list_t sgl;
-    d_iov_t     iov;
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, buf, size);
 
+    /* define scatter-gather list for dfs_write */
+    d_sg_list_t sgl;
     sgl.sg_nr = 1;
-    d_iov_set(&iov, buf, size);
     sgl.sg_iovs = &iov;
     sgl.sg_nr_out = 1;
-    sgl.sg_iovs[0].iov_len = size;
 
+    /* execute write operation,
+     * dfs_write writes all bytes if there is no error */
     int rc = dfs_write(mfu_file->dfs, mfu_file->obj, &sgl, mfu_file->offset, NULL); 
     if (rc) {
         MFU_LOG(MFU_LOG_ERR, "dfs_write %s failed (%d %s)",
@@ -1001,7 +1008,149 @@ ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* m
         errno = rc;
         return -1;
     }
+
+    /* update file pointer with number of bytes written */
     mfu_file->offset += (daos_off_t)size;
+
+    return (ssize_t)size;
+#endif
+}
+
+/* reliable pread from file descriptor (retries, if necessary, until hard error) */
+ssize_t mfu_file_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_pread(file, mfu_file->fd, buf, size, offset);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_pread(file, buf, size, offset, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+            file, mfu_file->type);
+    }
+}
+
+ssize_t daos_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, buf, size);
+
+    /* define scatter-gather list for dfs_read */
+    d_sg_list_t sgl;
+    sgl.sg_nr = 1;
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+
+    /* execute read operation */
+    daos_size_t got_size;
+    int rc = dfs_read(mfu_file->dfs, mfu_file->obj, &sgl, offset, &got_size, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_read %s failed (%d %s)",
+            file, rc, strerror(rc));
+        errno = rc;
+        return -1;
+    }
+
+    return (ssize_t)got_size;
+#endif
+}
+
+ssize_t mfu_pread(const char* file, int fd, void* buf, size_t size, off_t offset)
+{
+    int tries = MFU_IO_TRIES;
+    while (1) {
+        ssize_t rc = pread(fd, (char*) buf, size, offset);
+        if (rc > 0) {
+            /* read some data */
+            return rc;
+        }
+        else if (rc == 0) {
+            /* EOF */
+            return rc;
+        }
+        else {   /* (rc < 0) */
+            /* something worth printing an error about */
+            tries--;
+            if (tries <= 0) {
+                /* too many failed retries, give up */
+                MFU_ABORT(-1, "Failed to read file %s errno=%d (%s)",
+                    file, errno, strerror(errno));
+            }
+
+            /* sleep a bit before consecutive tries */
+            usleep(MFU_IO_USLEEP);
+        }
+    }
+}
+
+ssize_t mfu_file_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        ssize_t rc = mfu_pwrite(file, mfu_file->fd, buf, size, offset);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        ssize_t rc = daos_pwrite(file, buf, size, offset, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known: %s type=%d",
+            file, mfu_file->type);
+    }
+}
+
+ssize_t mfu_pwrite(const char* file, int fd, const void* buf, size_t size, off_t offset)
+{
+    int tries = MFU_IO_TRIES;
+    while (1) {
+        ssize_t rc = pwrite(fd, (const char*) buf, size, offset);
+        if (rc > 0) {
+            /* wrote some data */
+            return rc;
+        }
+        else if (rc == 0) {
+            /* didn't write anything, but not an error either */
+            return rc;
+        }
+        else { /* (rc < 0) */
+            /* something worth printing an error about */
+            tries--;
+            if (tries <= 0) {
+                /* too many failed retries, give up */
+                MFU_ABORT(-1, "Failed to write file %s errno=%d (%s)",
+                    file, errno, strerror(errno));
+            }
+
+            /* sleep a bit before consecutive tries */
+            usleep(MFU_IO_USLEEP);
+        }
+    }
+}
+
+ssize_t daos_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    /* record address and size of user buffer in io vector */
+    d_iov_t iov;
+    d_iov_set(&iov, buf, size);
+
+    /* define scatter-gather list for dfs_write */
+    d_sg_list_t sgl;
+    sgl.sg_nr = 1;
+    sgl.sg_iovs = &iov;
+    sgl.sg_nr_out = 1;
+
+    /* execute write operation,
+     * dfs_write writes all bytes if there is no error */
+    int rc = dfs_write(mfu_file->dfs, mfu_file->obj, &sgl, offset, NULL); 
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_write %s failed (%d %s)",
+                file, rc, strerror(rc));
+        errno = rc;
+        return -1;
+    }
+
     return (ssize_t)size;
 #endif
 }
diff --git a/src/common/mfu_io.h b/src/common/mfu_io.h
index bcc96be3..0784d326 100644
--- a/src/common/mfu_io.h
+++ b/src/common/mfu_io.h
@@ -138,6 +138,16 @@ ssize_t mfu_file_write(const char* file, const void* buf, size_t size, mfu_file_
 ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* mfu_file);
 ssize_t mfu_write(const char* file, int fd, const void* buf, size_t size);
 
+/* pread from opened file descriptor (may return short read) */
+ssize_t mfu_file_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t daos_pread(const char* file, void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t mfu_pread(const char* file, int fd, void* buf, size_t size, off_t offset);
+
+/* pwrite to opened file descriptor (may return short write) */
+ssize_t mfu_file_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t daos_pwrite(const char* file, const void* buf, size_t size, off_t offset, mfu_file_t* mfu_file);
+ssize_t mfu_pwrite(const char* file, int fd, const void* buf, size_t size, off_t offset);
+
 /* truncate a file */
 int mfu_truncate(const char* file, off_t length);
 
diff --git a/src/common/mfu_param_path.h b/src/common/mfu_param_path.h
index e1ab1167..59609d90 100644
--- a/src/common/mfu_param_path.h
+++ b/src/common/mfu_param_path.h
@@ -109,7 +109,7 @@ typedef struct {
     char*  dest_path;     /* prefex of destination directory */
     char*  input_file;    /* file name of input list */
     bool   preserve;      /* whether to preserve timestamps, ownership, permissions, etc. */
-    bool   synchronous;   /* whether to use O_DIRECT */
+    bool   direct;        /* whether to use O_DIRECT */
     bool   sparse;        /* whether to create sparse files */
     size_t chunk_size;    /* size to chunk files by */
     size_t block_size;    /* block size to read/write to file system */
diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 46cdb5b7..69efedff 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -843,33 +843,57 @@ int mfu_compare_contents(
     const char* dst_name,          /* IN  - path name to destination file */
     off_t offset,                  /* IN  - offset with file to start comparison */
     off_t length,                  /* IN  - number of bytes to be compared */
-    size_t bufsize,                /* IN  - size of I/O buffer to be used during compare */
+    off_t file_size,               /* IN  - size of file */
     int overwrite,                 /* IN  - whether to replace dest with source contents (1) or not (0) */
+    mfu_copy_opts_t* copy_opts,    /* IN - options for data compare/copy step */
     uint64_t* count_bytes_read,    /* OUT - number of bytes read (src + dest) */
     uint64_t* count_bytes_written, /* OUT - number of bytes written to dest */
     mfu_progress* prg)             /* IN  - progress message structure */
 {
+    /* extract values from copy options */
+    int direct = copy_opts->direct;
+    size_t buf_size = copy_opts->block_size;
+
+    /* for O_DIRECT, check that length is a multiple of buf_size */
+    if (direct &&                      /* using O_DIRECT */
+        offset + length < file_size && /* not at end of file */
+        length % buf_size != 0)        /* length not an integer multiple of block size */
+    {
+        MFU_ABORT(-1, "O_DIRECT requires chunk size to be integer multiple of block size %llu",
+            buf_size);
+    }
+
+    /* open source as read only, with optional O_DIRECT */
+    int src_flags = O_RDONLY;
+    if (direct) {
+        src_flags |= O_DIRECT;
+    }
+
     /* open source file */
-    int src_fd = mfu_open(src_name, O_RDONLY);
+    int src_fd = mfu_open(src_name, src_flags);
     if (src_fd < 0) {
         /* log error if there is an open failure on the src side */
         MFU_LOG(MFU_LOG_ERR, "Failed to open `%s' (errno=%d %s)",
-          src_name, errno, strerror(errno));
+            src_name, errno, strerror(errno));
        return -1;
     }
 
-    /* avoid opening file in write mode if we're only reading */
+    /* avoid opening file in write mode if we're only reading,
+     * optionally enable O_DIRECT */
     int dst_flags = O_RDONLY;
     if (overwrite) {
         dst_flags = O_RDWR;
     }
+    if (direct) {
+        dst_flags |= O_DIRECT;
+    }
 
     /* open destination file */
     int dst_fd = mfu_open(dst_name, dst_flags);
     if (dst_fd < 0) {
         /* log error if there is an open failure on the dst side */
         MFU_LOG(MFU_LOG_ERR, "Failed to open `%s' (errno=%d %s)",
-          dst_name, errno, strerror(errno));
+            dst_name, errno, strerror(errno));
         mfu_close(src_name, src_fd);
         return -1;
     }
@@ -881,53 +905,62 @@ int mfu_compare_contents(
     /* assume we'll find that file contents are the same */
     int rc = 0;
 
-    /* seek to offset in source file */
-    if (mfu_lseek(src_name, src_fd, offset, SEEK_SET) == (off_t)-1) {
-        /* log error if there is an lseek failure on the src side */
-        MFU_LOG(MFU_LOG_ERR, "Failed to lseek `%s', offset: %lx (errno=%d %s)",
-          src_name, (unsigned long)offset, errno, strerror(errno));
-        mfu_close(dst_name, dst_fd);
-        mfu_close(src_name, src_fd);
-        return -1;
-    }
+    /* TODO: replace this with mfu_copy_opts->buf */
+    /* allocate buffer to write files, aligned on 1MB boundaraies */
+    size_t alignment = 1024*1024;
+    void* src_buf = (char*) MFU_MEMALIGN(buf_size, alignment);
+    void* dst_buf = (char*) MFU_MEMALIGN(buf_size, alignment);
 
-    /* seek to offset in destination file */
-    if (mfu_lseek(dst_name, dst_fd, offset, SEEK_SET) == (off_t)-1) {
-        /* log error if there is an lseek failure on the dst side */
-        MFU_LOG(MFU_LOG_ERR, "Failed to lseek `%s', offset: %lx (errno=%d %s)",
-          dst_name, (unsigned long)offset, errno, strerror(errno));
-        mfu_close(dst_name, dst_fd);
-        mfu_close(src_name, src_fd);
-        return -1;
-    }
+    /* initialize our starting offset within the file */
+    off_t off = offset;
 
-    /* allocate buffers to read file data */
-    void* src_buf  = MFU_MALLOC(bufsize);
-    void* dest_buf = MFU_MALLOC(bufsize);
+    /* if we write with O_DIRECT, we may need to truncate file */
+    int need_truncate = 0;
 
     /* read and compare data from files */
     off_t total_bytes = 0;
-    while (length == 0 || total_bytes < length) {
-        /* track current position in file for error reporting and seeking */
-        off_t pos = offset + total_bytes;
-
+    while (total_bytes < length) {
         /* whether we should copy the source bytes to the destination */
         int need_copy = 0;
 
         /* determine number of bytes to read in this iteration */
-        size_t left_to_read = bufsize;
-        if (length > 0) {
-            if (length - total_bytes < (off_t)bufsize) {
-                left_to_read = (size_t)(length - total_bytes);
+        size_t left_to_read = buf_size;
+        if (! direct) {
+            off_t remainder = length - total_bytes;
+            if (remainder < (off_t)buf_size) {
+                left_to_read = (size_t) remainder;
             }
         }
 
         /* read data from source file */
-        ssize_t src_read = mfu_read(src_name, src_fd, (ssize_t*)src_buf, left_to_read);
+        ssize_t src_read = mfu_pread(src_name, src_fd, (ssize_t*)src_buf, left_to_read, off);
+
+        /* If we're using O_DIRECT, deal with short reads.
+         * Retry with same buffer and offset since those must
+         * be aligned at block boundaries. */
+        while (direct &&                     /* using O_DIRECT */
+               src_read > 0 &&               /* read was not an error or eof */
+               src_read < left_to_read &&    /* shorter than requested */
+               (off + src_read) < file_size) /* not at end of file */
+        {
+            /* TODO: probably should retry a limited number of times then abort */
+            src_read = mfu_pread(src_name, src_fd, src_buf, left_to_read, off);
+        }
+
+        /* check for read error */
         if (src_read < 0) {
             /* hit a read error */
             MFU_LOG(MFU_LOG_ERR, "Failed to read `%s' at offset %llx (errno=%d %s)",
-              src_name, (unsigned long long)pos, errno, strerror(errno));
+                src_name, (unsigned long long)off, errno, strerror(errno));
+            rc = -1;
+            break;
+        }
+
+        /* check for early EOF */
+        if (src_read == 0) {
+            /* if the source is shorter than expected, consider this to be an error */
+            MFU_LOG(MFU_LOG_ERR, "Source `%s' is shorter %llx than expected (errno=%d %s)",
+                src_name, (unsigned long long)off, errno, strerror(errno));
             rc = -1;
             break;
         }
@@ -936,11 +969,34 @@ int mfu_compare_contents(
         *count_bytes_read += (uint64_t) src_read;
 
         /* read data from destination file */
-        ssize_t dst_read = mfu_read(dst_name, dst_fd, (ssize_t*)dest_buf, left_to_read);
+        ssize_t dst_read = mfu_pread(dst_name, dst_fd, (ssize_t*)dst_buf, left_to_read, off);
+
+        /* If we're using O_DIRECT, deal with short reads.
+         * Retry with same buffer and offset since those must
+         * be aligned at block boundaries. */
+        while (direct &&                     /* using O_DIRECT */
+               dst_read > 0 &&               /* read was not an error or eof */
+               dst_read < left_to_read &&    /* shorter than requested */
+               (off + dst_read) < file_size) /* not at end of file */
+        {
+            /* TODO: probably should retry a limited number of times then abort */
+            dst_read = mfu_pread(dst_name, dst_fd, dst_buf, left_to_read, off);
+        }
+
+        /* check for read error */
         if (dst_read < 0) {
             /* hit a read error */
             MFU_LOG(MFU_LOG_ERR, "Failed to read `%s' at offset %llx (errno=%d %s)",
-              dst_name, (unsigned long long)pos, errno, strerror(errno));
+                dst_name, (unsigned long long)off, errno, strerror(errno));
+            rc = -1;
+            break;
+        }
+
+        /* check for early EOF */
+        if (dst_read == 0) {
+            /* destination is shorter than expected, consider this to be an error */
+            MFU_LOG(MFU_LOG_ERR, "Destination `%s' is shorter than expected %llx (errno=%d %s)",
+                dst_name, (unsigned long long)off, errno, strerror(errno));
             rc = -1;
             break;
         }
@@ -948,13 +1004,17 @@ int mfu_compare_contents(
         /* tally up number of bytes read */
         *count_bytes_read += (uint64_t) dst_read;
 
-        /* TODO: could be a non-error short read, we could just adjust number
+        /* we could have a non-error short read, so adjust number
          * of bytes we compare and update offset to shorter of the two values
          * numread = min(src_read, dst_read) */
+        ssize_t min_read = src_read;
+        if (dst_read < min_read) {
+            min_read = dst_read;
+        }
 
-        /* check that we got the same number of bytes from each */
-        if (src_read != dst_read) {
-            /* one read came up shorter than the other */
+        /* if have same size buffers, and read some data, let's check the contents */
+        if (memcmp((ssize_t*)src_buf, (ssize_t*)dst_buf, (size_t)min_read) != 0) {
+            /* memory contents are different */
             rc = 1;
             if (! overwrite) {
                 break;
@@ -962,53 +1022,63 @@ int mfu_compare_contents(
             need_copy = 1;
         }
 
-        /* check for EOF */
-        if (src_read == 0) {
-            /* hit end of source file */
-            break;
-        }
+        /* if the bytes are different,
+         * then copy the bytes from the source into the destination */
+        if (overwrite && need_copy) {
+            /* compute number of bytes to write */
+            size_t bytes_to_write = (size_t) min_read;
+            if (direct) {
+                /* O_DIRECT requires particular write sizes,
+                 * ok to write beyond end of file so long as
+                 * we truncate in cleanup step */
+                size_t remainder = buf_size - (size_t) min_read;
+                if (remainder > 0) {
+                    /* zero out the end of the buffer for security,
+                     * don't want to leave data from another file at end of
+                     * current file if we fail before truncating */
+                    char* bufzero = ((char*)src_buf + min_read);
+                    memset(bufzero, 0, remainder);
+
+                    /* remember that we might need to truncate,
+                     * because we may write past the end of the file */
+                    need_truncate = 1;
+                }
 
-        /* if have same size buffers, and read some data, let's check the contents */
-        if (src_read == dst_read) {
-            if (memcmp((ssize_t*)src_buf, (ssize_t*)dest_buf, (size_t)src_read) != 0) {
-                /* memory contents are different */
-                rc = 1;
-                if (! overwrite) {
+                /* assumes buf_size is magic size for O_DIRECT */
+                bytes_to_write = buf_size;
+            }
+
+            /* we loop to account for short writes */
+            ssize_t n = 0;
+            while (n < bytes_to_write) {
+                /* write data to destination file */
+                ssize_t bytes_written = mfu_pwrite(dst_name, dst_fd, ((char*)src_buf) + n, bytes_to_write - n, off + n);
+
+                /* check for write error */
+                if (bytes_written < 0) {
+                    MFU_LOG(MFU_LOG_ERR, "Failed to write `%s' at offset %llx (errno=%d %s)", 
+                        dst_name, (unsigned long long)off + n, strerror(errno));
+                    rc = -1;
                     break;
                 }
-                need_copy = 1;
-            }
-        }
 
-        /* if the bytes are different,
-         * then copy the bytes from the source into the destination */
-        if (overwrite && need_copy == 1) {
-            /* seek back to position to write to in destination file */
-            if (mfu_lseek(dst_name, dst_fd, pos, SEEK_SET) == (off_t)-1) {
-                /* log error if there is an lseek failure on the dst side */
-                MFU_LOG(MFU_LOG_ERR, "Failed to lseek `%s', offset: %llx (errno=%d %s)",
-                  dst_name, (unsigned long long)pos, strerror(errno));
-                rc = -1;
-                break;
-            }
+                /* So long as we're not using O_DIRECT, we can handle short writes
+                 * by advancing by the number of bytes written.  For O_DIRECT, we
+                 * need to keep buffer, file offset, and amount to write aligned
+                 * on block boundaries, so just retry the entire operation. */
+                if (!direct || bytes_written == bytes_to_write) {
+                    /* advance index by number of bytes written */
+                    n += bytes_written;
 
-            /* write data to destination file */
-            size_t bytes_to_write = (size_t) src_read;
-            ssize_t bytes_written = mfu_write(dst_name, dst_fd, src_buf, bytes_to_write);
-            if (bytes_written < 0) {
-                /* hit a write error */
-                MFU_LOG(MFU_LOG_ERR, "Failed to write `%s' at offset %llx (errno=%d %s)",
-                  dst_name, (unsigned long long)pos, strerror(errno));
-                rc = -1;
-                break;
+                    /* tally up number of bytes written */
+                    *count_bytes_written += (uint64_t) bytes_written;
+                }
             }
-
-            /* tally up number of bytes written */
-            *count_bytes_written += (uint64_t) bytes_written;
         }
 
         /* add bytes to our total */
-        total_bytes += (long unsigned int)src_read;
+        off += min_read;
+        total_bytes += (long unsigned int)min_read;
 
         /* update number of bytes read and written for progress messages */
         uint64_t count_bytes[2];
@@ -1017,8 +1087,24 @@ int mfu_compare_contents(
         mfu_progress_update(count_bytes, prg);
     }
 
+    /* truncate destination file if we might have written past the end */
+    if (need_truncate) {
+        off_t last_written = offset + length;
+        off_t file_size_offt = (off_t) file_size;
+        if (last_written >= file_size_offt) {
+            /* Use ftruncate() here rather than truncate(), because grouplock
+             * of Lustre would cause block to truncate() since the fd is different
+             * from the out_fd. */
+            if (mfu_ftruncate(dst_fd, file_size_offt) < 0) {
+                MFU_LOG(MFU_LOG_ERR, "Failed to truncate destination file: %s (errno=%d %s)",
+                    dst_name, errno, strerror(errno));
+                rc = -1;
+            }
+        }
+    }
+
     /* free buffers */
-    mfu_free(&dest_buf);
+    mfu_free(&dst_buf);
     mfu_free(&src_buf);
 
     /* close files */
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index 84490aa5..2630261b 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -273,8 +273,9 @@ int mfu_compare_contents(
     const char* dst,          /* IN  - path name to destination file */
     off_t offset,             /* IN  - offset with file to start comparison */
     off_t length,             /* IN  - number of bytes to be compared */
-    size_t bufsize,           /* IN  - size of I/O buffer to be used during compare */
+    off_t file_size,          /* IN  - size of file to be compared */
     int overwrite,            /* IN  - whether to replace dest with source contents (1) or not (0) */
+    mfu_copy_opts_t* opts,    /* IN  - options to use in compare/copy */
     uint64_t* bytes_read,     /* OUT - number of bytes read (src + dest) */
     uint64_t* bytes_written,  /* OUT - number of bytes written to dest */
     mfu_progress* prg         /* IN  - progress message structure */
diff --git a/src/dcmp/dcmp.c b/src/dcmp/dcmp.c
index b254f5d5..87e52314 100644
--- a/src/dcmp/dcmp.c
+++ b/src/dcmp/dcmp.c
@@ -30,6 +30,7 @@ static void print_usage(void)
     printf("  -o, --output <EXPR:FILE>  - write list of entries matching EXPR to FILE\n");
     printf("  -t, --text                - change output option to write in text format\n");
     printf("  -b, --base                - enable base checks and normal output with --output\n");
+    printf("  -s, --direct              - open files with O_DIRECT\n");
     printf("      --progress <N>        - print progress every N seconds\n");
     printf("  -v, --verbose             - verbose output\n");
     printf("  -q, --quiet               - quiet output\n");
@@ -754,7 +755,8 @@ static int dcmp_strmap_compare_data(
     strmap* src_map,
     mfu_flist dst_compare_list,
     strmap* dst_map,
-    size_t strlen_prefix)
+    size_t strlen_prefix,
+    mfu_copy_opts_t* copy_opts)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -795,10 +797,13 @@ static int dcmp_strmap_compare_data(
         /* get length of section that we should compare (bytes) */
         off_t length = (off_t)src_p->length;
 
+        /* get size of file that we should compare (bytes) */
+        off_t filesize = (off_t)src_p->file_size;
+
         /* compare the contents of the files */
         int overwrite = 0;
-        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length,
-                1048576, overwrite, &bytes_read, &bytes_written, prg);
+        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length, filesize,
+                overwrite, copy_opts, &bytes_read, &bytes_written, prg);
         if (compare_rc == -1) {
             /* we hit an error while reading */
             rc = -1;
@@ -928,13 +933,15 @@ static void time_strmap_compare(mfu_flist src_list, double start_compare,
 }
 
 /* compare entries from src into dst */
-static int dcmp_strmap_compare(mfu_flist src_list,
-                                strmap* src_map,
-                                mfu_flist dst_list,
-                                strmap* dst_map,
-                                size_t strlen_prefix,
-                                const mfu_param_path* src_path,
-                                const mfu_param_path* dest_path)
+static int dcmp_strmap_compare(
+    mfu_flist src_list,
+    strmap* src_map,
+    mfu_flist dst_list,
+    strmap* dst_map,
+    size_t strlen_prefix,
+    mfu_copy_opts_t* copy_opts,
+    const mfu_param_path* src_path,
+    const mfu_param_path* dest_path)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1092,7 +1099,7 @@ static int dcmp_strmap_compare(mfu_flist src_list,
         cmp_global_size = mfu_flist_global_size(src_compare_list);
         if (cmp_global_size > 0) {
             tmp_rc = dcmp_strmap_compare_data(src_compare_list, src_map, dst_compare_list,
-                    dst_map, strlen_prefix);
+                    dst_map, strlen_prefix, copy_opts);
             if (tmp_rc < 0) {
                 /* got a read error, signal that back to caller */
                 rc = -1;
@@ -2037,9 +2044,12 @@ int main(int argc, char **argv)
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
     MPI_Comm_size(MPI_COMM_WORLD, &ranks);
 
-    /* pointer to mfu_walk_opts */
+    /* allocate structure to define walk options */
     mfu_walk_opts_t* walk_opts = mfu_walk_opts_new();
 
+    /* allocate structure to define copy (comparision) options */
+    mfu_copy_opts_t* copy_opts = mfu_copy_opts_new();
+
     /* TODO: allow user to specify file lists as input files */
 
     /* TODO: three levels of comparison:
@@ -2060,6 +2070,7 @@ int main(int argc, char **argv)
         {"output",   1, 0, 'o'},
         {"text",     0, 0, 't'},
         {"base",     0, 0, 'b'},
+        {"direct",   0, 0, 's'},
         {"progress", 1, 0, 'P'},
         {"verbose",  0, 0, 'v'},
         {"quiet",    0, 0, 'q'},
@@ -2076,7 +2087,7 @@ int main(int argc, char **argv)
     int help  = 0;
     while (1) {
         int c = getopt_long(
-            argc, argv, "o:tbvqldh",
+            argc, argv, "o:tbsvqldh",
             long_options, &option_index
         );
 
@@ -2097,6 +2108,12 @@ int main(int argc, char **argv)
         case 'b':
             options.base++;
             break;
+        case 's':
+            copy_opts->direct = true;
+            if(rank == 0) {
+                MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
+            }
+            break;
         case 'P':
             mfu_progress_timeout = atoi(optarg);
             break;
@@ -2218,7 +2235,7 @@ int main(int argc, char **argv)
     strmap* map2 = dcmp_strmap_creat(flist4, path2);
 
     /* compare files in map1 with those in map2 */
-    int tmp_rc = dcmp_strmap_compare(flist3, map1, flist4, map2, strlen(path1), srcpath, destpath);
+    int tmp_rc = dcmp_strmap_compare(flist3, map1, flist4, map2, strlen(path1), copy_opts, srcpath, destpath);
     if (tmp_rc < 0) {
         /* hit a read error on at least one file */
         rc = 1;
@@ -2254,6 +2271,9 @@ int main(int argc, char **argv)
 
     dcmp_option_fini();
 
+    /* free the copy options structure */
+    mfu_copy_opts_delete(&copy_opts);
+
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 753824c5..924f5159 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -642,7 +642,7 @@ void print_usage(void)
     printf("  -i, --input <file>       - read source list from file\n");
     printf("  -k, --chunksize          - work size per task in bytes (default 1MB)\n");
     printf("  -p, --preserve           - preserve permissions, ownership, timestamps, extended attributes\n");
-    printf("  -s, --synchronous        - use synchronous read/write calls (O_DIRECT)\n");
+    printf("  -s, --direct             - open files with O_DIRECT\n");
     printf("  -S, --sparse             - create sparse files when possible\n");
     printf("      --progress <N>       - print progress every N seconds\n");
     printf("  -v, --verbose            - verbose output\n");
@@ -707,6 +707,7 @@ int main(int argc, char** argv)
         {"chunksize"            , required_argument, 0, 'k'},
         {"preserve"             , no_argument      , 0, 'p'},
         {"synchronous"          , no_argument      , 0, 's'},
+        {"direct"               , no_argument      , 0, 's'},
         {"sparse"               , no_argument      , 0, 'S'},
         {"progress"             , required_argument, 0, 'P'},
         {"verbose"              , no_argument      , 0, 'v'},
@@ -865,9 +866,9 @@ int main(int argc, char** argv)
                 }
                 break;
             case 's':
-                mfu_copy_opts->synchronous = 1;
+                mfu_copy_opts->direct = 1;
                 if(rank == 0) {
-                    MFU_LOG(MFU_LOG_INFO, "Using synchronous read/write (O_DIRECT)");
+                    MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
                 }
                 break;
             case 'S':
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index 2cef389b..858ddd85 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -52,12 +52,12 @@ static void print_usage(void)
     printf("  -b  --batch-files <N> - batch files into groups of N during copy\n");
     printf("  -c, --contents        - read and compare file contents rather than compare size and mtime\n");
     printf("  -D, --delete          - delete extraneous files from target\n");
+    printf("  -s, --direct          - open files with O_DIRECT\n");
     printf("      --link-dest <DIR> - hardlink to files in DIR when unchanged\n");
     printf("  -S, --sparse          - create sparse files when possible\n");
     printf("      --progress <N>    - print progress every N seconds\n");
     printf("  -v, --verbose         - verbose output\n");
     printf("  -q, --quiet           - quiet output\n");
-    printf("  -s, --synchronous     - use synchronous read/write calls(O_DIRECT)\n");
     printf("  -h, --help            - print usage\n");
     printf("\n");
     printf("For more information see https://mpifileutils.readthedocs.io.\n");
@@ -688,6 +688,7 @@ static void dsync_strmap_compare_data_link_dest(
     mfu_flist src_compare_list,
     mfu_flist link_compare_list,
     mfu_flist link_same_list,
+    mfu_copy_opts_t* copy_opts,
     uint64_t* count_bytes_read,
     uint64_t* count_bytes_written)
 {
@@ -729,9 +730,12 @@ static void dsync_strmap_compare_data_link_dest(
         /* get length of section that we should compare (bytes) */
         off_t length = (off_t)src_p->length;
         
+        /* get length of file that we should compare (bytes) */
+        off_t filesize = (off_t)src_p->file_size;
+        
         /* compare the contents of the files */
-        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length,
-                1048576, overwrite, count_bytes_read, count_bytes_written, compare_prog);
+        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length, filesize,
+                overwrite, copy_opts, count_bytes_read, count_bytes_written, compare_prog);
         if (compare_rc == -1) {
             /* we hit an error while reading */
             rc = -1;
@@ -799,9 +803,10 @@ static int dsync_strmap_compare_data(
     mfu_flist dst_same_list,
     mfu_flist dst_remove_list,
     size_t strlen_prefix,
+    bool use_hardlinks,
+    mfu_copy_opts_t* copy_opts,
     uint64_t* count_bytes_read,
-    uint64_t* count_bytes_written,
-    bool use_hardlinks)
+    uint64_t* count_bytes_written)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -844,9 +849,12 @@ static int dsync_strmap_compare_data(
         /* get length of section that we should compare (bytes) */
         off_t length = (off_t)src_p->length;
 
+        /* get length of file that we should compare (bytes) */
+        off_t filesize = (off_t)src_p->file_size;
+        
         /* compare the contents of the files */
-        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length,
-                1048576, overwrite, count_bytes_read, count_bytes_written, compare_prog);
+        int compare_rc = mfu_compare_contents(src_p->name, dst_p->name, offset, length, filesize,
+                overwrite, copy_opts, count_bytes_read, count_bytes_written, compare_prog);
         if (compare_rc == -1) {
             /* we hit an error while reading */
             rc = -1;
@@ -1258,18 +1266,18 @@ static void dsync_only_dst(strmap* src_map,
 }
 
 static int dsync_sync_files(
-        strmap* src_map,
-        strmap* dst_map,
-        const mfu_param_path* src_path,
-        const mfu_param_path* dest_path,
-        const mfu_param_path* link_path,
-        mfu_flist dst_list,
-        mfu_flist dst_remove_list,
-        mfu_flist link_dst_list,
-        mfu_flist src_cp_list,
-        mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file,
-        mfu_file_t* mfu_dst_file)
+    strmap* src_map,
+    strmap* dst_map,
+    const mfu_param_path* src_path,
+    const mfu_param_path* dest_path,
+    const mfu_param_path* link_path,
+    mfu_flist dst_list,
+    mfu_flist dst_remove_list,
+    mfu_flist link_dst_list,
+    mfu_flist src_cp_list,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1285,7 +1293,7 @@ static int dsync_sync_files(
 
     /* record copy_into_dir flag result from check_copy into
      * mfu copy options structure */
-    mfu_copy_opts->copy_into_dir = copy_into_dir;
+    copy_opts->copy_into_dir = copy_into_dir;
 
     /* exit job if we found a problem */
     if(!valid) {
@@ -1324,7 +1332,7 @@ static int dsync_sync_files(
         if (rank == 0) {
             MFU_LOG(MFU_LOG_INFO, "Copying items to destination");
         }
-        tmp_rc = mfu_flist_copy(src_cp_list, 1, src_path, dest_path, mfu_copy_opts,
+        tmp_rc = mfu_flist_copy(src_cp_list, 1, src_path, dest_path, copy_opts,
                                 mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
@@ -1343,7 +1351,7 @@ static int dsync_sync_files(
                 MFU_LOG(MFU_LOG_INFO, "Linking items in destination");
             }
             tmp_rc = mfu_flist_hardlink(link_dst_list, link_path, dest_path,
-                                        mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                                        copy_opts, mfu_src_file, mfu_dst_file);
             if (tmp_rc < 0) {
                 rc = -1;
             }
@@ -1359,7 +1367,8 @@ static int dsync_strmap_compare_link_dest(
     strmap* src_map,
     mfu_flist link_list,
     strmap* link_map,
-    mfu_flist link_same_list)
+    mfu_flist link_same_list,
+    mfu_copy_opts_t* copy_opts)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1469,7 +1478,7 @@ static int dsync_strmap_compare_link_dest(
             /* compare file contents byte-by-byte, overwrites destination
              * file in place if found to be different during comparison */
             dsync_strmap_compare_data_link_dest(src_compare_list,
-                link_compare_list, link_same_list,
+                link_compare_list, link_same_list, copy_opts,
                 &total_bytes_read, &total_bytes_written
             );
         } else {
@@ -1510,7 +1519,7 @@ static int dsync_strmap_compare(
     mfu_flist link_list,
     strmap* link_map,
     size_t strlen_prefix,
-    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_copy_opts_t* copy_opts,
     const mfu_param_path* src_path,
     const mfu_param_path* dest_path,
     const mfu_param_path* link_path,
@@ -1738,8 +1747,8 @@ static int dsync_strmap_compare(
              * and hardlinks are not enabled */
             tmp_rc = dsync_strmap_compare_data(src_compare_list, src_map,
                 dst_compare_list, dst_map, src_list, src_cp_list, dst_same_list,
-                dst_remove_list, strlen_prefix,
-                &total_bytes_read, &total_bytes_written, use_hardlinks
+                dst_remove_list, strlen_prefix, use_hardlinks, copy_opts,
+                &total_bytes_read, &total_bytes_written
             );
             if (tmp_rc < 0) {
                 rc = -1;
@@ -1769,7 +1778,7 @@ static int dsync_strmap_compare(
         /* compare files in source and link-dest and create list of items
          * that are the same */
         rc = dsync_strmap_compare_link_dest(src_list, src_map,
-            link_list, link_map, link_same_list);
+            link_list, link_map, link_same_list, copy_opts);
 
         /* of the items to be copied, some may be actual copies,
          * and some may be hardlinks, we'll break the copy list
@@ -1812,7 +1821,7 @@ static int dsync_strmap_compare(
         /* sync the files that are in the source and destination directories */
         tmp_rc = dsync_sync_files(src_map, dst_map,
             src_path, dest_path, link_path, dst_list, dst_remove_list,
-            link_dst_list, cp_list, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            link_dst_list, cp_list, copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -2810,7 +2819,7 @@ int main(int argc, char **argv)
     mfu_walk_opts_t* walk_opts = mfu_walk_opts_new();
 
     /* pointer to mfu_copy opts */
-    mfu_copy_opts_t* mfu_copy_opts = mfu_copy_opts_new();
+    mfu_copy_opts_t* copy_opts = mfu_copy_opts_new();
 
     /* TODO: allow user to specify file lists as input files */
 
@@ -2830,10 +2839,10 @@ int main(int argc, char **argv)
     mfu_debug_level = MFU_LOG_VERBOSE;
 
     /* By default, sync option will preserve all attributes. */
-    mfu_copy_opts->preserve = true;
+    copy_opts->preserve = true;
 
     /* flag to check for sync option */
-    mfu_copy_opts->do_sync = 1;
+    copy_opts->do_sync = 1;
 
     int option_index = 0;
     static struct option long_options[] = {
@@ -2841,6 +2850,7 @@ int main(int argc, char **argv)
         {"batch-files",   1, 0, 'b'},
         {"contents",      0, 0, 'c'},
         {"delete",        0, 0, 'D'},
+        {"direct",        0, 0, 's'},
         {"output",        1, 0, 'o'}, // undocumented
         {"debug",         0, 0, 'd'}, // undocumented
         {"link-dest",     1, 0, 'l'},
@@ -2848,7 +2858,6 @@ int main(int argc, char **argv)
         {"progress",      1, 0, 'P'},
         {"verbose",       0, 0, 'v'},
         {"quiet",         0, 0, 'q'},
-        {"synchronous",   0, 0, 's'},
         {"help",          0, 0, 'h'},
         {0, 0, 0, 0}
     };
@@ -2864,7 +2873,7 @@ int main(int argc, char **argv)
 
     while (1) {
         int c = getopt_long(
-            argc, argv, "b:cDo:Svqsh",
+            argc, argv, "b:cDso:Svqh",
             long_options, &option_index
         );
 
@@ -2874,7 +2883,7 @@ int main(int argc, char **argv)
 
         switch (c) {
         case 'b':
-            mfu_copy_opts->batch_files = atoi(optarg);
+            copy_opts->batch_files = atoi(optarg);
             break;
         case 'c':
             options.contents++;
@@ -2885,6 +2894,12 @@ int main(int argc, char **argv)
         case 'D':
             options.delete = 1;
             break;
+        case 's':
+            copy_opts->direct = true;
+            if(rank == 0) {
+                MFU_LOG(MFU_LOG_INFO, "Using O_DIRECT");
+            }
+            break;
         case 'l':
             options.link_dest = MFU_STRDUP(optarg);
             break;
@@ -2898,7 +2913,7 @@ int main(int argc, char **argv)
             options.debug++;
             break;
         case 'S':
-            mfu_copy_opts->sparse = 1;
+            copy_opts->sparse = 1;
             break;
         case 'P':
             mfu_progress_timeout = atoi(optarg);
@@ -2914,12 +2929,6 @@ int main(int argc, char **argv)
              * disable the algorithm to save some overhead */
             mfu_progress_timeout = 0;
             break;
-        case 's':
-            mfu_copy_opts->synchronous = true;
-            if(rank == 0) {
-                MFU_LOG(MFU_LOG_INFO, "Using synchronous read/write (O_DIRECT)");
-            }
-            break;
         case 'h':
         case '?':
             usage = 1;
@@ -3101,7 +3110,7 @@ int main(int argc, char **argv)
 
     /* compare files in map_src with those in map_dst */
     int tmp_rc = dsync_strmap_compare(flist_src, map_src, flist_dst, map_dst, flist_link, map_link,
-        strlen(path_src), mfu_copy_opts, srcpath, destpath, linkpath, mfu_src_file, mfu_dst_file);
+        strlen(path_src), copy_opts, srcpath, destpath, linkpath, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = 1;
     }
@@ -3132,11 +3141,11 @@ int main(int argc, char **argv)
         mfu_free(&linkpath);
     }
 
-    /* free the copy options structure */
-    mfu_copy_opts_delete(&mfu_copy_opts);
-
     dsync_option_fini();
 
+    /* free the copy options structure */
+    mfu_copy_opts_delete(&copy_opts);
+
     /* free the walk options */
     mfu_walk_opts_delete(&walk_opts);
 

From a8df56e73fb68c116fc8e58e06165042e1a86142 Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Mon, 21 Sep 2020 22:56:11 +0000
Subject: [PATCH 19/27] daos: mfu_file_unlink and daos_unlink implementation

Added implementation for mfu_file_unlink and daos_unlink.
Updated mfu_flist_copy.c and mfu_flist_walk.c to use the
new mfu_file_unlink.

The following files still have references to mfu_unlink,
but I don't believe that can/should be updated:
mfu_flist_remove.c
dbcast.c
dreln.c
copy.c
dbz2.c

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_flist_copy.c |  2 +-
 src/common/mfu_flist_walk.c |  6 ++--
 src/common/mfu_io.c         | 63 ++++++++++++++++++++++++++++++++++++-
 src/common/mfu_io.h         |  3 +-
 4 files changed, 68 insertions(+), 6 deletions(-)

diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index c718dbf7..2e6601d4 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -2053,7 +2053,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
                     rc = -1;
 #if 0
                     /* delete destination file */
-                    int unlink_rc = mfu_unlink(dest);
+                    int unlink_rc = mfu_file_unlink(dest, mfu_dst_file);
                     if (unlink_rc != 0) {
                         MFU_LOG(MFU_LOG_ERR, "Failed to unlink `%s' (errno=%d %s)",
                                   name, errno, strerror(errno)
diff --git a/src/common/mfu_flist_walk.c b/src/common/mfu_flist_walk.c
index c068f295..ed81c8d8 100644
--- a/src/common/mfu_flist_walk.c
+++ b/src/common/mfu_flist_walk.c
@@ -354,7 +354,7 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
                         /* unlink files here if remove option is on,
                          * and dtype is known without a stat */
                         if (REMOVE_FILES && (entry->d_type != DT_DIR)) {
-                            mfu_unlink(newpath);
+                            mfu_file_unlink(newpath, mfu_file);
                         } else {
                             /* we can read object type from directory entry */
                             have_mode = 1;
@@ -372,7 +372,7 @@ static void walk_readdir_process_dir(const char* dir, CIRCLE_handle* handle)
                             /* unlink files here if remove option is on,
                              * and stat was necessary to get type */
                             if (REMOVE_FILES && !S_ISDIR(st.st_mode)) {
-                                mfu_unlink(newpath);
+                                mfu_file_unlink(newpath, mfu_file);
                             } else {
                                 mfu_flist_insert_stat(CURRENT_LIST, newpath, mode, &st);
                             }
@@ -527,7 +527,7 @@ static void walk_stat_process(CIRCLE_handle* handle)
     /* TODO: filter items by stat info */
 
     if (REMOVE_FILES && !S_ISDIR(st.st_mode)) {
-        mfu_unlink(path);
+        mfu_file_unlink(path, mfu_file);
     } else {
         /* record info for item in list */
         mfu_flist_insert_stat(CURRENT_LIST, path, st.st_mode, &st);
diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index cd0dbfc6..c2a350e2 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -1227,6 +1227,67 @@ int mfu_file_ftruncate(mfu_file_t* mfu_file, off_t length)
     }
 }
 
+/* unlink a file */
+int mfu_file_unlink(const char* file, mfu_file_t* mfu_file)
+{
+    if (mfu_file->type == POSIX) {
+        int rc = mfu_unlink(file);
+        return rc;
+    } else if (mfu_file->type == DAOS) {
+        int rc = daos_unlink(file, mfu_file);
+        return rc;
+    } else {
+        MFU_ABORT(-1, "File type not known, type=%d",
+                  mfu_file->type);
+    } 
+}
+
+/* emulates unlink on a DAOS file or symlink */
+int daos_unlink(const char* file, mfu_file_t* mfu_file)
+{
+#ifdef DAOS_SUPPORT
+    char* name     = NULL;
+    char* dir_name = NULL;
+    parse_filename(file, &name, &dir_name);
+    assert(dir_name);
+
+    /* Need to lookup parent directory in DFS */
+    dfs_obj_t* parent = NULL;
+    mode_t mode;
+    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, &mode, NULL);
+    if (parent == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+        errno = ENOENT;
+        rc = -1;
+    } 
+    else {
+        /* only allow regular files and symlinks */
+        if (!S_ISREG(mode) && !S_ISLNK(mode)) {
+            MFU_LOG(MFU_LOG_ERR, "Invalid entry type (not a file or symlink)");
+            errno = EINVAL;
+            rc = -1;
+        }
+        else {
+            /* remove the file */
+            rc = dfs_remove(mfu_file->dfs, parent, name, false, NULL);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_remove failed (%d %s)",
+                        rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+        }
+        /* close the parent, ignoring errors since they have no direct impact */
+        dfs_release(parent);
+    }
+
+    mfu_free(&name);
+    mfu_free(&dir_name);
+
+    return rc; 
+#endif
+}
+
 /* delete a file */
 int mfu_unlink(const char* file)
 {
@@ -1442,7 +1503,7 @@ int daos_closedir(DIR* _dirp, mfu_file_t* mfu_file)
     struct dfs_mfu_t *dirp = (struct dfs_mfu_t *)_dirp;
     int rc = dfs_release(dirp->dir);
     if (rc) {
-        MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d)",
+        MFU_LOG(MFU_LOG_ERR, "dfs_release failed (%d %s)",
                 rc, strerror(rc));
         errno = rc;
         rc = -1;
diff --git a/src/common/mfu_io.h b/src/common/mfu_io.h
index 0784d326..2a878c42 100644
--- a/src/common/mfu_io.h
+++ b/src/common/mfu_io.h
@@ -83,7 +83,6 @@ int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file);
 
 /* call mknod, retry a few times on EINTR or EIO */
 int mfu_file_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file);
-/* just a noop, since there is no daos_mknod */
 int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file);
 int mfu_mknod(const char* path, mode_t mode, dev_t dev);
 
@@ -157,6 +156,8 @@ int daos_ftruncate(mfu_file_t* mfu_file, off_t length);
 int mfu_ftruncate(int fd, off_t length);
 
 /* delete a file */
+int mfu_file_unlink(const char* file, mfu_file_t* mfu_file);
+int daos_unlink(const char* file, mfu_file_t* mfu_file);
 int mfu_unlink(const char* file);
 
 /* force flush of written data */

From 4133059b9baec638bb3f9d1ea2a65813be6a3c21 Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Tue, 22 Sep 2020 21:10:31 +0000
Subject: [PATCH 20/27] daos: mfu_io: add dfs_release for each dfs_lookup

Each daos_* function that uses dfs_lookup now also
has a corresponding dfs_release, except for "open"
functions, since this is handled in "close".

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_io.c | 62 ++++++++++++++++++++++++++++++---------------
 1 file changed, 42 insertions(+), 20 deletions(-)

diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index c2a350e2..b66f5e1f 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -66,6 +66,7 @@ static dfs_obj_t* lookup_insert_dir(const char *name, mfu_file_t* mfu_file)
         d_list_t *rlink;
         int rc;
 
+        /* TODO: need to make sure we have a corresponding d_hash_table_destroy */
 	if (dir_hash == NULL) {
 	    rc = d_hash_table_create(0, 16, NULL, &hdl_hash_ops, &dir_hash);
 	    if (rc) {
@@ -282,7 +283,11 @@ int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
 
     dfs_obj_t* parent = NULL;
     int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
-    if (parent != NULL) {
+    if (parent == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+        errno = ENOENT;
+        rc = -1;
+    } else {
         rc = dfs_chmod(mfu_file->dfs, parent, name, mode);
         if (rc) {
             MFU_LOG(MFU_LOG_ERR, "dfs_chmod %s failed (%d %s)",
@@ -290,10 +295,8 @@ int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
             errno = rc;
             rc = -1;
         }
-    } else {
-        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
-        errno = ENOENT;
-        rc = -1;
+        /* close the parent, ignoring errors since they have no direct impact */
+        dfs_release(parent);
     }
 
     mfu_free(&name);
@@ -387,6 +390,12 @@ int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
         rc = -1;
     }
 
+    /* close the parent, ignoring errors since they have no direct impact. 
+     * only close if dfs_lookup was called here */
+    if (mfu_file->only_daos && parent != NULL) {
+        dfs_release(parent);
+    }
+
     mfu_free(&name);
     mfu_free(&dir_name);
 
@@ -651,7 +660,11 @@ int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
 
     dfs_obj_t* parent = NULL;
     int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
-    if (parent != NULL) {
+    if (parent == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+        errno = ENOENT;
+        rc = -1;
+    } else {
         rc = dfs_open(mfu_file->dfs, parent, name,
                       dfs_mode, flags,
                       0, 0, NULL, &(mfu_file->obj));
@@ -661,10 +674,8 @@ int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
             errno = rc;
             rc = -1;
         }
-    } else {
-        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
-        errno = ENOENT;
-        rc = -1;
+        /* close the parent, ignoring errors since they have no direct impact */
+        dfs_release(parent);
     }
 
     mfu_free(&name);
@@ -1183,7 +1194,7 @@ int daos_ftruncate(mfu_file_t* mfu_file, off_t length)
     daos_off_t offset = (daos_off_t) length;
     int rc = dfs_punch(mfu_file->dfs, mfu_file->obj, offset, DFS_MAX_FSIZE);
     if (rc) {
-        MFU_LOG(MFU_LOG_ERR, "dfs_punch failed (%d)",
+        MFU_LOG(MFU_LOG_ERR, "dfs_punch failed (%d %s)",
                 rc, strerror(rc));
         errno = rc;
         rc = -1;
@@ -1354,18 +1365,29 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
     parse_filename(dir, &name, &dir_name);
     assert(dir_name);
 
-    /* Need to lookup parent directory in DFS */
-    dfs_obj_t* parent = NULL;
-    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    int rc = 0;
 
     /* only call mkdir if name is not the root DFS directory */
     if (name && strcmp(name, "/") != 0) {
-        rc = dfs_mkdir(mfu_file->dfs, parent, name, mode, 0);
-    }
-
-    if (rc) {
-        errno = rc;
-        rc = -1;
+        /* Need to lookup parent directory in DFS */
+        dfs_obj_t* parent = NULL;
+        rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+        if (parent == NULL) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
+            errno = ENOENT;
+            rc = -1;
+        } else {
+            /* Make the directory */
+            rc = dfs_mkdir(mfu_file->dfs, parent, name, mode, 0);
+            if (rc) {
+                MFU_LOG(MFU_LOG_ERR, "dfs_mkdir %s failed (%d %s)", 
+                        name, rc, strerror(rc));
+                errno = rc;
+                rc = -1;
+            }
+            /* close the parent, ignoring errors since they have no direct impact */
+            dfs_release(parent);
+        }
     }
 
     mfu_free(&name);

From b499439d9261233b3cc4b2d735834fc893f7800b Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Tue, 22 Sep 2020 22:24:05 +0000
Subject: [PATCH 21/27] daos: mfu_io: return 0 or NULL if not DAOS_SUPPORT

For daos_* functions, when DAOS_SUPPORT is not defined,
the functions will just return 0 or NULL to alleviate
compiler warnings/errors.

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_io.c | 36 +++++++++++++++++++++++++++++++++++-
 1 file changed, 35 insertions(+), 1 deletion(-)

diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index b66f5e1f..40f83e87 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -249,6 +249,8 @@ int daos_access(const char* path, int amode, mfu_file_t* mfu_file)
     mfu_free(&dir_name);
     
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -303,6 +305,8 @@ int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
     mfu_free(&dir_name);
 
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -400,6 +404,8 @@ int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
     mfu_free(&dir_name);
 
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -512,6 +518,8 @@ int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
     mfu_free(&dir_name);
 
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -682,6 +690,8 @@ int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
     mfu_free(&dir_name);
 
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -775,6 +785,8 @@ int daos_close(const char* file, mfu_file_t* mfu_file)
         rc = -1;
     }
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -829,6 +841,8 @@ int daos_lseek(const char* file, mfu_file_t* mfu_file, off_t pos, int whence)
         MFU_ABORT(-1, "daos_lseek whence type not known: %d", whence);
     }
     return 0;
+#else
+    return 0;
 #endif
 }
 
@@ -908,6 +922,8 @@ ssize_t daos_read(const char* file, void* buf, size_t size, mfu_file_t* mfu_file
     mfu_file->offset += (daos_off_t)got_size;
 
     return (ssize_t)got_size;
+#else
+    return (ssize_t)0;
 #endif
 }
 
@@ -1024,6 +1040,8 @@ ssize_t daos_write(const char* file, const void* buf, size_t size, mfu_file_t* m
     mfu_file->offset += (daos_off_t)size;
 
     return (ssize_t)size;
+#else
+    return (ssize_t)0;
 #endif
 }
 
@@ -1066,6 +1084,8 @@ ssize_t daos_pread(const char* file, void* buf, size_t size, off_t offset, mfu_f
     }
 
     return (ssize_t)got_size;
+#else
+    return (ssize_t)0;
 #endif
 }
 
@@ -1163,6 +1183,8 @@ ssize_t daos_pwrite(const char* file, const void* buf, size_t size, off_t offset
     }
 
     return (ssize_t)size;
+#else
+    return (ssize_t)0;
 #endif
 }
 
@@ -1200,6 +1222,8 @@ int daos_ftruncate(mfu_file_t* mfu_file, off_t length)
         rc = -1;
     }
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -1295,7 +1319,9 @@ int daos_unlink(const char* file, mfu_file_t* mfu_file)
     mfu_free(&name);
     mfu_free(&dir_name);
 
-    return rc; 
+    return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -1394,6 +1420,8 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
     mfu_free(&dir_name);
 
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -1480,6 +1508,8 @@ DIR* daos_opendir(const char* dir, mfu_file_t* mfu_file)
         return NULL;
     }
     return (DIR *)dirp;
+#else
+    return NULL;
 #endif
 }
 
@@ -1532,6 +1562,8 @@ int daos_closedir(DIR* _dirp, mfu_file_t* mfu_file)
     }
     free(dirp);
     return rc;
+#else
+    return 0;
 #endif
 }
 
@@ -1599,6 +1631,8 @@ struct dirent* daos_readdir(DIR* _dirp, mfu_file_t* mfu_file)
 ret:
     dirp->num_ents--;
     return &dirp->ents[dirp->num_ents];
+#else
+    return NULL;
 #endif
 }
 

From ad926b0f1e72ab334eb97302212474bc5b72b89c Mon Sep 17 00:00:00 2001
From: Adam Moody <moody20@llnl.gov>
Date: Tue, 22 Sep 2020 23:16:33 -0700
Subject: [PATCH 22/27] dcmp, dsync: add --chunksize and --blocksize

Signed-off-by: Adam Moody <moody20@llnl.gov>
---
 doc/rst/dcmp.1.rst  | 13 ++++++++++++
 doc/rst/dcp.1.rst   | 16 +++++++--------
 doc/rst/dsync.1.rst | 13 ++++++++++++
 src/dcmp/dcmp.c     | 47 ++++++++++++++++++++++++++++++++++---------
 src/dcp/dcp.c       |  4 ++--
 src/dsync/dsync.c   | 49 +++++++++++++++++++++++++++++++++++----------
 6 files changed, 111 insertions(+), 31 deletions(-)

diff --git a/doc/rst/dcmp.1.rst b/doc/rst/dcmp.1.rst
index 40f39ac4..6cecb2d9 100644
--- a/doc/rst/dcmp.1.rst
+++ b/doc/rst/dcmp.1.rst
@@ -36,6 +36,19 @@ OPTIONS
 
    Enable base checks and normal stdout results when --output is used.
 
+.. option:: --blocksize SIZE
+
+   Set the I/O buffer to be SIZE bytes.  Units like "MB" and "GB" may
+   immediately follow the number without spaces (eg. 8MB). The default
+   blocksize is 1MB.
+
+.. option:: --chunksize SIZE
+
+   Multiple processes copy a large file in parallel by dividing it into chunks.
+   Set chunk to be at minimum SIZE bytes.  Units like "MB" and
+   "GB" can immediately follow the number without spaces (eg. 64MB).
+   The default chunksize is 1MB.
+
 .. option:: -s, --direct
 
    Use O_DIRECT to avoid caching file data.
diff --git a/doc/rst/dcp.1.rst b/doc/rst/dcp.1.rst
index 230f6f8c..98f842ad 100644
--- a/doc/rst/dcp.1.rst
+++ b/doc/rst/dcp.1.rst
@@ -19,12 +19,19 @@ file system, and it splits large file copies across multiple processes.
 
 OPTIONS
 -------
-.. option:: -b, --blocksize SIZE
+.. option:: --blocksize SIZE
 
    Set the I/O buffer to be SIZE bytes.  Units like "MB" and "GB" may
    immediately follow the number without spaces (eg. 8MB). The default
    blocksize is 1MB.
 
+.. option:: --chunksize SIZE
+
+   Multiple processes copy a large file in parallel by dividing it into chunks.
+   Set chunk to be at minimum SIZE bytes.  Units like "MB" and
+   "GB" can immediately follow the number without spaces (eg. 64MB).
+   The default chunksize is 1MB.
+
 .. option:: --daos-src-pool POOL
 
    Specify the DAOS source pool to be used.
@@ -56,13 +63,6 @@ OPTIONS
    Read source list from FILE. FILE must be generated by another tool
    from the mpiFileUtils suite.
 
-.. option:: -k, --chunksize SIZE
-
-   Split large files into chunks of SIZE bytes to be processed.  Multiple
-   process ranks may copy a large file in parallel.  Units like "MB" and
-   "GB" can immediately follow the number without spaces (eg. 64MB).
-   The default chunksize is 1MB.
-
 .. option:: -p, --preserve
 
    Preserve permissions, group, timestamps, and extended attributes.
diff --git a/doc/rst/dsync.1.rst b/doc/rst/dsync.1.rst
index 6eac6338..5c3aa6d5 100644
--- a/doc/rst/dsync.1.rst
+++ b/doc/rst/dsync.1.rst
@@ -26,6 +26,19 @@ OPTIONS
 
    Batch files into groups of up to size N during copy operation.
 
+.. option:: --blocksize SIZE
+
+   Set the I/O buffer to be SIZE bytes.  Units like "MB" and "GB" may
+   immediately follow the number without spaces (eg. 8MB). The default
+   blocksize is 1MB.
+
+.. option:: --chunksize SIZE
+
+   Multiple processes copy a large file in parallel by dividing it into chunks.
+   Set chunk to be at minimum SIZE bytes.  Units like "MB" and
+   "GB" can immediately follow the number without spaces (eg. 64MB).
+   The default chunksize is 1MB.
+
 .. option:: -c, --contents
 
    Compare files byte-by-byte rather than checking size and mtime
diff --git a/src/dcmp/dcmp.c b/src/dcmp/dcmp.c
index 87e52314..bdfae2fd 100644
--- a/src/dcmp/dcmp.c
+++ b/src/dcmp/dcmp.c
@@ -30,6 +30,8 @@ static void print_usage(void)
     printf("  -o, --output <EXPR:FILE>  - write list of entries matching EXPR to FILE\n");
     printf("  -t, --text                - change output option to write in text format\n");
     printf("  -b, --base                - enable base checks and normal output with --output\n");
+    printf("      --blocksize <SIZE>    - IO buffer size in bytes (default 1MB)\n");
+    printf("      --chunksize <SIZE>    - minimum work size per task in bytes (default 1MB)\n");
     printf("  -s, --direct              - open files with O_DIRECT\n");
     printf("      --progress <N>        - print progress every N seconds\n");
     printf("  -v, --verbose             - verbose output\n");
@@ -2067,16 +2069,18 @@ int main(int argc, char **argv)
 
     int option_index = 0;
     static struct option long_options[] = {
-        {"output",   1, 0, 'o'},
-        {"text",     0, 0, 't'},
-        {"base",     0, 0, 'b'},
-        {"direct",   0, 0, 's'},
-        {"progress", 1, 0, 'P'},
-        {"verbose",  0, 0, 'v'},
-        {"quiet",    0, 0, 'q'},
-        {"lite",     0, 0, 'l'},
-        {"debug",    0, 0, 'd'},
-        {"help",     0, 0, 'h'},
+        {"output",    1, 0, 'o'},
+        {"text",      0, 0, 't'},
+        {"base",      0, 0, 'b'},
+        {"blocksize", 1, 0, 'B'},
+        {"chunksize", 1, 0, 'k'},
+        {"direct",    0, 0, 's'},
+        {"progress",  1, 0, 'P'},
+        {"verbose",   0, 0, 'v'},
+        {"quiet",     0, 0, 'q'},
+        {"lite",      0, 0, 'l'},
+        {"debug",     0, 0, 'd'},
+        {"help",      0, 0, 'h'},
         {0, 0, 0, 0}
     };
     int ret = 0;
@@ -2085,6 +2089,7 @@ int main(int argc, char **argv)
     /* read in command line options */
     int usage = 0;
     int help  = 0;
+    unsigned long long bytes = 0;
     while (1) {
         int c = getopt_long(
             argc, argv, "o:tbsvqldh",
@@ -2108,6 +2113,28 @@ int main(int argc, char **argv)
         case 'b':
             options.base++;
             break;
+        case 'B':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse block size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->block_size = (size_t)bytes;
+            }
+            break;
+        case 'k':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse chunk size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->chunk_size = bytes;
+            }
+            break;
         case 's':
             copy_opts->direct = true;
             if(rank == 0) {
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 924f5159..1395904f 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -631,7 +631,8 @@ void print_usage(void)
 #ifdef LUSTRE_SUPPORT
     /* printf("  -g, --grouplock <id> - use Lustre grouplock when reading/writing file\n"); */
 #endif
-    printf("  -b, --blocksize     - IO buffer size in bytes (default 1MB)\n");
+    printf("  -b, --blocksize <SIZE>   - IO buffer size in bytes (default 1MB)\n");
+    printf("  -k, --chunksize <SIZE>   - work size per task in bytes (default 1MB)\n");
     printf("      --daos-src-pool      - DAOS source pool \n");
     printf("      --daos-dst-pool      - DAOS destination pool \n");
     printf("      --daos-src-cont      - DAOS source container \n");
@@ -640,7 +641,6 @@ void print_usage(void)
     printf("      --daos-dst-svcl      - DAOS service level used by destination DAOS pool \n");
     printf("      --daos-prefix        - DAOS prefix for unified namespace path \n");
     printf("  -i, --input <file>       - read source list from file\n");
-    printf("  -k, --chunksize          - work size per task in bytes (default 1MB)\n");
     printf("  -p, --preserve           - preserve permissions, ownership, timestamps, extended attributes\n");
     printf("  -s, --direct             - open files with O_DIRECT\n");
     printf("  -S, --sparse             - create sparse files when possible\n");
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index 858ddd85..a4353c79 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -48,17 +48,19 @@ static void print_usage(void)
     printf("Usage: dsync [options] source target\n");
     printf("\n");
     printf("Options:\n");
-    printf("      --dryrun          - show differences, but do not synchronize files\n");
-    printf("  -b  --batch-files <N> - batch files into groups of N during copy\n");
-    printf("  -c, --contents        - read and compare file contents rather than compare size and mtime\n");
-    printf("  -D, --delete          - delete extraneous files from target\n");
-    printf("  -s, --direct          - open files with O_DIRECT\n");
-    printf("      --link-dest <DIR> - hardlink to files in DIR when unchanged\n");
-    printf("  -S, --sparse          - create sparse files when possible\n");
-    printf("      --progress <N>    - print progress every N seconds\n");
-    printf("  -v, --verbose         - verbose output\n");
-    printf("  -q, --quiet           - quiet output\n");
-    printf("  -h, --help            - print usage\n");
+    printf("      --dryrun            - show differences, but do not synchronize files\n");
+    printf("  -b  --batch-files <N>   - batch files into groups of N during copy\n");
+    printf("      --blocksize <SIZE>  - IO buffer size in bytes (default 1MB)\n");
+    printf("      --chunksize <SIZE>  - minimum work size per task in bytes (default 1MB)\n");
+    printf("  -c, --contents          - read and compare file contents rather than compare size and mtime\n");
+    printf("  -D, --delete            - delete extraneous files from target\n");
+    printf("  -s, --direct            - open files with O_DIRECT\n");
+    printf("      --link-dest <DIR>   - hardlink to files in DIR when unchanged\n");
+    printf("  -S, --sparse            - create sparse files when possible\n");
+    printf("      --progress <N>      - print progress every N seconds\n");
+    printf("  -v, --verbose           - verbose output\n");
+    printf("  -q, --quiet             - quiet output\n");
+    printf("  -h, --help              - print usage\n");
     printf("\n");
     printf("For more information see https://mpifileutils.readthedocs.io.\n");
     fflush(stdout);
@@ -2848,6 +2850,8 @@ int main(int argc, char **argv)
     static struct option long_options[] = {
         {"dryrun",        0, 0, 'n'},
         {"batch-files",   1, 0, 'b'},
+        {"blocksize",     1, 0, 'B'},
+        {"chunksize",     1, 0, 'k'},
         {"contents",      0, 0, 'c'},
         {"delete",        0, 0, 'D'},
         {"direct",        0, 0, 's'},
@@ -2867,6 +2871,7 @@ int main(int argc, char **argv)
     /* read in command line options */
     int usage = 0;
     int help  = 0;
+    unsigned long long bytes = 0;
 
     /* Don't delete dst files by default */
     options.delete = 0;
@@ -2885,6 +2890,28 @@ int main(int argc, char **argv)
         case 'b':
             copy_opts->batch_files = atoi(optarg);
             break;
+        case 'B':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse block size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->block_size = (size_t)bytes;
+            }
+            break;
+        case 'k':
+            if (mfu_abtoull(optarg, &bytes) != MFU_SUCCESS || bytes == 0) {
+                if (rank == 0) {
+                    MFU_LOG(MFU_LOG_ERR,
+                            "Failed to parse chunk size: '%s'", optarg);
+                }
+                usage = 1;
+            } else {
+                copy_opts->chunk_size = bytes;
+            }
+            break;
         case 'c':
             options.contents++;
             break;

From 0fcb4fb33fbf9d25657b20d3376dd731765e5a0b Mon Sep 17 00:00:00 2001
From: Adam Moody <moody20@llnl.gov>
Date: Tue, 22 Sep 2020 23:32:41 -0700
Subject: [PATCH 23/27] libmfu: increase block and chunk size from 1MB to 64MB

Signed-off-by: Adam Moody <moody20@llnl.gov>
---
 src/common/mfu_flist.h      | 6 ++++--
 src/common/mfu_flist_copy.c | 6 +++---
 src/dcmp/dcmp.c             | 4 ++--
 src/dcp/dcp.c               | 4 ++--
 src/dsync/dsync.c           | 4 ++--
 5 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/src/common/mfu_flist.h b/src/common/mfu_flist.h
index 84db5c85..05e35241 100644
--- a/src/common/mfu_flist.h
+++ b/src/common/mfu_flist.h
@@ -60,10 +60,12 @@ extern "C" {
 #define DCOPY_DEF_PERMS_DIR  (S_IRWXU)
 
 /* default chunk size to split files into work units */
-#define FD_CHUNK_SIZE (1*1024*1024)
+#define MFU_CHUNK_SIZE_STR "64MB"
+#define MFU_CHUNK_SIZE (64*1024*1024)
 
 /* default buffer size to read/write data to file system */
-#define FD_BLOCK_SIZE (1*1024*1024)
+#define MFU_BLOCK_SIZE_STR "64MB"
+#define MFU_BLOCK_SIZE (64*1024*1024)
 
 /*
  * FIXME: Is this description correct?
diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index 2e6601d4..5c6871c9 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -2269,7 +2269,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
     /* hard code some configurables for now */
 
     /* Set default block size */
-    mfu_copy_opts->block_size = FD_BLOCK_SIZE;
+    mfu_copy_opts->block_size = MFU_BLOCK_SIZE;
 
     /* allocate buffer to read/write files, aligned on 1MB boundaraies */
     size_t alignment = 1024*1024;
@@ -3152,10 +3152,10 @@ mfu_copy_opts_t* mfu_copy_opts_new(void)
     opts->sparse        = false;
 
     /* Set default chunk size */
-    opts->chunk_size    = FD_CHUNK_SIZE;
+    opts->chunk_size    = MFU_CHUNK_SIZE;
 
     /* temporaries used during the copy operation for buffers to read/write data */
-    opts->block_size    = FD_BLOCK_SIZE;
+    opts->block_size    = MFU_BLOCK_SIZE;
     opts->block_buf1    = NULL;
     opts->block_buf2    = NULL;
 
diff --git a/src/dcmp/dcmp.c b/src/dcmp/dcmp.c
index bdfae2fd..91cd6118 100644
--- a/src/dcmp/dcmp.c
+++ b/src/dcmp/dcmp.c
@@ -30,8 +30,8 @@ static void print_usage(void)
     printf("  -o, --output <EXPR:FILE>  - write list of entries matching EXPR to FILE\n");
     printf("  -t, --text                - change output option to write in text format\n");
     printf("  -b, --base                - enable base checks and normal output with --output\n");
-    printf("      --blocksize <SIZE>    - IO buffer size in bytes (default 1MB)\n");
-    printf("      --chunksize <SIZE>    - minimum work size per task in bytes (default 1MB)\n");
+    printf("      --blocksize <SIZE>    - IO buffer size in bytes (default " MFU_BLOCK_SIZE_STR ")\n");
+    printf("      --chunksize <SIZE>    - minimum work size per task in bytes (default " MFU_CHUNK_SIZE_STR ")\n");
     printf("  -s, --direct              - open files with O_DIRECT\n");
     printf("      --progress <N>        - print progress every N seconds\n");
     printf("  -v, --verbose             - verbose output\n");
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 1395904f..47e4acba 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -631,8 +631,8 @@ void print_usage(void)
 #ifdef LUSTRE_SUPPORT
     /* printf("  -g, --grouplock <id> - use Lustre grouplock when reading/writing file\n"); */
 #endif
-    printf("  -b, --blocksize <SIZE>   - IO buffer size in bytes (default 1MB)\n");
-    printf("  -k, --chunksize <SIZE>   - work size per task in bytes (default 1MB)\n");
+    printf("  -b, --blocksize <SIZE>   - IO buffer size in bytes (default " MFU_BLOCK_SIZE_STR ")\n");
+    printf("  -k, --chunksize <SIZE>   - work size per task in bytes (default " MFU_CHUNK_SIZE_STR ")\n");
     printf("      --daos-src-pool      - DAOS source pool \n");
     printf("      --daos-dst-pool      - DAOS destination pool \n");
     printf("      --daos-src-cont      - DAOS source container \n");
diff --git a/src/dsync/dsync.c b/src/dsync/dsync.c
index a4353c79..76711d16 100644
--- a/src/dsync/dsync.c
+++ b/src/dsync/dsync.c
@@ -50,8 +50,8 @@ static void print_usage(void)
     printf("Options:\n");
     printf("      --dryrun            - show differences, but do not synchronize files\n");
     printf("  -b  --batch-files <N>   - batch files into groups of N during copy\n");
-    printf("      --blocksize <SIZE>  - IO buffer size in bytes (default 1MB)\n");
-    printf("      --chunksize <SIZE>  - minimum work size per task in bytes (default 1MB)\n");
+    printf("      --blocksize <SIZE>  - IO buffer size in bytes (default " MFU_BLOCK_SIZE_STR ")\n");
+    printf("      --chunksize <SIZE>  - minimum work size per task in bytes (default " MFU_CHUNK_SIZE_STR ")\n");
     printf("  -c, --contents          - read and compare file contents rather than compare size and mtime\n");
     printf("  -D, --delete            - delete extraneous files from target\n");
     printf("  -s, --direct            - open files with O_DIRECT\n");

From c2389036f86989a4a260144cd3e580271593bb91 Mon Sep 17 00:00:00 2001
From: Adam Moody <moody20@llnl.gov>
Date: Wed, 23 Sep 2020 11:13:35 -0700
Subject: [PATCH 24/27] libmfu: fix to avoid overwriting block_size set in
 command line

Signed-off-by: Adam Moody <moody20@llnl.gov>
---
 src/common/mfu_flist_copy.c | 418 +++++++++++++++++++++---------------
 1 file changed, 240 insertions(+), 178 deletions(-)

diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index 5c6871c9..dac01a76 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -102,15 +102,18 @@ static mfu_copy_stats_t mfu_copy_stats;
 static mfu_copy_file_cache_t mfu_copy_src_cache;
 static mfu_copy_file_cache_t mfu_copy_dst_cache;
 
-static void mfu_copy_open_file(const char* file, int read_flag,
-        mfu_copy_file_cache_t* cache, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_file)
+static void mfu_copy_open_file(
+    const char* file,             /* path to file to be opened */
+    int read_flag,                /* set to 1 to open in read only, 0 for write */
+    mfu_copy_file_cache_t* cache, /* cache the open file to avoid repetitive open/close of the same file */
+    mfu_copy_opts_t* copy_opts,   /* options configuring the copy operation */
+    mfu_file_t* mfu_file)         /* whether the file is in POSIX/DAOS */
 {
     /* see if we have a cached file descriptor */
     char* name = cache->name;
     if (name != NULL) {
         /* we have a cached file descriptor */
-        int fd         = cache->fd;
+        int fd = cache->fd;
 #ifdef DAOS_SUPPORT
         dfs_obj_t* obj = cache->obj;
 #endif
@@ -125,20 +128,19 @@ static void mfu_copy_open_file(const char* file, int read_flag,
             mfu_free(&cache->name);
         }
     }
-    /* open the new file */
+
+    /* open the new file, this sets mfu_file->fd/obj */
     if (read_flag) {
         int flags = O_RDONLY;
-        if (mfu_copy_opts->direct) {
+        if (copy_opts->direct) {
             flags |= O_DIRECT;
         }
-        /* set obj or fd here */
         mfu_file_open(file, flags, mfu_file);
     } else {
         int flags = O_WRONLY | O_CREAT;
-        if (mfu_copy_opts->direct) {
+        if (copy_opts->direct) {
             flags |= O_DIRECT;
         }
-        /* set obj or fd here */
         mfu_file_open(file, flags, mfu_file, DCOPY_DEF_PERMS_FILE);
     }
 
@@ -147,23 +149,25 @@ static void mfu_copy_open_file(const char* file, int read_flag,
         cache->name = MFU_STRDUP(file);
         cache->fd   = mfu_file->fd;
         cache->read = read_flag;
+
 #ifdef LUSTRE_SUPPORT
         /* Zero is an invalid ID for grouplock. */
-        if (mfu_copy_opts->grouplock_id != 0) {
+        if (copy_opts->grouplock_id != 0) {
             errno = 0;
-            int rc = ioctl(mfu_file->fd, LL_IOC_GROUP_LOCK, mfu_copy_opts->grouplock_id);
+            int rc = ioctl(mfu_file->fd, LL_IOC_GROUP_LOCK, copy_opts->grouplock_id);
             if (rc) {
                 MFU_LOG(MFU_LOG_ERR, "Failed to obtain grouplock with ID %d "
                     "on file `%s', ignoring this error (errno=%d %s)",
-                    mfu_copy_opts->grouplock_id, file, errno, strerror(errno));
+                    copy_opts->grouplock_id, file, errno, strerror(errno));
             } else {
                 MFU_LOG(MFU_LOG_INFO, "Obtained grouplock with ID %d "
-                    "on file `%s', fd %d", mfu_copy_opts->grouplock_id,
+                    "on file `%s', fd %d", copy_opts->grouplock_id,
                     file, mfu_file->fd);
             }
         }
 #endif
     }
+
 #ifdef DAOS_SUPPORT
     if (mfu_file->obj != NULL && mfu_file->type == DAOS) {
         cache->name = MFU_STRDUP(file);
@@ -173,6 +177,34 @@ static void mfu_copy_open_file(const char* file, int read_flag,
 #endif
 }
 
+/* close a file that opened with mfu_copy_open_file */
+static int mfu_copy_close_file(
+    mfu_copy_file_cache_t* cache,
+    mfu_file_t* mfu_file)
+{
+    int rc = 0;
+
+    /* close file if we have one */
+    char* name = cache->name;
+    if (name != NULL) {
+        int fd = cache->fd;
+#ifdef DAOS_SUPPORT
+        dfs_obj_t* obj = cache->obj;
+#endif
+        /* if open for write, fsync */
+        int read_flag = cache->read;
+        if (! read_flag && mfu_file->type == POSIX) {
+            rc = mfu_fsync(name, fd);
+        }
+
+        /* close the file and delete the name string */
+        rc = mfu_file_close(name, mfu_file);
+        mfu_free(&cache->name);
+    }
+
+    return rc;
+}
+
 /* copy all extended attributes from op->operand to dest_path,
  * returns 0 on success and -1 on failure */
 static int mfu_copy_xattrs(
@@ -515,31 +547,6 @@ static int mfu_copy_timestamps(
     return rc;
 }
 
-static int mfu_copy_close_file(mfu_copy_file_cache_t* cache, mfu_file_t* mfu_file)
-{
-    int rc = 0;
-
-    /* close file if we have one */
-    char* name = cache->name;
-    if (name != NULL) {
-        int fd = cache->fd;
-#ifdef DAOS_SUPPORT
-        dfs_obj_t* obj = cache->obj;
-#endif
-        /* if open for write, fsync */
-        int read_flag = cache->read;
-        if (! read_flag && mfu_file->type == POSIX) {
-            rc = mfu_fsync(name, fd);
-        }
-
-        /* close the file and delete the name string */
-        rc = mfu_file_close(name, mfu_file);
-        mfu_free(&cache->name);
-    }
-
-    return rc;
-}
-
 /* progress message to print while setting file metadata */
 static void meta_progress_fn(const uint64_t* vals, int count, int complete, int ranks, double secs)
 {
@@ -578,10 +585,16 @@ static void meta_progress_fn(const uint64_t* vals, int count, int complete, int
  * and permissions starting from deepest level and working upwards,
  * we go in this direction in case updating a file updates its
  * parent directory */
-static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_copy_set_metadata(
+    int levels,                     /* number of levels */
+    int minlevel,                   /* value of minimum level */
+    mfu_flist* lists,               /* list of items at each level */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -594,7 +607,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
     if (rank == 0) {
-        if(mfu_copy_opts->preserve) {
+        if(copy_opts->preserve) {
             MFU_LOG(MFU_LOG_INFO, "Setting ownership, permissions, and timestamps.");
         }
         else {
@@ -629,7 +642,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
 
             /* get destination name of item */
             char* dest = mfu_param_path_copy_dest(name, numpaths,
-                    paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                    paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
             /* No need to copy it */
             if (dest == NULL) {
@@ -639,7 +652,7 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
             /* update our running total */
             total_count++;
 
-            if(mfu_copy_opts->preserve) {
+            if(copy_opts->preserve) {
                 tmp_rc = mfu_copy_ownership(list, idx, dest);
                 if (tmp_rc < 0) {
                     rc = -1;
@@ -708,10 +721,16 @@ static int mfu_copy_set_metadata(int levels, int minlevel, mfu_flist* lists,
  * and permissions starting from deepest level and working upwards,
  * we go in this direction in case updating a file updates its
  * parent directory */
-static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_copy_set_metadata_dirs(
+    int levels,                     /* number of levels */
+    int minlevel,                   /* value of minimum level */
+    mfu_flist* lists,               /* list of items at each level */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -724,7 +743,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
     if (rank == 0) {
-        if(mfu_copy_opts->preserve) {
+        if(copy_opts->preserve) {
             MFU_LOG(MFU_LOG_INFO, "Setting ownership, permissions, and timestamps on directories.");
         }
         else {
@@ -756,7 +775,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
 
             /* get destination name of item */
             char* dest = mfu_param_path_copy_dest(name, numpaths,
-                    paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                    paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
             /* No need to copy it */
             if (dest == NULL) {
@@ -772,7 +791,7 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
             /* update our running total */
             total_count++;
 
-            if(mfu_copy_opts->preserve) {
+            if(copy_opts->preserve) {
                 tmp_rc = mfu_copy_ownership(list, idx, dest);
                 if (tmp_rc < 0) {
                     rc = -1;
@@ -836,10 +855,15 @@ static int mfu_copy_set_metadata_dirs(int levels, int minlevel, mfu_flist* lists
  * and creates dir at same relative path under destpath, copies xattrs
  * when preserving permissions, which contains file striping info on Lustre,
  * returns 0 on success and -1 on error */
-static int mfu_create_directory(mfu_flist list, uint64_t idx,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_create_directory(
+    mfu_flist list,                 /* flist holding target directory */
+    uint64_t idx,                   /* index of target directory within its list */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -849,7 +873,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     char* dest_path = mfu_param_path_copy_dest(name, numpaths, paths,
-            destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -868,7 +892,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
      * not dsync is on happens prior to this in
      * mfu_param_path_copy_dest. */
 
-    if (mfu_copy_opts->do_sync &&
+    if (copy_opts->do_sync &&
         (strncmp(dest_path, destpath->path, strlen(dest_path)) == 0) &&
         destpath->target_stat_valid)
     {
@@ -898,7 +922,7 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
      * creating / striping files in the directory */
 
     /* copy extended attributes on directory */
-    if (mfu_copy_opts->preserve) {
+    if (copy_opts->preserve) {
         int tmp_rc = mfu_copy_xattrs(list, idx, dest_path);
         if (tmp_rc < 0) {
             rc = -1;
@@ -918,10 +942,16 @@ static int mfu_create_directory(mfu_flist list, uint64_t idx,
  * with a barrier in between levels, so that we don't try to create
  * a child directory until the parent exists,
  * returns 0 on success and -1 on failure */
-static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_create_directories(
+    int levels,                     /* number of levels */
+    int minlevel,                   /* value of minimum level */
+    mfu_flist* lists,               /* list of items at each level */
+    int numpaths,                   /* number of items in paths list */
+    const mfu_param_path* paths,    /* list of source paths */
+    const mfu_param_path* destpath, /* path items are being copied to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure copy operation */
+    mfu_file_t* mfu_src_file,       /* abstract whether source items are in POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* abstract whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -962,7 +992,7 @@ static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
             if (type == MFU_TYPE_DIR) {
                 /* create the directory */
                 int tmp_rc = mfu_create_directory(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1027,10 +1057,15 @@ static int mfu_create_directories(int levels, int minlevel, mfu_flist* lists,
  * that contains source link, computes relative path to link under source path,
  * and creates link at same relative path under destpath,
  * returns 0 on success and -1 on error */
-static int mfu_create_link(mfu_flist list, uint64_t idx,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_create_link(
+    mfu_flist list,
+    uint64_t idx,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1040,7 +1075,7 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, numpaths,
-           paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+           paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1078,7 +1113,7 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
     }
 
     /* set permissions on link */
-    if (mfu_copy_opts->preserve) {
+    if (copy_opts->preserve) {
         int xattr_rc = mfu_copy_xattrs(list, idx, dest_path);
         if (xattr_rc < 0) {
             rc = -1;
@@ -1099,10 +1134,15 @@ static int mfu_create_link(mfu_flist list, uint64_t idx,
  * and creates file at same relative path under destpath, copies xattrs
  * when preserving permissions, which contains file striping info on Lustre,
  * returns 0 on success and -1 on error */
-static int mfu_create_file(mfu_flist list, uint64_t idx,
-        int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_create_file(
+    mfu_flist list,
+    uint64_t idx,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1112,7 +1152,7 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, numpaths,
-            paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1146,7 +1186,7 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
     /* copy extended attributes, important to do this first before
      * writing data because some attributes tell file system how to
      * stripe data, e.g., Lustre */
-    if (mfu_copy_opts->preserve) {
+    if (copy_opts->preserve) {
         int tmp_rc = mfu_copy_xattrs(list, idx, dest_path);
         if (tmp_rc < 0) {
             rc = -1;
@@ -1156,7 +1196,7 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
     /* Truncate destination files to 0 bytes when sparse file is enabled,
      * this is because we will not overwrite sections corresponding to holes
      * and we need those to be set to 0 */
-    if (mfu_copy_opts->sparse) {
+    if (copy_opts->sparse) {
         /* truncate destination file to 0 bytes */
         struct stat st;
         int status = mfu_file_lstat(dest_path, &st, mfu_dst_file);
@@ -1191,10 +1231,14 @@ static int mfu_create_file(mfu_flist list, uint64_t idx,
 
 /* creates hardlink in destpath for specified file, identifies source path
  * returns 0 on success and -1 on error */
-static int mfu_create_hardlink(mfu_flist list, uint64_t idx,
-        const mfu_param_path* srcpath, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file,
-        mfu_file_t* mfu_dst_file)
+static int mfu_create_hardlink(
+    mfu_flist list,
+    uint64_t idx,
+    const mfu_param_path* srcpath,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1204,7 +1248,7 @@ static int mfu_create_hardlink(mfu_flist list, uint64_t idx,
 
     /* get destination name */
     const char* dest_path = mfu_param_path_copy_dest(src_path, 1,
-            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* No need to copy it */
     if (dest_path == NULL) {
@@ -1264,10 +1308,16 @@ static void create_progress_fn(const uint64_t* vals, int count, int complete, in
 
 /* creates file inodes and symlinks,
  * returns 0 on success and -1 on error */
-static int mfu_create_files(int levels, int minlevel,
-        mfu_flist* lists, int numpaths, const mfu_param_path* paths,
-        const mfu_param_path* destpath, mfu_copy_opts_t* mfu_copy_opts,
-        mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_create_files(
+    int levels,
+    int minlevel,
+    mfu_flist* lists,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     int rc = 0;
 
@@ -1311,7 +1361,7 @@ static int mfu_create_files(int levels, int minlevel,
             if (type == MFU_TYPE_FILE) {
                 /* create inode and copy xattr for regular file */
                 int tmp_rc = mfu_create_file(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1320,7 +1370,7 @@ static int mfu_create_files(int levels, int minlevel,
             } else if (type == MFU_TYPE_LINK) {
                 /* create symlink */
                 int tmp_rc = mfu_create_link(list, idx, numpaths,
-                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -1386,10 +1436,15 @@ static int mfu_create_files(int levels, int minlevel,
 
 /* creates hardlinks,
  * returns 0 on success and -1 on error */
-static int mfu_create_hardlinks(int levels, int minlevel, mfu_flist* lists,
-        const mfu_param_path* srcpath, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file,
-        mfu_file_t* mfu_dst_file)
+static int mfu_create_hardlinks(
+    int levels,
+    int minlevel,
+    mfu_flist* lists,
+    const mfu_param_path* srcpath,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     int rc = 0;
 
@@ -1433,7 +1488,7 @@ static int mfu_create_hardlinks(int levels, int minlevel, mfu_flist* lists,
             }
 
             int tmp_rc = mfu_create_hardlink(list, idx, srcpath,
-                                             destpath, mfu_copy_opts,
+                                             destpath, copy_opts,
                                              mfu_src_file, mfu_dst_file);
             if (tmp_rc != 0) {
                 rc = -1;
@@ -1562,16 +1617,16 @@ static int mfu_copy_file_normal(
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_copy_opts_t* copy_opts,
     mfu_file_t* mfu_src_file,
     mfu_file_t* mfu_dst_file)
 {
     /* set buffer and buffer size */
-    size_t buf_size = mfu_copy_opts->block_size;
-    void* buf       = mfu_copy_opts->block_buf1;
+    size_t buf_size = copy_opts->block_size;
+    void* buf       = copy_opts->block_buf1;
 
     /* for O_DIRECT, check that length is multiple of block_size */
-    if (mfu_copy_opts->direct &&       /* using O_DIRECT */
+    if (copy_opts->direct &&           /* using O_DIRECT */
         offset + length < file_size && /* not at end of file */
         length % buf_size != 0)        /* length not an integer multiple of block size */
     {
@@ -1589,7 +1644,7 @@ static int mfu_copy_file_normal(
          * O_DIRECT requires read operation of certain size blocks,
          * even if we know that would run past the end of the file */
         size_t left_to_read = buf_size;
-        if (! mfu_copy_opts->direct) {
+        if (! copy_opts->direct) {
             uint64_t remainder = length - total_bytes;
             if (remainder < (uint64_t) buf_size) {
                 left_to_read = (size_t) remainder;
@@ -1602,7 +1657,7 @@ static int mfu_copy_file_normal(
         /* If we're using O_DIRECT, deal with short reads.
          * Retry with same buffer and offset since those must
          * be aligned at block boundaries. */
-        while (mfu_copy_opts->direct &&        /* using O_DIRECT */
+        while (copy_opts->direct &&            /* using O_DIRECT */
                bytes_read > 0 &&               /* read was not an error or eof */
                bytes_read < left_to_read &&    /* shorter than requested */
                (off + bytes_read) < file_size) /* not at end of file */
@@ -1627,7 +1682,7 @@ static int mfu_copy_file_normal(
 
         /* compute number of bytes to write */
         size_t bytes_to_write = (size_t) bytes_read;
-        if (mfu_copy_opts->direct) {
+        if (copy_opts->direct) {
             /* O_DIRECT requires particular write sizes,
              * ok to write beyond end of file so long as
              * we truncate in cleanup step */
@@ -1649,7 +1704,7 @@ static int mfu_copy_file_normal(
          * If this hole is at the end of the file, the truncate below will
          * set the file size correctly. */
         int skip_write = 0;
-        if (mfu_copy_opts->sparse && mfu_is_all_null(buf, bytes_to_write)) {
+        if (copy_opts->sparse && mfu_is_all_null(buf, bytes_to_write)) {
             skip_write = 1;
         }
 
@@ -1672,7 +1727,7 @@ static int mfu_copy_file_normal(
                  * by advancing by the number of bytes written.  For O_DIRECT, we
                  * need to keep buffer, file offset, and amount to write aligned
                  * on block boundaries, so just retry the entire operation. */
-                if (!mfu_copy_opts->direct || bytes_written == bytes_to_write) {
+                if (!copy_opts->direct || bytes_written == bytes_to_write) {
                     n += bytes_written;
                 }
             }
@@ -1722,12 +1777,12 @@ static int mfu_copy_file_fiemap(
     uint64_t length,
     uint64_t file_size,
     bool* normal_copy_required,
-    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_copy_opts_t* copy_opts,
     mfu_file_t* mfu_src_file,
     mfu_file_t* mfu_dst_file)
 {
     *normal_copy_required = true;
-    if (mfu_copy_opts->direct) {
+    if (copy_opts->direct) {
         goto fail_normal_copy;
     }
 
@@ -1815,8 +1870,8 @@ static int mfu_copy_file_fiemap(
         size_t ext_len;
         size_t ext_hole_size;
 
-        size_t buf_size = mfu_copy_opts->block_size;
-        void* buf = mfu_copy_opts->block_buf1;
+        size_t buf_size = copy_opts->block_size;
+        void* buf = copy_opts->block_buf1;
 
         ext_start = fiemap->fm_extents[i].fe_logical;
         ext_len = fiemap->fm_extents[i].fe_length;
@@ -1896,7 +1951,7 @@ static int mfu_copy_file(
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_copy_opts_t* copy_opts,
     mfu_file_t* mfu_src_file,
     mfu_file_t* mfu_dst_file)
 {
@@ -1904,7 +1959,7 @@ static int mfu_copy_file(
 
     /* open the input file */
     mfu_copy_open_file(src, 1, &mfu_copy_src_cache,
-                       mfu_copy_opts, mfu_src_file);
+                       copy_opts, mfu_src_file);
     if (mfu_src_file->fd < 0 && mfu_src_file->type != DAOS) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open input file `%s' (errno=%d %s)",
             src, errno, strerror(errno));
@@ -1913,16 +1968,16 @@ static int mfu_copy_file(
 
     /* open the output file */
     mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache,
-                       mfu_copy_opts, mfu_dst_file);
+                       copy_opts, mfu_dst_file);
     if (mfu_dst_file->fd < 0 && mfu_dst_file->type != DAOS) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open output file `%s' (errno=%d %s)", dest, errno, strerror(errno));
         return -1;
     }
 
-    if (mfu_copy_opts->sparse) {
+    if (copy_opts->sparse) {
         bool normal_copy_required;
         ret = mfu_copy_file_fiemap(src, dest, offset, length, file_size,
-                               &normal_copy_required, mfu_copy_opts,
+                               &normal_copy_required, copy_opts,
                                mfu_src_file, mfu_dst_file);
         if (!ret || !normal_copy_required) {
             return ret;
@@ -1930,7 +1985,7 @@ static int mfu_copy_file(
     }
 
     ret = mfu_copy_file_normal(src, dest, offset, length, file_size,
-                               mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                               copy_opts, mfu_src_file, mfu_dst_file);
 
     return ret;
 }
@@ -1938,9 +1993,14 @@ static int mfu_copy_file(
 /* slices files in list at boundaries of chunk size, evenly distributes
  * chunks, and copies data from source to destination file,
  * returns 0 on success and -1 on error */
-static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
-        int numpaths, const mfu_param_path* paths, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+static int mfu_copy_files(
+    mfu_flist list,
+    int numpaths,
+    const mfu_param_path* paths,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -1971,7 +2031,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
 
     /* split file list into a linked list of file sections,
      * this evenly spreads the file sections across processes */
-    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, chunk_size);
+    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, copy_opts->chunk_size);
 
     /* get a count of how many items are the chunk list */
     uint64_t list_count = mfu_file_chunk_list_size(head);
@@ -1990,7 +2050,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
 
         /* get name of destination file */
         char* dest = mfu_param_path_copy_dest(p->name, numpaths,
-                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
         if (dest == NULL) {
             /* No need to copy it */
             p = p->next;
@@ -2003,7 +2063,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
         /* copy portion of file corresponding to this chunk,
          * and record whether copy operation succeeded */
         int copy_rc = mfu_copy_file(p->name, dest, (uint64_t)p->offset,
-                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts,
+                (uint64_t)p->length, (uint64_t)p->file_size, copy_opts,
                 mfu_src_file, mfu_dst_file);
         if (copy_rc < 0) {
             /* error copying file */
@@ -2045,7 +2105,7 @@ static int mfu_copy_files(mfu_flist list, uint64_t chunk_size,
              * compute destination name and delete it */
             const char* name = mfu_flist_file_get_name(list, i);
             const char* dest = mfu_param_path_copy_dest(name, numpaths,
-                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
             if (dest != NULL) {
                 /* sanity check to ensure we don't * delete the source file */
                 if (strcmp(dest, name) != 0) {
@@ -2236,9 +2296,14 @@ static void print_summary(mfu_flist flist)
     return;
 }
 
-int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
-        const mfu_param_path* paths, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+int mfu_flist_copy(
+    mfu_flist src_cp_list,          /* list of source items to be copied */
+    int numpaths,                   /* number of entries in paths array below */
+    const mfu_param_path* paths,    /* list of paths, each source item is from one path in this list */
+    const mfu_param_path* destpath, /* destination path to copy items to */
+    mfu_copy_opts_t* copy_opts,     /* options to configure how copy is executed */
+    mfu_file_t* mfu_src_file,       /* whether source items are coming from POSIX/DAOS */
+    mfu_file_t* mfu_dst_file)       /* whether destination is in POSIX/DAOS */
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -2254,27 +2319,22 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
-    /* set mfu_copy options in mfu_copy_opts_t struct */
-
     /* copy the destination path to user opts structure */
-    mfu_copy_opts->dest_path = MFU_STRDUP((*destpath).path);
+    copy_opts->dest_path = MFU_STRDUP((*destpath).path);
 
     /* print note about what we're doing and the amount of files/data to be moved */
     if (rank == 0) {
-        MFU_LOG(MFU_LOG_INFO, "Copying to %s", mfu_copy_opts->dest_path);
+        MFU_LOG(MFU_LOG_INFO, "Copying to %s", copy_opts->dest_path);
     }
     mfu_flist_print_summary(src_cp_list);
 
     /* TODO: consider file system striping params here */
     /* hard code some configurables for now */
 
-    /* Set default block size */
-    mfu_copy_opts->block_size = MFU_BLOCK_SIZE;
-
     /* allocate buffer to read/write files, aligned on 1MB boundaraies */
     size_t alignment = 1024*1024;
-    mfu_copy_opts->block_buf1 = (char*) MFU_MEMALIGN(mfu_copy_opts->block_size, alignment);
-    mfu_copy_opts->block_buf2 = (char*) MFU_MEMALIGN(mfu_copy_opts->block_size, alignment);
+    copy_opts->block_buf1 = (char*) MFU_MEMALIGN(copy_opts->block_size, alignment);
+    copy_opts->block_buf2 = (char*) MFU_MEMALIGN(copy_opts->block_size, alignment);
 
     /* Grab a relative and actual start time for the epilogue. */
     time(&(mfu_copy_stats.time_started));
@@ -2301,13 +2361,13 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
     /* create directories, from top down */
     int tmp_rc = mfu_create_directories(levels, minlevel, lists, numpaths,
-            paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
 
     /* operate on files in batches if batch size is given */
-    uint64_t batch_size = mfu_copy_opts->batch_files;
+    uint64_t batch_size = copy_opts->batch_files;
     if (batch_size > 0) {
         /* operate in batches, get total size of list, our global
          * offset within it, and the local size of our list to
@@ -2364,14 +2424,14 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
                 /* create files and links */
                 tmp_rc = mfu_create_files(levels2, minlevel2, lists2, numpaths,
-                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
 
                 /* copy data */
-                tmp_rc = mfu_copy_files(spreadlist, mfu_copy_opts->chunk_size,
-                        numpaths, paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                tmp_rc = mfu_copy_files(spreadlist, numpaths, paths, destpath,
+                    copy_opts, mfu_src_file, mfu_dst_file);
                 if (tmp_rc < 0) {
                     rc = -1;
                 }
@@ -2382,7 +2442,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
                 /* set permissions, ownership, and timestamps if needed */
                 mfu_copy_set_metadata(levels2, minlevel2, lists2, numpaths,
-                        paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                        paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
                 /* free our lists of levels */
                 mfu_flist_array_free(levels2, &lists2);
@@ -2469,7 +2529,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* set permissions, ownership, and timestamps if needed */
         mfu_copy_set_metadata_dirs(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
         /* force updates to disk */
         mfu_sync_all("Syncing directory updates to disk.");
@@ -2478,14 +2538,14 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* create files and links */
         tmp_rc = mfu_create_files(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
 
         /* copy data */
-        tmp_rc = mfu_copy_files(src_cp_list, mfu_copy_opts->chunk_size,
-                numpaths, paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+        tmp_rc = mfu_copy_files(src_cp_list, numpaths, paths, destpath,
+            copy_opts, mfu_src_file, mfu_dst_file);
         if (tmp_rc < 0) {
             rc = -1;
         }
@@ -2496,7 +2556,7 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
 
         /* set permissions, ownership, and timestamps if needed */
         mfu_copy_set_metadata(levels, minlevel, lists, numpaths,
-                paths, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+                paths, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
         /* force updates to disk */
         mfu_sync_all("Syncing directory updates to disk.");
@@ -2506,8 +2566,8 @@ int mfu_flist_copy(mfu_flist src_cp_list, int numpaths,
     mfu_flist_array_free(levels, &lists);
 
     /* free buffers */
-    mfu_free(&mfu_copy_opts->block_buf1);
-    mfu_free(&mfu_copy_opts->block_buf2);
+    mfu_free(&copy_opts->block_buf1);
+    mfu_free(&copy_opts->block_buf2);
 
     /* Determine the actual and relative end time for the epilogue. */
     mfu_copy_stats.wtime_ended = MPI_Wtime();
@@ -2645,13 +2705,13 @@ static int mfu_fill_file(
     uint64_t offset,
     uint64_t length,
     uint64_t file_size,
-    mfu_copy_opts_t* mfu_copy_opts,
+    mfu_copy_opts_t* copy_opts,
     mfu_file_t* mfu_file)
 {
     int ret;
 
     /* open the file */
-    mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, mfu_copy_opts, mfu_file);
+    mfu_copy_open_file(dest, 0, &mfu_copy_dst_cache, copy_opts, mfu_file);
     int out_fd = mfu_file->fd; 
     if (out_fd < 0) {
         MFU_LOG(MFU_LOG_ERR, "Failed to open output file `%s' (errno=%d %s)",
@@ -2667,8 +2727,8 @@ static int mfu_fill_file(
     }
 
     /* get buffer */
-    size_t buf_size = mfu_copy_opts->block_size;
-    void* buf = mfu_copy_opts->block_buf1;
+    size_t buf_size = copy_opts->block_size;
+    void* buf = copy_opts->block_buf1;
 
     /* fill buffer with data */
 
@@ -2683,7 +2743,7 @@ static int mfu_fill_file(
         }
 
         /* compute number of bytes to write */
-        if (mfu_copy_opts->direct) {
+        if (copy_opts->direct) {
             /* O_DIRECT requires particular write sizes,
              * ok to write beyond end of file so long as
              * we truncate in cleanup step */
@@ -2746,19 +2806,19 @@ static int mfu_fill_file(
     return ret;
 }
 
-int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_file)
+int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* copy_opts, mfu_file_t* mfu_file)
 {
     int rc = MFU_SUCCESS;
 
     /* allocate buffer to write files, aligned on 1MB boundaraies */
     size_t alignment = 1024*1024;
-    mfu_copy_opts->block_buf1 = (char*) MFU_MEMALIGN(mfu_copy_opts->block_size, alignment);
+    copy_opts->block_buf1 = (char*) MFU_MEMALIGN(copy_opts->block_size, alignment);
 
     /* fill buffer with data */
-    //memset(mfu_copy_opts->block_buf1, 0, mfu_copy_opts->block_size);
+    //memset(copy_opts->block_buf1, 0, copy_opts->block_size);
     size_t idx;
-    for (idx = 0; idx < mfu_copy_opts->block_size; idx++) {
-        mfu_copy_opts->block_buf1[idx] = (char) rand();
+    for (idx = 0; idx < copy_opts->block_size; idx++) {
+        copy_opts->block_buf1[idx] = (char) rand();
     }
 
     /* determine whether we should print status messages */
@@ -2788,7 +2848,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* m
 
     /* split file list into a linked list of file sections,
      * this evenly spreads the file sections across processes */
-    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, mfu_copy_opts->chunk_size);
+    mfu_file_chunk* head = mfu_file_chunk_list_alloc(list, copy_opts->chunk_size);
 
     /* get a count of how many items are the chunk list */
     uint64_t list_count = mfu_file_chunk_list_size(head);
@@ -2811,7 +2871,7 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* m
         /* copy portion of file corresponding to this chunk,
          * and record whether copy operation succeeded */
         int copy_rc = mfu_fill_file(p->name, (uint64_t)p->offset,
-                (uint64_t)p->length, (uint64_t)p->file_size, mfu_copy_opts, mfu_file);
+                (uint64_t)p->length, (uint64_t)p->file_size, copy_opts, mfu_file);
         if (copy_rc < 0) {
             /* error copying file */
             vals[i] = 1;
@@ -2908,9 +2968,13 @@ int mfu_flist_fill(mfu_flist list, mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* m
     return rc;
 }
 
-int mfu_flist_hardlink(mfu_flist src_link_list,
-        const mfu_param_path* srcpath, const mfu_param_path* destpath,
-        mfu_copy_opts_t* mfu_copy_opts, mfu_file_t* mfu_src_file, mfu_file_t* mfu_dst_file)
+int mfu_flist_hardlink(
+    mfu_flist src_link_list,
+    const mfu_param_path* srcpath,
+    const mfu_param_path* destpath,
+    mfu_copy_opts_t* copy_opts,
+    mfu_file_t* mfu_src_file,
+    mfu_file_t* mfu_dst_file)
 {
     /* assume we'll succeed */
     int rc = 0;
@@ -2919,14 +2983,12 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
     int rank;
     MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 
-    /* set mfu_copy options in mfu_copy_opts_t struct */
-
     /* copy the destination path to user opts structure */
-    mfu_copy_opts->dest_path = MFU_STRDUP((*destpath).path);
+    copy_opts->dest_path = MFU_STRDUP((*destpath).path);
 
     /* print note about what we're doing and the amount of files/data to be moved */
     if (rank == 0) {
-        MFU_LOG(MFU_LOG_INFO, "Linking to %s", mfu_copy_opts->dest_path);
+        MFU_LOG(MFU_LOG_INFO, "Linking to %s", copy_opts->dest_path);
     }
     mfu_flist_print_summary(src_link_list);
 
@@ -2955,7 +3017,7 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
 
     /* create directories, from top down */
     int tmp_rc = mfu_create_directories(levels, minlevel, lists, 1,
-            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
@@ -2967,14 +3029,14 @@ int mfu_flist_hardlink(mfu_flist src_link_list,
      * has better idea for it. */
     /* create hard links */
     tmp_rc = mfu_create_hardlinks(levels, minlevel, lists,
-            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
     if (tmp_rc < 0) {
         rc = -1;
     }
 
     /* set permissions, ownership, and timestamps if needed */
     mfu_copy_set_metadata(levels, minlevel, lists, 1,
-            srcpath, destpath, mfu_copy_opts, mfu_src_file, mfu_dst_file);
+            srcpath, destpath, copy_opts, mfu_src_file, mfu_dst_file);
 
     /* force updates to disk */
     mfu_sync_all("Syncing directory updates to disk.");
@@ -3134,36 +3196,36 @@ mfu_copy_opts_t* mfu_copy_opts_new(void)
     opts->copy_into_dir = 0;
 
     /* By default, we want the sync option off */
-    opts->do_sync       = 0;
+    opts->do_sync = 0;
 
     /* to record destination path that we'll be copying to */
-    opts->dest_path     = NULL;
+    opts->dest_path = NULL;
 
     /* records name of input file to read source list from (not used?) */
-    opts->input_file    = NULL;
+    opts->input_file = NULL;
 
     /* By default, don't bother to preserve all attributes. */
-    opts->preserve      = false;
+    opts->preserve = false;
 
     /* By default, don't use O_DIRECT. */
-    opts->direct        = false;
+    opts->direct = false;
 
     /* By default, don't use sparse file. */
-    opts->sparse        = false;
+    opts->sparse = false;
 
     /* Set default chunk size */
-    opts->chunk_size    = MFU_CHUNK_SIZE;
+    opts->chunk_size = MFU_CHUNK_SIZE;
 
     /* temporaries used during the copy operation for buffers to read/write data */
-    opts->block_size    = MFU_BLOCK_SIZE;
-    opts->block_buf1    = NULL;
-    opts->block_buf2    = NULL;
+    opts->block_size = MFU_BLOCK_SIZE;
+    opts->block_buf1 = NULL;
+    opts->block_buf2 = NULL;
 
     /* Zero is invalid for the Lustre grouplock ID. */
-    opts->grouplock_id  = 0;
+    opts->grouplock_id = 0;
 
     /* By default, do not limit the batch size */
-    opts->batch_files   = 0;
+    opts->batch_files = 0;
 
     return opts;
 }

From 66c5273035396c34998c32e9d7918bce9aeca58f Mon Sep 17 00:00:00 2001
From: Toyohisa Kameyama <kameyama@riken.jp>
Date: Fri, 25 Sep 2020 10:04:58 +0900
Subject: [PATCH 25/27] mfu: support aarch64

aarch64 kernel is not found SYS_getdents.
If SYS_getdents is not defined, use sys_getdents64.

Signed-off-by: Toyohisa Kameyama <kameyama@riken.jp>
---
 src/common/mfu_flist_walk.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/common/mfu_flist_walk.c b/src/common/mfu_flist_walk.c
index ed81c8d8..08836c45 100644
--- a/src/common/mfu_flist_walk.c
+++ b/src/common/mfu_flist_walk.c
@@ -161,6 +161,9 @@ static void walk_getdents_process_dir(const char* dir, CIRCLE_handle* handle)
         return;
     }
 
+#if !defined(SYS_getdents) && defined(SYS_getdents64)
+#define SYS_getdents SYS_getdents64
+#endif
     /* Read all directory entries */
     while (1) {
         /* execute system call to get block of directory entries */

From fb5b43cd703bdf4d2857238fb5969525e688242b Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Thu, 24 Sep 2020 20:59:30 +0000
Subject: [PATCH 26/27] daos: enhance use of lookup hash

lookup_insert_dir and associated functions have been
refactored and expanded.

*mfu_param_path.h*
- Added dfs_hash to mfu_file.
- Removed only_daos from mfu_file, since it is no longer needed

*Naming convention*
- Changed mfu_* to daos_* since they are only used by DAOS.
- Changed lookup_insert_dir to daos_lookup_hash.

*daos_lookup_hash and associated functions*
- Gets the hash from mfu_file instead of a global.
- Uses a pointer to the name instead of static allocation,
  which saves space.
- Updated error messages to use MFU_LOG instead of stderr directly.
- Added a _new and _delete function for the object handle struct.
- Properly deallocate and free each entry.

*daos_ IO functions*
With the excpetion of daos_opendir and daos_closedir,
all daos_ IO functions now use daos_hash_lookup to
get directory entries.

*mfu_util*
- Added daos_mount as a wrapper for dfs_mount.
- Added daos_umount as a wrapper for dfs_umount.
  This also destroys the hash.

*dcp.c*
Now uses the new daos_mount and daos_umount functions.

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/mfu_flist_copy.c |   2 +-
 src/common/mfu_io.c         | 266 ++++++++++++++++++++----------------
 src/common/mfu_param_path.h |  12 +-
 src/common/mfu_util.c       |  36 +++++
 src/common/mfu_util.h       |  13 ++
 src/dcp/dcp.c               |  32 ++---
 6 files changed, 216 insertions(+), 145 deletions(-)

diff --git a/src/common/mfu_flist_copy.c b/src/common/mfu_flist_copy.c
index dac01a76..3d9109c3 100644
--- a/src/common/mfu_flist_copy.c
+++ b/src/common/mfu_flist_copy.c
@@ -3171,10 +3171,10 @@ mfu_file_t* mfu_file_new(void)
     mfu_file_t* mfile = (mfu_file_t*) MFU_MALLOC(sizeof(mfu_file_t));
     mfile->type       = POSIX;
     mfile->fd         = -1;
-    mfile->only_daos  = false;
 #ifdef DAOS_SUPPORT
     mfile->obj        = NULL;
     mfile->dfs        = NULL;
+    mfile->dfs_hash   = NULL;
 #endif
     return mfile;
 }
diff --git a/src/common/mfu_io.c b/src/common/mfu_io.c
index 40f83e87..a43e039e 100644
--- a/src/common/mfu_io.c
+++ b/src/common/mfu_io.c
@@ -25,81 +25,136 @@
 static int mpi_rank;
 
 #ifdef DAOS_SUPPORT
-struct d_hash_table *dir_hash;
-
-struct mfu_dir_hdl {
-        d_list_t	entry;
-        dfs_obj_t	*oh;
-        char		name[PATH_MAX];
+/* Handle for a hash table entry */
+struct daos_dir_hdl {
+    d_list_t    entry;
+    dfs_obj_t*  oh;
+    char*       name;
 };
 
-static inline struct mfu_dir_hdl* hdl_obj(d_list_t *rlink)
+/* Return a newly allocated daos_dir_hdl structure */
+static struct daos_dir_hdl* daos_dir_hdl_new(void)
 {
-        return container_of(rlink, struct mfu_dir_hdl, entry);
+    struct daos_dir_hdl* hdl = (struct daos_dir_hdl*) MFU_MALLOC(sizeof(struct daos_dir_hdl));
+    hdl->oh = NULL;
+    hdl->name = NULL;
+
+    return hdl;
 }
 
-static bool key_cmp(struct d_hash_table *htable, d_list_t *rlink,
-	const void *key, unsigned int ksize)
+/* free a daos_dir_hdl structure */
+static void daos_dir_hdl_delete(struct daos_dir_hdl** phdl)
 {
-        struct mfu_dir_hdl *hdl = hdl_obj(rlink);
+    if (phdl != NULL) {
+        struct daos_dir_hdl* hdl = *phdl;
+        if (hdl->oh != NULL) {
+            dfs_release(hdl->oh);
+        }
+        mfu_free(&hdl->name);
+        mfu_free(phdl);
+    }
+}
 
-        return (strcmp(hdl->name, (const char *)key) == 0);
+/* Get the daos_dir_hdl from its entry */
+static inline struct daos_dir_hdl* hdl_obj(d_list_t* rlink)
+{
+    return container_of(rlink, struct daos_dir_hdl, entry);
 }
 
-static void rec_free(struct d_hash_table *htable, d_list_t *rlink)
+/* Simple string comparison of hdl->name as the key */
+static bool key_cmp(struct d_hash_table* htable, d_list_t* rlink, 
+        const void* key, unsigned int ksize)
 {
-        struct mfu_dir_hdl *hdl = hdl_obj(rlink);
+    struct daos_dir_hdl* hdl = hdl_obj(rlink);
 
-        assert(d_hash_rec_unlinked(&hdl->entry));
-        dfs_release(hdl->oh);
-        free(hdl);
+    return (strcmp(hdl->name, (const char *)key) == 0);
 }
 
+/* Since we only delete entries when we are finished with them,
+ * this should always return true so rec_free is called */
+static bool rec_decref(struct d_hash_table* htable, d_list_t* rlink)
+{
+    return true;
+}
+
+/* Free a hash entry. Called when the table is destroyed */
+static void rec_free(struct d_hash_table* htable, d_list_t* rlink)
+{
+    struct daos_dir_hdl* hdl = hdl_obj(rlink);
+
+    assert(d_hash_rec_unlinked(&hdl->entry));
+    daos_dir_hdl_delete(&hdl);
+}
+
+/* Operations for the hash table */
 static d_hash_table_ops_t hdl_hash_ops = {
-        .hop_key_cmp	= key_cmp,
-        .hop_rec_free	= rec_free
+    .hop_key_cmp    = key_cmp,
+    .hop_rec_decref = rec_decref,
+    .hop_rec_free   = rec_free
 };
 
-static dfs_obj_t* lookup_insert_dir(const char *name, mfu_file_t* mfu_file)
+/* Caches calls to dfs_lookup and returns lookups from the cache. */
+static dfs_obj_t* daos_hash_lookup(const char* name, mfu_file_t* mfu_file)
 {
-        struct mfu_dir_hdl *hdl;
-        d_list_t *rlink;
-        int rc;
-
-        /* TODO: need to make sure we have a corresponding d_hash_table_destroy */
-	if (dir_hash == NULL) {
-	    rc = d_hash_table_create(0, 16, NULL, &hdl_hash_ops, &dir_hash);
-	    if (rc) {
-		    fprintf(stderr, "Failed to initialize dir hashtable");
-		    return NULL;
-	    }
-	}
+    struct daos_dir_hdl* hdl;
+    d_list_t* rlink;
+    int rc;
 
-        rlink = d_hash_rec_find(dir_hash, name, strlen(name));
-        if (rlink != NULL) {
-                hdl = hdl_obj(rlink);
-                return hdl->oh;
+    /* Make sure the hash is initialized */
+    if (mfu_file->dfs_hash == NULL) {
+        rc = d_hash_table_create(D_HASH_FT_NOLOCK, 16, NULL, &hdl_hash_ops, &mfu_file->dfs_hash);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "Failed to initialize dir hashtable");
+            return NULL;
         }
+    }
 
-        hdl = calloc(1, sizeof(struct mfu_dir_hdl));
-        if (hdl == NULL)
-		return NULL;
+    /* If cached, return it */
+    rlink = d_hash_rec_find(mfu_file->dfs_hash, name, strlen(name));
+    if (rlink != NULL) {
+        hdl = hdl_obj(rlink);
+        return hdl->oh;
+    }
 
-        strncpy(hdl->name, name, PATH_MAX-1);
-        hdl->name[PATH_MAX-1] = '\0';
+    /* Create a new entry */
+    hdl = daos_dir_hdl_new();
+    if (hdl == NULL) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to initialze hash entry");
+        daos_dir_hdl_delete(&hdl);
+        return NULL;
+    }
 
-        rc = dfs_lookup(mfu_file->dfs, name, O_RDWR, &hdl->oh, NULL, NULL);
-	if (rc) {
-		fprintf(stderr, "dfs_lookup() of %s Failed", name);
-		return NULL;
-	}
+    /* Allocate space for name, up to PATH_MAX,
+     * leaving 1 extra for the null terminator */
+    size_t name_len = strnlen(name, PATH_MAX-1);
+    if (name_len >= PATH_MAX-1) {
+        MFU_LOG(MFU_LOG_ERR, "name is too long");
+        daos_dir_hdl_delete(&hdl);
+        return NULL;
+    }
+    hdl->name = MFU_STRDUP(name);
+
+    /* Lookup the object handle */
+    rc = dfs_lookup(mfu_file->dfs, name, O_RDWR, &hdl->oh, NULL, NULL);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "dfs_lookup() of %s Failed", name);
+        daos_dir_hdl_delete(&hdl);
+        return NULL;
+    }
 
-        rc = d_hash_rec_insert(dir_hash, hdl->name, strlen(hdl->name),
-                               &hdl->entry, true);
-	if (rc)
-		return NULL;
+    /* Store this entry in the hash.
+     * Since we have already called d_hash_rec_find,
+     * pass exclusive=false to avoid another find being called */
+    rc = d_hash_rec_insert(mfu_file->dfs_hash, hdl->name, name_len,
+                            &hdl->entry, false);
+    if (rc) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to insert hash entry");
+        daos_dir_hdl_delete(&hdl);
+        return NULL;
+    }
 
-        return hdl->oh;
+    /* Return the object */
+    return hdl->oh;
 }
 
 static int parse_filename(const char* path, char** _obj_name, char** _cont_name)
@@ -283,10 +338,10 @@ int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
     parse_filename(path, &name, &dir_name);
     assert(dir_name);
 
-    dfs_obj_t* parent = NULL;
-    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    int rc = 0;
+
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
     if (parent == NULL) {
-        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
         errno = ENOENT;
         rc = -1;
     } else {
@@ -297,8 +352,6 @@ int daos_chmod(const char *path, mode_t mode, mfu_file_t* mfu_file)
             errno = rc;
             rc = -1;
         }
-        /* close the parent, ignoring errors since they have no direct impact */
-        dfs_release(parent);
     }
 
     mfu_free(&name);
@@ -366,6 +419,7 @@ int mfu_utimensat(int dirfd, const char *pathname, const struct timespec times[2
     return rc;
 }
 
+/* stat a DAOS path */
 int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
@@ -374,30 +428,22 @@ int daos_stat(const char* path, struct stat* buf, mfu_file_t* mfu_file)
     parse_filename(path, &name, &dir_name);
     assert(dir_name);
 
-    dfs_obj_t* parent = NULL;
-    int rc;
-    if (mfu_file->only_daos) {
-        rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
+    if (parent == NULL) {
+        errno = ENOENT;
+        rc = -1;
+    } else {
+        /* Stat the path */
+        rc = dfs_stat(mfu_file->dfs, parent, name, buf);
         if (rc) {
-            MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
-            errno = ENOENT;
+            MFU_LOG(MFU_LOG_ERR, "dfs_stat %s failed (%d %s)",
+                    name, rc, strerror(rc));
+            errno = rc;
             rc = -1;
         }
-    } else {
-        parent = lookup_insert_dir(dir_name, mfu_file);
-    }
-    rc = dfs_stat(mfu_file->dfs, parent, name, buf);
-    if (rc) {
-        MFU_LOG(MFU_LOG_ERR, "dfs_stat %s failed (%d %s)",
-                name, rc, strerror(rc));
-        errno = rc;
-        rc = -1;
-    }
-
-    /* close the parent, ignoring errors since they have no direct impact. 
-     * only close if dfs_lookup was called here */
-    if (mfu_file->only_daos && parent != NULL) {
-        dfs_release(parent);
     }
 
     mfu_free(&name);
@@ -482,10 +528,11 @@ int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
     parse_filename(path, &name, &dir_name);
     assert(dir_name);
 
-    dfs_obj_t* parent = NULL;
-    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
     if (parent == NULL) {
-        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
         errno = ENOENT;
         rc = -1;
     }
@@ -510,8 +557,6 @@ int daos_mknod(const char* path, mode_t mode, dev_t dev, mfu_file_t* mfu_file)
                 rc = -1;
             }
         }
-        /* close the parent, ignoring errors since they have no direct impact */
-        dfs_release(parent);
     }
 
     mfu_free(&name);
@@ -666,10 +711,11 @@ int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
     parse_filename(file, &name, &dir_name);
     assert(dir_name);
 
-    dfs_obj_t* parent = NULL;
-    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
     if (parent == NULL) {
-        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
         errno = ENOENT;
         rc = -1;
     } else {
@@ -682,8 +728,6 @@ int daos_open(const char* file, int flags, mode_t mode, mfu_file_t* mfu_file)
             errno = rc;
             rc = -1;
         }
-        /* close the parent, ignoring errors since they have no direct impact */
-        dfs_release(parent);
     }
 
     mfu_free(&name);
@@ -1277,7 +1321,10 @@ int mfu_file_unlink(const char* file, mfu_file_t* mfu_file)
     } 
 }
 
-/* emulates unlink on a DAOS file or symlink */
+/* emulates unlink on a DAOS file or symlink.
+ * Since checking the file type would require another
+ * lookup, for performance considerations,
+ * this also works on directories. */
 int daos_unlink(const char* file, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
@@ -1286,34 +1333,23 @@ int daos_unlink(const char* file, mfu_file_t* mfu_file)
     parse_filename(file, &name, &dir_name);
     assert(dir_name);
 
-    /* Need to lookup parent directory in DFS */
-    dfs_obj_t* parent = NULL;
-    mode_t mode;
-    int rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, &mode, NULL);
+    int rc = 0;
+
+    /* Lookup the parent directory */
+    dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
     if (parent == NULL) {
-        MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
         errno = ENOENT;
         rc = -1;
     } 
     else {
-        /* only allow regular files and symlinks */
-        if (!S_ISREG(mode) && !S_ISLNK(mode)) {
-            MFU_LOG(MFU_LOG_ERR, "Invalid entry type (not a file or symlink)");
-            errno = EINVAL;
+        /* remove the file */
+        rc = dfs_remove(mfu_file->dfs, parent, name, false, NULL);
+        if (rc) {
+            MFU_LOG(MFU_LOG_ERR, "dfs_remove failed (%d %s)",
+                    rc, strerror(rc));
+            errno = rc;
             rc = -1;
         }
-        else {
-            /* remove the file */
-            rc = dfs_remove(mfu_file->dfs, parent, name, false, NULL);
-            if (rc) {
-                MFU_LOG(MFU_LOG_ERR, "dfs_remove failed (%d %s)",
-                        rc, strerror(rc));
-                errno = rc;
-                rc = -1;
-            }
-        }
-        /* close the parent, ignoring errors since they have no direct impact */
-        dfs_release(parent);
     }
 
     mfu_free(&name);
@@ -1395,11 +1431,9 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
 
     /* only call mkdir if name is not the root DFS directory */
     if (name && strcmp(name, "/") != 0) {
-        /* Need to lookup parent directory in DFS */
-        dfs_obj_t* parent = NULL;
-        rc = dfs_lookup(mfu_file->dfs, dir_name, O_RDWR, &parent, NULL, NULL);
+        /* Lookup the parent directory */
+        dfs_obj_t* parent = daos_hash_lookup(dir_name, mfu_file);
         if (parent == NULL) {
-            MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir_name);
             errno = ENOENT;
             rc = -1;
         } else {
@@ -1411,8 +1445,6 @@ int daos_mkdir(const char* dir, mode_t mode, mfu_file_t* mfu_file)
                 errno = rc;
                 rc = -1;
             }
-            /* close the parent, ignoring errors since they have no direct impact */
-            dfs_release(parent);
         }
     }
 
@@ -1492,6 +1524,7 @@ struct dfs_mfu_t {
 };
 #endif
 
+/* open directory. This is not cached in mfu_file->dir_hash */
 DIR* daos_opendir(const char* dir, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
@@ -1501,7 +1534,7 @@ DIR* daos_opendir(const char* dir, mfu_file_t* mfu_file)
         return NULL;
     }
     int rc = dfs_lookup(mfu_file->dfs, dir, O_RDWR, &dirp->dir, NULL, NULL);
-    if (rc) {
+    if (dirp->dir == NULL) {
         MFU_LOG(MFU_LOG_ERR, "dfs_lookup %s failed", dir);
         errno = ENOENT;
         free(dirp);
@@ -1549,6 +1582,7 @@ DIR* mfu_file_opendir(const char* dir, mfu_file_t* mfu_file)
     }
 }
 
+/* close dir. This is not cached in mfu_file->dir_hash */
 int daos_closedir(DIR* _dirp, mfu_file_t* mfu_file)
 {
 #ifdef DAOS_SUPPORT
diff --git a/src/common/mfu_param_path.h b/src/common/mfu_param_path.h
index 59609d90..bfea4175 100644
--- a/src/common/mfu_param_path.h
+++ b/src/common/mfu_param_path.h
@@ -54,14 +54,14 @@ typedef struct mfu_param_path_t {
 
 /* options passed to I/O functions that tell them which backend filesystem to use */
 typedef struct {
-    enum        {POSIX, DAOS} type;
-    int         fd;
-    bool        only_daos;
+    enum                 {POSIX, DAOS} type;
+    int                  fd;
 #ifdef DAOS_SUPPORT
     /* DAOS specific variables for I/O */
-    daos_off_t   offset;
-    dfs_obj_t*   obj;
-    dfs_t*       dfs;
+    daos_off_t           offset;
+    dfs_obj_t*           obj;
+    dfs_t*               dfs;
+    struct d_hash_table* dfs_hash;
 #endif
 } mfu_file_t;
 
diff --git a/src/common/mfu_util.c b/src/common/mfu_util.c
index 69efedff..a5eb8053 100644
--- a/src/common/mfu_util.c
+++ b/src/common/mfu_util.c
@@ -4,6 +4,7 @@
 #include "mfu.h"
 #include "mpi.h"
 #include "dtcmp.h"
+#include "mfu_errors.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -26,6 +27,7 @@
 
 #ifdef DAOS_SUPPORT
 #include <gurt/common.h>
+#include <gurt/hash.h>
 #endif
 
 int mfu_initialized = 0;
@@ -195,6 +197,40 @@ int daos_connect(
 
     return 0;
 }
+
+int daos_mount(
+  mfu_file_t* mfu_file,
+  daos_handle_t* poh,
+  daos_handle_t* coh)
+{
+    /* Mount dfs */
+    int rc = dfs_mount(*poh, *coh, O_RDWR, &mfu_file->dfs);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
+                MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
+        rc = -1;
+    }
+
+    return rc;
+}
+
+int daos_umount(
+  mfu_file_t* mfu_file)
+{
+    /* Unmount dfs */
+    int rc = dfs_umount(mfu_file->dfs);
+    if (rc != 0) {
+        MFU_LOG(MFU_LOG_ERR, "Failed to unmount DFS namespace");
+        rc = -1;
+    }
+
+    /* Clean up the hash */
+    if (mfu_file->dfs_hash != NULL) {
+        d_hash_table_destroy(mfu_file->dfs_hash, true);
+    }
+
+    return rc;
+}
 #endif
 
 /* initialize mfu library,
diff --git a/src/common/mfu_util.h b/src/common/mfu_util.h
index 2630261b..ceb5c5f6 100644
--- a/src/common/mfu_util.h
+++ b/src/common/mfu_util.h
@@ -136,6 +136,19 @@ int daos_connect(
   bool connect_pool,
   bool create_cont
 );
+
+/* Mount DAOS dfs */
+int daos_mount(
+  mfu_file_t* mfu_file,
+  daos_handle_t* poh,
+  daos_handle_t* coh
+);
+
+/* Unmount DAOS dfs.
+ * Cleanup up hash */
+int daos_umount(
+  mfu_file_t* mfu_file
+);
 #endif
 
 /* initialize mfu library,
diff --git a/src/dcp/dcp.c b/src/dcp/dcp.c
index 47e4acba..5af24637 100644
--- a/src/dcp/dcp.c
+++ b/src/dcp/dcp.c
@@ -35,8 +35,6 @@ typedef struct {
     uuid_t dst_pool_uuid;  /* destination pool UUID */
     uuid_t src_cont_uuid;  /* source container UUID */
     uuid_t dst_cont_uuid;  /* destination container UUID */
-    dfs_t* dfs1;           /* source dfs object */
-    dfs_t* dfs2;           /* destination dfs object */
     char* src_svc;         /* source service level */
     char* dst_svc;         /* destination service level */
     char* dfs_prefix;      /* prefix for UNS */
@@ -52,8 +50,6 @@ static daos_args_t* daos_args_new(void)
     da->dst_poh    = DAOS_HDL_INVAL;
     da->src_coh    = DAOS_HDL_INVAL;
     da->dst_coh    = DAOS_HDL_INVAL;
-    da->dfs1       = NULL;
-    da->dfs2       = NULL;
     da->src_svc    = NULL;
     da->dst_svc    = NULL;
     da->dfs_prefix = NULL;
@@ -67,8 +63,7 @@ static daos_args_t* daos_args_new(void)
     return da;
 }
 
-/* free a daos_args_t structure.
- * dfs is handled in dfs_umount */
+/* free a daos_args_t structure */
 static void daos_args_delete(daos_args_t** pda)
 {
     if (pda != NULL) {
@@ -461,10 +456,8 @@ static int daos_setup(
 
     if (!local_daos_error && mfu_src_file->type == DAOS) {
         /* DFS is mounted for the source container */
-        tmp_rc = dfs_mount(da->src_poh, da->src_coh, O_RDWR, &da->dfs1);
+        tmp_rc = daos_mount(mfu_src_file, &da->src_poh, &da->src_coh);
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
-                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
             local_daos_error = true;
         }
     }
@@ -472,13 +465,11 @@ static int daos_setup(
     if (!local_daos_error && mfu_dst_file->type == DAOS) {
         /* DFS is mounted for the destination container */
         if (same_pool) {
-            tmp_rc = dfs_mount(da->src_poh, da->dst_coh, O_RDWR, &da->dfs2);
+            tmp_rc = daos_mount(mfu_dst_file, &da->src_poh, &da->dst_coh);
         } else {
-            tmp_rc = dfs_mount(da->dst_poh, da->dst_coh, O_RDWR, &da->dfs2);
+            tmp_rc = daos_mount(mfu_dst_file, &da->dst_poh, &da->dst_coh);
         }
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to mount DAOS filesystem (DFS): "
-                    MFU_ERRF, MFU_ERRP(-MFU_ERR_DAOS));
             local_daos_error = true;
         }
     }
@@ -489,11 +480,6 @@ static int daos_setup(
         return 1;
     }
 
-    /* set source and destination files to address of their
-     * DFS mount within DAOS */
-    mfu_src_file->dfs = da->dfs1;
-    mfu_dst_file->dfs = da->dfs2;
-
     /* Everything looks good so far */
     return 0;
 }
@@ -518,12 +504,13 @@ static int daos_cleanup(
     }
 
     if (mfu_src_file->type == DAOS) {
-        tmp_rc = dfs_umount(mfu_src_file->dfs);
+        tmp_rc = daos_umount(mfu_src_file);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed to umount DFS namespace");
             rc = 1;
         }
+
+        /* Close the container */
         tmp_rc = daos_cont_close(da->src_coh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
@@ -533,12 +520,13 @@ static int daos_cleanup(
     }
 
     if (mfu_dst_file->type == DAOS) {
-        tmp_rc = dfs_umount(mfu_dst_file->dfs);
+        tmp_rc = daos_umount(mfu_dst_file);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {
-            MFU_LOG(MFU_LOG_ERR, "Failed unmount DFS namespace");
             rc = 1;
         }
+
+        /* Close the container */
         tmp_rc = daos_cont_close(da->dst_coh, NULL);
         MPI_Barrier(MPI_COMM_WORLD);
         if (tmp_rc != 0) {

From 871d8f7d96ae01d1bf66c7e9751884f3824ee368 Mon Sep 17 00:00:00 2001
From: Dalton Bohning <daltonx.bohning@intel.com>
Date: Wed, 30 Sep 2020 00:05:36 +0000
Subject: [PATCH 27/27] libmfu: add major, minor, patch version

Added the major, minor, and patch version
to the compiled libmfu.so
The initial version is 0.0.0

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>

Signed-off-by: Dalton Bohning <daltonx.bohning@intel.com>
---
 src/common/CMakeLists.txt | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/common/CMakeLists.txt b/src/common/CMakeLists.txt
index 9bea346d..d5c83d56 100644
--- a/src/common/CMakeLists.txt
+++ b/src/common/CMakeLists.txt
@@ -1,3 +1,9 @@
+# Version for the shared mfu library
+set(MFU_VERSION_MAJOR 0) # Incompatible API changes
+set(MFU_VERSION_MINOR 0) # Backwards-compatible functionality
+set(MFU_VERSION_PATCH 0) # Backwards-compatible fixes
+set(MFU_VERSION ${MFU_VERSION_MAJOR}.${MFU_VERSION_MINOR}.${MFU_VERSION_PATCH})
+
 # todo re-asses if all of these must be *installed*
 LIST(APPEND libmfu_install_headers
   mfu.h
@@ -44,7 +50,7 @@ SET_TARGET_PROPERTIES(mfu_o PROPERTIES C_STANDARD 99)
 
 ADD_LIBRARY(mfu SHARED $<TARGET_OBJECTS:mfu_o>)
 TARGET_LINK_LIBRARIES(mfu LINK_PUBLIC ${MFU_EXTERNAL_LIBS})
-SET_TARGET_PROPERTIES(mfu PROPERTIES OUTPUT_NAME mfu CLEAN_DIRECT_OUTPUT 1)
+SET_TARGET_PROPERTIES(mfu PROPERTIES VERSION ${MFU_VERSION} OUTPUT_NAME mfu CLEAN_DIRECT_OUTPUT 1)
 INSTALL(TARGETS mfu DESTINATION ${CMAKE_INSTALL_LIBDIR})
 
 ADD_LIBRARY(mfu-static STATIC $<TARGET_OBJECTS:mfu_o>)
